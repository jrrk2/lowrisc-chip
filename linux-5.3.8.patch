diff --git a/arch/riscv/configs/defconfig b/arch/riscv/configs/defconfig
index 3efff552a..4a9b3b8a8 100644
--- a/arch/riscv/configs/defconfig
+++ b/arch/riscv/configs/defconfig
@@ -1,92 +1,2067 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/riscv 5.3.8 Kernel Configuration
+#
+
+#
+# Compiler: riscv64-unknown-linux-gnu-gcc (GCC) 9.2.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=90200
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_WARN_MAYBE_UNINITIALIZED=y
+CONFIG_IRQ_WORK=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+# CONFIG_HEADER_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_HOSTNAME="ariane-fpga"
+CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
-CONFIG_POSIX_MQUEUE=y
-CONFIG_NO_HZ_IDLE=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
+# CONFIG_NO_HZ is not set
 CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_PREEMPT_COUNT=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TINY_SRCU=y
+# end of RCU Subsystem
+
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# end of Scheduler features
+
+CONFIG_ARCH_SUPPORTS_INT128=y
 CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+# CONFIG_MEMCG_SWAP_ENABLED is not set
+CONFIG_MEMCG_KMEM=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_WRITEBACK=y
 CONFIG_CGROUP_SCHED=y
-CONFIG_CFS_BANDWIDTH=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_RDMA=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+# CONFIG_CGROUP_PERF is not set
 CONFIG_CGROUP_BPF=y
-CONFIG_NAMESPACES=y
-CONFIG_USER_NS=y
-CONFIG_CHECKPOINT_RESTORE=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_SOCK_CGROUP_DATA=y
+# CONFIG_NAMESPACES is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
 CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_INITRAMFS_FORCE=y
+CONFIG_INITRAMFS_ROOT_UID=0
+CONFIG_INITRAMFS_ROOT_GID=0
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_INITRAMFS_COMPRESSION=".gz"
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
 CONFIG_EXPERT=y
+CONFIG_MULTIUSER=y
+CONFIG_SGETMASK_SYSCALL=y
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_HAVE_FUTEX_CMPXCHG=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
 CONFIG_BPF_SYSCALL=y
-CONFIG_SOC_SIFIVE=y
-CONFIG_SMP=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_SLUB_MEMCG_SYSFS_ON=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+# CONFIG_PROFILING is not set
+# end of General setup
+
+CONFIG_64BIT=y
+CONFIG_RISCV=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA32=y
+CONFIG_PAGE_OFFSET=0xffffffe000000000
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=3
+
+#
+# SoC selection
+#
+# CONFIG_SOC_SIFIVE is not set
+# end of SoC selection
+
+#
+# Platform type
+#
+# CONFIG_ARCH_RV32I is not set
+CONFIG_ARCH_RV64I=y
+# CONFIG_CMODEL_MEDLOW is not set
+CONFIG_CMODEL_MEDANY=y
+CONFIG_MODULE_SECTIONS=y
+# CONFIG_MAXPHYSMEM_2GB is not set
+CONFIG_MAXPHYSMEM_128GB=y
+# CONFIG_SMP is not set
+CONFIG_TUNE_GENERIC=y
+CONFIG_RISCV_ISA_C=y
+
+#
+# supported PMU type
+#
+CONFIG_RISCV_BASE_PMU=y
+# end of supported PMU type
+
+CONFIG_FPU=y
+# end of Platform type
+
+#
+# Kernel features
+#
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# end of Kernel features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE="swiotlb=noforce root=/dev/rda2"
+# CONFIG_CMDLINE_FALLBACK is not set
+# CONFIG_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE_FORCE=y
+# end of Boot options
+
+#
+# Power management options
+#
+# CONFIG_PM is not set
+# end of Power management options
+
+#
+# General architecture-dependent options
+#
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_CLK=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_64BIT_TIME=y
+# CONFIG_REFCOUNT_FULL is not set
+# CONFIG_LOCK_EVENT_COUNTS is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# end of GCOV-based kernel profiling
+
+CONFIG_PLUGIN_HOSTCC="g++"
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
 CONFIG_MODULES=y
-CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+# CONFIG_MODULE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_DEV_THROTTLING is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_CGROUP_IOLATENCY is not set
+# CONFIG_BLK_DEBUG_FS is not set
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_AIX_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+# CONFIG_CMDLINE_PARTITION is not set
+# end of Partition Types
+
+CONFIG_BLK_MQ_VIRTIO=y
+
+#
+# IO Schedulers
+#
+# CONFIG_MQ_IOSCHED_DEADLINE is not set
+# CONFIG_MQ_IOSCHED_KYBER is not set
+# CONFIG_IOSCHED_BFQ is not set
+# end of IO Schedulers
+
+CONFIG_ASN1=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_HAS_MMIOWB=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_ARCH_HAS_BINFMT_FLAT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_MEMORY_BALLOON=y
+CONFIG_BALLOON_COMPACTION=y
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+# end of Memory Management options
+
 CONFIG_NET=y
+
+#
+# Networking options
+#
 CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
 CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+# CONFIG_XDP_SOCKETS is not set
 CONFIG_INET=y
-CONFIG_IP_MULTICAST=y
-CONFIG_IP_ADVANCED_ROUTER=y
-CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-CONFIG_IP_PNP_BOOTP=y
-CONFIG_IP_PNP_RARP=y
-CONFIG_NETLINK_DIAG=y
-CONFIG_PCI=y
-CONFIG_PCIEPORTBUS=y
-CONFIG_PCI_HOST_GENERIC=y
-CONFIG_PCIE_XILINX=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+# CONFIG_IP_PNP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_DNS_RESOLVER is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+# CONFIG_BPF_STREAM_PARSER is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+# CONFIG_BT_RFCOMM is not set
+# CONFIG_BT_BNEP is not set
+CONFIG_BT_HIDP=y
+CONFIG_BT_HS=y
+# CONFIG_BT_LE is not set
+CONFIG_BT_SELFTEST=y
+CONFIG_BT_DEBUGFS=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIUART=y
+# CONFIG_BT_HCIUART_H4 is not set
+CONFIG_BT_HCIUART_BCSP=y
+# CONFIG_BT_HCIUART_ATH3K is not set
+# CONFIG_BT_HCIUART_AG6XX is not set
+# CONFIG_BT_HCIVHCI is not set
+# CONFIG_BT_MRVL is not set
+# end of Bluetooth device drivers
+
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_FAILOVER=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_HAVE_PCI=y
+# CONFIG_PCI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_GENERIC_CPU_DEVICES=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+CONFIG_BLK_DEV_NULL_BLK=y
 CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_ATA_OVER_ETH=y
+CONFIG_LOWRISC_PITONSD=y
 CONFIG_VIRTIO_BLK=y
-CONFIG_BLK_DEV_SD=y
-CONFIG_BLK_DEV_SR=y
-CONFIG_ATA=y
-CONFIG_SATA_AHCI=y
-CONFIG_SATA_AHCI_PLATFORM=y
+CONFIG_VIRTIO_BLK_SCSI=y
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_SRAM is not set
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_93CX6 is not set
+# end of EEPROM support
+
+#
+# Texas Instruments shared transport line discipline
+#
+# end of Texas Instruments shared transport line discipline
+
+#
+# Altera FPGA firmware download module (requires I2C)
+#
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+# CONFIG_VOP_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# end of Intel MIC & related support
+
+# CONFIG_ECHO is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+# CONFIG_SCSI is not set
+# end of SCSI device support
+
+# CONFIG_ATA is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+# CONFIG_MD_AUTODETECT is not set
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_UNSTRIPED is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_WRITECACHE is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_DUST is not set
+# CONFIG_DM_INIT is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_LOG_WRITES is not set
+# CONFIG_DM_INTEGRITY is not set
+# CONFIG_TARGET_CORE is not set
 CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_IPVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
 CONFIG_VIRTIO_NET=y
-CONFIG_MACB=y
-CONFIG_E1000E=y
-CONFIG_R8169=y
-CONFIG_MICROSEMI_PHY=y
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# end of Distributed Switch Architecture drivers
+
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+CONFIG_NET_VENDOR_LOWRISC=y
+CONFIG_LOWRISC_DIGILENT_100MHZ=y
+CONFIG_LOWRISC_MII_INIT=y
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+CONFIG_MDIO_BITBANG=y
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_BUS_MUX_MULTIPLEXER is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_OCTEON is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+CONFIG_REALTEK_PHY=y
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Host-side USB support is needed for USB Network Adapter support
+#
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NETDEVSIM is not set
+CONFIG_NET_FAILOVER=y
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
 CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_KEYBOARD_LOWRISC=y
+# CONFIG_KEYBOARD_LOWRISC_FAKE is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+CONFIG_MOUSE_LOWRISC=y
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+# CONFIG_CONSOLE_TRANSLATIONS is not set
+# CONFIG_VT_CONSOLE is not set
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
 CONFIG_SERIAL_8250=y
-CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+# CONFIG_SERIAL_8250_DW is not set
+# CONFIG_SERIAL_8250_RT288X is not set
 CONFIG_SERIAL_OF_PLATFORM=y
+
+#
+# Non-8250 serial port support
+#
 CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_SERIAL_UARTLITE=y
+# CONFIG_SERIAL_UARTLITE_CONSOLE is not set
+CONFIG_SERIAL_UARTLITE_NR_UARTS=1
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# end of Serial drivers
+
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+CONFIG_HVC_DRIVER=y
 CONFIG_HVC_RISCV_SBI=y
-CONFIG_HW_RANDOM=y
-CONFIG_HW_RANDOM_VIRTIO=y
-CONFIG_SPI=y
-CONFIG_SPI_SIFIVE=y
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+# CONFIG_SPI is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
 # CONFIG_PTP_1588_CLOCK is not set
-CONFIG_DRM=y
-CONFIG_DRM_RADEON=y
-CONFIG_FRAMEBUFFER_CONSOLE=y
-CONFIG_USB=y
-CONFIG_USB_XHCI_HCD=y
-CONFIG_USB_XHCI_PLATFORM=y
-CONFIG_USB_EHCI_HCD=y
-CONFIG_USB_EHCI_HCD_PLATFORM=y
-CONFIG_USB_OHCI_HCD=y
-CONFIG_USB_OHCI_HCD_PLATFORM=y
-CONFIG_USB_STORAGE=y
-CONFIG_USB_UAS=y
-CONFIG_MMC=y
-CONFIG_MMC_SPI=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+# CONFIG_PINCTRL is not set
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_TQMX86 is not set
+# end of Multifunction device drivers
+
+# CONFIG_REGULATOR is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ARM devices
+#
+# end of ARM devices
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# end of ACP (Audio CoProcessor) Configuration
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_SIMPLE is not set
+CONFIG_FB_LOWRISC=y
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+# CONFIG_BACKLIGHT_CLASS_DEVICE is not set
+# end of Backlight & LCD device support
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# end of Console display driver support
+
+# CONFIG_LOGO is not set
+# end of Graphics support
+
+# CONFIG_SOUND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_UHID=y
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# end of Special HID drivers
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+CONFIG_RTC_DEBUG=y
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+
+#
+# SPI RTC drivers
+#
+
+#
+# SPI and I2C RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+CONFIG_RTC_DRV_LOWRISC=y
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_DMADEVICES is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_MENU=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
 CONFIG_VIRTIO_MMIO=y
+CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES=y
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+# CONFIG_CLK_SIFIVE is not set
+# end of Common Clock Framework
+
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_RISCV_TIMER=y
+# end of Clock Source drivers
+
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+# end of Generic IOMMU Pagetable Support
+
+# CONFIG_IOMMU_DEBUGFS is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+# CONFIG_AL_FIC is not set
+# end of IRQ chip support
+
+CONFIG_SIFIVE_PLIC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_FSL_IMX8MQ_USB is not set
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# end of Performance monitor support
+
+CONFIG_RAS=y
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+# CONFIG_NVMEM_SYSFS is not set
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+CONFIG_COUNTER=y
+# CONFIG_FTM_QUADDEC is not set
+# end of Device Drivers
+
+#
+# File systems
+#
+CONFIG_VALIDATE_FS_PARSER=y
+CONFIG_FS_IOMAP=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
 CONFIG_EXT4_FS=y
-CONFIG_EXT4_FS_POSIX_ACL=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_EXPORTFS_BLOCK_OPS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
 CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_FAT_DEFAULT_UTF8=y
+# CONFIG_NTFS_FS is not set
+# end of DOS/FAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+CONFIG_PROC_SYSCTL=y
+# CONFIG_PROC_PAGE_MONITOR is not set
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
 CONFIG_TMPFS=y
-CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+CONFIG_CONFIGFS_FS=y
+# end of Pseudo filesystems
+
+# CONFIG_MISC_FILESYSTEMS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
 CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
 CONFIG_NFS_V4_1=y
 CONFIG_NFS_V4_2=y
-CONFIG_ROOT_NFS=y
-CONFIG_CRYPTO_USER_API_HASH=y
-CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_PNFS_FILE_LAYOUT=y
+CONFIG_PNFS_BLOCK=y
+CONFIG_PNFS_FLEXFILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+CONFIG_NFS_V4_1_MIGRATION=y
+CONFIG_NFS_USE_LEGACY_DNS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_PNFS=y
+CONFIG_NFSD_BLOCKLAYOUT=y
+CONFIG_NFSD_SCSILAYOUT=y
+# CONFIG_NFSD_FLEXFILELAYOUT is not set
+# CONFIG_NFSD_FAULT_INJECTION is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_SUNRPC_BACKCHANNEL=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="yama,loadpin,safesetid,integrity"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+# CONFIG_CRYPTO_ECRDSA is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128L is not set
+# CONFIG_CRYPTO_AEGIS256 is not set
+# CONFIG_CRYPTO_MORUS640 is not set
+# CONFIG_CRYPTO_MORUS1280 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_OFB is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_STREEBOG is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HASH_INFO=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+#
+# Library routines
+#
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+CONFIG_CRC7=y
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_SWIOTLB=y
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+# CONFIG_DIMLIB is not set
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
 CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=15
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=7
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_INFO_REDUCED=y
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_DEBUG_INFO_BTF is not set
+# CONFIG_GDB_SCRIPTS is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_INSTALL is not set
+# CONFIG_OPTIMIZE_INLINING is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_MISC is not set
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_CC_HAS_KASAN_GENERIC=y
+CONFIG_KASAN_STACK=1
+# end of Memory Debugging
+
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# end of Debug Lockups and Hangs
+
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+CONFIG_DEBUG_MUTEXES=y
+# CONFIG_DEBUG_RWSEMS is not set
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+# CONFIG_STACKTRACE is not set
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+CONFIG_DEBUG_PLIST=y
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
 # CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_PREEMPTIRQ_EVENTS is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_HWLAT_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+# CONFIG_PREEMPTIRQ_DELAY_TEST is not set
+CONFIG_RUNTIME_TESTING_MENU=y
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_REED_SOLOMON_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_STRSCPY is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_BITFIELD is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_XARRAY is not set
+# CONFIG_TEST_OVERFLOW is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_IDA is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_VMALLOC is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_BLACKHOLE_DEV is not set
+# CONFIG_FIND_BIT_BENCHMARK is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+CONFIG_TEST_UDELAY=y
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_TEST_MEMCAT_P is not set
+# CONFIG_TEST_STACKINIT is not set
+# CONFIG_TEST_MEMINIT is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+# end of Kernel hacking
diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig
index 1bb8ec575..8093b6b98 100644
--- a/drivers/block/Kconfig
+++ b/drivers/block/Kconfig
@@ -394,6 +394,12 @@ config XILINX_SYSACE
 	help
 	  Include support for the Xilinx SystemACE CompactFlash interface
 
+config LOWRISC_PITONSD
+	tristate "LowRISC PitonSD support"
+	depends on RISCV
+	help
+	  Include support for the LowRISC Piton SD-Card block device
+
 config XEN_BLKDEV_FRONTEND
 	tristate "Xen virtual block device support"
 	depends on XEN
diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index a53cc1e3a..d003fc465 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_AMIGA_Z2RAM)	+= z2ram.o
 obj-$(CONFIG_BLK_DEV_RAM)	+= brd.o
 obj-$(CONFIG_BLK_DEV_LOOP)	+= loop.o
 obj-$(CONFIG_XILINX_SYSACE)	+= xsysace.o
+obj-$(CONFIG_LOWRISC_PITONSD)	+= lowrisc_pitonsd.o
 obj-$(CONFIG_CDROM_PKTCDVD)	+= pktcdvd.o
 obj-$(CONFIG_SUNVDC)		+= sunvdc.o
 obj-$(CONFIG_BLK_DEV_SKD)	+= skd.o
diff --git a/drivers/block/lowrisc_pitonsd.c b/drivers/block/lowrisc_pitonsd.c
new file mode 100644
index 000000000..0115ed004
--- /dev/null
+++ b/drivers/block/lowrisc_pitonsd.c
@@ -0,0 +1,1019 @@
+/*
+ * LowRISC_piton_sd device driver
+ *
+ * SD-Card block driver based on modified open piton FPGA driver
+ * This driver based on xsysace.c (Copyright 2007 Secret Lab Technologies Ltd.)
+ * Original copyright Grant Likely <grant.likely@secretlab.ca>
+ * Changes copyright LowRISC CIC
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+/*
+ * The LowRISC_piton_sd FPGA uses a hardware state-machine to make an SD-Card
+ * appear as a regular block device
+ * This driver is a block device driver for the LowRISC_piton_sd.
+ *
+ * Initialization:
+ *    The driver registers itself as a platform_device driver at module
+ *    load time.  The platform bus will take care of calling the
+ *    pitonsd_probe() method for all LowRISC_piton_sd instances in the system.  Any
+ *    number of LowRISC_piton_sd instances are supported in principle, but available
+ *    hardware only allows for one.  pitonsd_probe() calls
+ *    pitonsd_setup() which initialized all data structures and registers the device.
+ *    In practice the platform supports just one instance.
+ *
+ * Processing:
+ *    Just about all of the heavy lifting in this driver is performed by
+ *    a Finite State Machine (FSM).  The driver needs to wait on a number
+ *    of events; some raised by interrupts, some which need to be polled
+ *    for.  Describing all of the behaviour in a FSM seems to be the
+ *    easiest way to keep the complexity low and make it easy to
+ *    understand what the driver is doing.  If the block ops or the
+ *    request function need to interact with the hardware, then they
+ *    simply need to flag the request and kick of FSM processing.
+ *
+ *    The FSM itself is atomic-safe code which can be run from any
+ *    context. It is always called when the hardware is idle.
+ *    The general process flow is:
+ *    1. obtain the sdpiton->lock spinlock.
+ *    2. Switch on the previous activity that occurred before idle.
+ *    3. Copy or verify the buffers.
+ *    4. Check for new requests.
+ *
+ *    Additionally, the driver maintains a kernel timer which can kick in
+ *    if the state machine fails to return to idle. This could happen if
+ *    the user foolishly removes the disk whilst it is mounted, for example.
+ *
+ *    A quirk of the hardware architecture is that it forgets to inquire the SD-Card
+ *    capacity. This is worked around by reading the partition table, and taking it as read.
+ */
+
+#undef DEBUG
+//#define DEBUG
+
+#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/blk-mq.h>
+#include <linux/mutex.h>
+#include <linux/ata.h>
+#include <linux/hdreg.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+
+#include "../../block/partitions/check.h"
+#include "lowrisc_pitonsd.h"
+
+MODULE_AUTHOR("Jonathan Kimmitt <jrrk2@cam.ac.uk>");
+MODULE_DESCRIPTION("LowRISC_piton_sd device driver");
+MODULE_LICENSE("GPL");
+
+/* FSM tasks; used to direct state transitions */
+
+enum {
+  _piton_sd_TASK_IDLE      ,
+  _piton_sd_TASK_VERIFY    ,
+  _piton_sd_TASK_READ      ,
+  _piton_sd_TASK_WRITE     };
+
+struct pitonsd_device {
+	/* driver state data */
+	struct list_head list;
+
+	/* finite state machine data */
+	struct tasklet_struct fsm_tasklet;
+	uint fsm_task;		/* Current activity (_piton_sd_TASK_*) */
+	uint fsm_iter_num;
+	struct timer_list stall_timer;
+
+	/* Transfer state/result, use for both id and block request */
+	struct request *req;	/* request being processed */
+        uint data_pos;          /* data (sector) position */
+	int data_result;	/* Result of transfer; 0 := success */
+        int blkcnt;             /* sectors in current transaction */
+        int iter;               /* current sector in transaction */
+
+	/* Details of hardware device */
+        resource_size_t physaddr, physaddrend;
+        volatile u64 __iomem *baseaddr, *ioptr;
+	int irq;
+
+	/* Block device data structures */
+	spinlock_t lock;
+	struct device *dev;
+	struct request_queue *queue;
+	struct gendisk *gd;
+	struct blk_mq_tag_set tag_set;
+	struct list_head rq_list;
+
+        /* error status */
+        blk_status_t iostat;
+};
+
+static int pitonsd_major, pitonsd_nxt_devid;
+
+/* ---------------------------------------------------------------------
+ * Debug support functions
+ */
+
+static void pitonsd_dump_regs(struct pitonsd_device *sdpiton)
+{
+  const char *init_state, *tran_state, *driver_status;
+  char status[99];
+  int stat = sdpiton->baseaddr[_piton_sd_STATUS];
+  *status = 0;
+  if (stat&1) strcat(status," REQ_RD");
+  if (stat&2) strcat(status," REQ_WR");
+  if (stat&4) strcat(status," IRQ_EN");
+  if (stat&8) strcat(status," SD_IRQ");
+  if (stat&16) strcat(status," REQ_RDY");
+  if (stat&32) strcat(status," INIT_DONE");
+  if (stat&64) strcat(status," HCXC");
+  if (stat&128) strcat(status," DETECT");
+  switch(sdpiton->baseaddr[_piton_sd_INIT_STATE])
+    {
+    case 0x0: init_state = "ST_CI_EN_SW_RST"; break;
+    case 0x1: init_state = "ST_CI_DAT_TIMEOUT"; break;
+    case 0x2: init_state = "ST_CI_BUS_WIDTH"; break;
+    case 0x3: init_state = "ST_CI_CMD_TIMEOUT"; break;
+    case 0x4: init_state = "ST_CI_CMD_ISER"; break;
+    case 0x5: init_state = "ST_CI_DAT_ISER"; break;
+    case 0x6: init_state = "ST_CI_BLK_SIZE"; break;
+    case 0x7: init_state = "ST_CI_BLK_COUNT"; break;
+    case 0x8: init_state = "ST_CI_CLOCK_DIV"; break;
+    case 0x9: init_state = "ST_CI_DE_SW_RST"; break;
+    case 0xa: init_state = "ST_CI_WAIT_POWER"; break;
+
+    case 0x10: init_state = "ST_CMD0_CLR_CMD_ISR"; break;
+    case 0x11: init_state = "ST_CMD0_WAIT_CLR"; break;
+    case 0x12: init_state = "ST_CMD0_CMD"; break;
+    case 0x13: init_state = "ST_CMD0_ARG"; break;
+    case 0x14: init_state = "ST_CMD0_WAIT_INT"; break;
+    case 0x15: init_state = "ST_CMD0_RD_CMD_ISR"; break;
+
+    case 0x20: init_state = "ST_CMD8_CLR_CMD_ISR"; break;
+    case 0x21: init_state = "ST_CMD8_WAIT_CLR"; break;
+    case 0x22: init_state = "ST_CMD8_CMD"; break;
+    case 0x23: init_state = "ST_CMD8_ARG"; break;
+    case 0x24: init_state = "ST_CMD8_WAIT_INT"; break;
+    case 0x25: init_state = "ST_CMD8_RD_CMD_ISR"; break;
+    case 0x26: init_state = "ST_CMD8_RD_RESP0"; break;
+
+    case 0x30: init_state = "ST_ACMD41_CMD55_CLR_CMD_ISR"; break;
+    case 0x31: init_state = "ST_ACMD41_CMD55_WAIT_CLR"; break;
+    case 0x32: init_state = "ST_ACMD41_CMD55_CMD"; break;
+    case 0x33: init_state = "ST_ACMD41_CMD55_ARG"; break;
+    case 0x34: init_state = "ST_ACMD41_CMD55_WAIT_INT"; break;
+    case 0x35: init_state = "ST_ACMD41_CMD55_RD_CMD_ISR"; break;
+    case 0x36: init_state = "ST_ACMD41_CMD55_RD_RESP0"; break;
+
+    case 0x40: init_state = "ST_ACMD41_CLR_CMD_ISR"; break;
+    case 0x41: init_state = "ST_ACMD41_WAIT_CLR"; break;
+    case 0x42: init_state = "ST_ACMD41_CMD"; break;
+    case 0x43: init_state = "ST_ACMD41_ARG"; break;
+    case 0x44: init_state = "ST_ACMD41_WAIT_INT"; break;
+    case 0x45: init_state = "ST_ACMD41_RD_CMD_ISR"; break;
+    case 0x46: init_state = "ST_ACMD41_RD_RESP0"; break;
+    case 0x47: init_state = "ST_ACMD41_WAIT_INTERVAL"; break;
+
+    case 0x50: init_state = "ST_CMD2_CLR_CMD_ISR"; break;
+    case 0x51: init_state = "ST_CMD2_WAIT_CLR"; break;
+    case 0x52: init_state = "ST_CMD2_CMD"; break;
+    case 0x53: init_state = "ST_CMD2_ARG"; break;
+    case 0x54: init_state = "ST_CMD2_WAIT_INT"; break;
+    case 0x55: init_state = "ST_CMD2_RD_CMD_ISR"; break;
+
+    case 0x60: init_state = "ST_CMD3_CLR_CMD_ISR"; break;
+    case 0x61: init_state = "ST_CMD3_WAIT_CLR"; break;
+    case 0x62: init_state = "ST_CMD3_CMD"; break;
+    case 0x63: init_state = "ST_CMD3_ARG"; break;
+    case 0x64: init_state = "ST_CMD3_WAIT_INT"; break;
+    case 0x65: init_state = "ST_CMD3_RD_CMD_ISR"; break;
+    case 0x66: init_state = "ST_CMD3_RD_RESP0"; break;
+
+    case 0x70: init_state = "ST_HS_EN_SW_RST"; break;
+    case 0x71: init_state = "ST_HS_CLOCK_DIV"; break;
+    case 0x72: init_state = "ST_HS_DE_SW_RST"; break;
+
+    case 0x80: init_state = "ST_CMD7_CLR_CMD_ISR"; break;
+    case 0x81: init_state = "ST_CMD7_WAIT_CLR"; break;
+    case 0x82: init_state = "ST_CMD7_CMD"; break;
+    case 0x83: init_state = "ST_CMD7_ARG"; break;
+    case 0x84: init_state = "ST_CMD7_WAIT_INT"; break;
+    case 0x85: init_state = "ST_CMD7_RD_CMD_ISR"; break;
+    case 0x86: init_state = "ST_CMD7_RD_RESP0"; break;
+
+    case 0x90: init_state = "ST_ACMD6_CMD55_CLR_CMD_ISR"; break;
+    case 0x91: init_state = "ST_ACMD6_CMD55_WAIT_CLR"; break;
+    case 0x92: init_state = "ST_ACMD6_CMD55_CMD"; break;
+    case 0x93: init_state = "ST_ACMD6_CMD55_ARG"; break;
+    case 0x94: init_state = "ST_ACMD6_CMD55_WAIT_INT"; break;
+    case 0x95: init_state = "ST_ACMD6_CMD55_RD_CMD_ISR"; break;
+    case 0x96: init_state = "ST_ACMD6_CMD55_RD_RESP0"; break;
+
+    case 0xa0: init_state = "ST_ACMD6_CLR_CMD_ISR"; break;
+    case 0xa1: init_state = "ST_ACMD6_WAIT_CLR"; break;
+    case 0xa2: init_state = "ST_ACMD6_CMD"; break;
+    case 0xa3: init_state = "ST_ACMD6_ARG"; break;
+    case 0xa4: init_state = "ST_ACMD6_WAIT_INT"; break;
+    case 0xa5: init_state = "ST_ACMD6_RD_CMD_ISR"; break;
+    case 0xa6: init_state = "ST_ACMD6_RD_RESP0"; break;
+
+    case 0xb0: init_state = "ST_FIN_CLR_CMD_ISR"; break;
+    case 0xb1: init_state = "ST_FIN_CLR_DAT_ISR"; break;
+
+    case 0xf0: init_state = "ST_INIT_DONE"; break;
+    case 0xff: init_state = "ST_INIT_ERR"; break;
+    default: init_state = "UNKNOWN";
+    }
+  switch(sdpiton->baseaddr[_piton_sd_TRAN_STATE])
+    {
+    case 0x3f: tran_state = "ST_RST"; break;
+
+    case 0x00: tran_state = "ST_IDLE"; break;
+    case 0x01: tran_state = "ST_OK_RESP_PENDING"; break;
+    case 0x02: tran_state = "ST_ERR_RESP_PENDING"; break;
+    case 0x03: tran_state = "ST_CLR_CMD_ISR"; break;
+    case 0x04: tran_state = "ST_CLR_DAT_ISR"; break;
+
+    case 0x10: tran_state = "ST_CMD17_DMA"; break;
+    case 0x11: tran_state = "ST_CMD17_CMD"; break;
+    case 0x12: tran_state = "ST_CMD17_WAIT_CLR"; break;
+    case 0x13: tran_state = "ST_CMD17_ARG"; break;
+    case 0x14: tran_state = "ST_CMD17_WAIT_CMD_INT"; break;
+    case 0x15: tran_state = "ST_CMD17_RD_CMD_ISR"; break;
+    case 0x16: tran_state = "ST_CMD17_RD_RESP0"; break;
+    case 0x17: tran_state = "ST_CMD17_WAIT_DATA_INT"; break;
+    case 0x18: tran_state = "ST_CMD17_RD_DATA_ISR"; break;
+
+    case 0x20: tran_state = "ST_CMD24_DMA"; break;
+    case 0x21: tran_state = "ST_CMD24_CMD"; break;
+    case 0x22: tran_state = "ST_CMD24_WAIT_CLR"; break;
+    case 0x23: tran_state = "ST_CMD24_ARG"; break;
+    case 0x24: tran_state = "ST_CMD24_WAIT_CMD_INT"; break;
+    case 0x25: tran_state = "ST_CMD24_RD_CMD_ISR"; break;
+    case 0x26: tran_state = "ST_CMD24_RD_RESP0"; break;
+    case 0x27: tran_state = "ST_CMD24_WAIT_DATA_INT"; break;
+    case 0x28: tran_state = "ST_CMD24_RD_DATA_ISR"; break;
+    default: tran_state = "UNKNOWN";
+    }
+  switch(sdpiton->fsm_task)
+    {
+    case  _piton_sd_TASK_IDLE      : driver_status = "piton_sd_TASK_IDLE      "; break;
+    case  _piton_sd_TASK_VERIFY    : driver_status = "piton_sd_TASK_VERIFY    "; break;
+    case  _piton_sd_TASK_READ      : driver_status = "piton_sd_TASK_READ      "; break;
+    case  _piton_sd_TASK_WRITE     : driver_status = "piton_sd_TASK_WRITE     "; break;
+    default: driver_status = "unknown";
+    }
+  printk(
+        "    sd_f:  0x%llx  dma_f: 0x%llx status: %s\n"
+        "    resp_vec: 0x%llx  init_state: %s  counter: 0x%llx\n"
+        "    init_fsm: 0x%llx  tran_state: %s  tran_fsm: 0x%llx\n"
+        "    driver_status: %s\n",
+        sdpiton->baseaddr[_piton_sd_ADDR_SD_F],
+        sdpiton->baseaddr[_piton_sd_ADDR_DMA_F],
+        status,
+        sdpiton->baseaddr[_piton_sd_ERROR],
+        init_state,
+        sdpiton->baseaddr[_piton_sd_COUNTER],
+        sdpiton->baseaddr[_piton_sd_INIT_FSM],
+        tran_state,
+        sdpiton->baseaddr[_piton_sd_TRAN_FSM],
+        driver_status);
+}
+
+/* ---------------------------------------------------------------------
+ * Finite State Machine (FSM) implementation
+ */
+
+#define TIMEOUT (HZ*10)
+
+static inline void my_cpy(char *dst0, const char *src0, int siz)
+{
+  int i;
+  uint64_t *dst = (uint64_t *)dst0;
+  uint64_t *src = (uint64_t *)src0;
+  if (siz > PAGE_SIZE)
+    printk("siz %d > PAGE_SIZE\n", siz);
+  for (i = siz/sizeof(uint64_t); i--; )
+    {
+      *dst++ = *src++;
+    }
+}
+
+static inline int my_cmp(char *src0, const char *src1, int siz)
+{
+  int i;
+  uint64_t *cmp0 = (uint64_t *)src0;
+  uint64_t *cmp1 = (uint64_t *)src1;
+  if (siz > PAGE_SIZE)
+    printk("siz %d > PAGE_SIZE\n", siz);
+  for (i = siz/sizeof(uint64_t); i-=8; )
+    {
+      if (*cmp0++ != *cmp1++)
+        return 1;
+    }
+  return 0;
+}
+
+static void pattern_transfer(struct pitonsd_device *sdpiton, int off, void *buf, int buflen)
+{
+  int i;
+  uint64_t *dst = (uint64_t *)(off + (char*)(sdpiton->ioptr));
+  if (buflen > PAGE_SIZE)
+    printk("buflen %d > PAGE_SIZE\n", buflen);
+  for (i = buflen/sizeof(uint64_t); i--; )
+    {
+      *dst++ = 0xDEADBEEFC001F00DULL;
+    }
+  wmb();
+}
+
+static void write_transfer(struct pitonsd_device *sdpiton, int off, void *buf, int buflen)
+{
+#ifdef SIMPLE_DEBUG
+  printk("write_data 0x%llx 0x%llx 0x%x\n", (u64)((off >> SECTOR_SHIFT) + sdpiton->data_pos), (u64)buf, buflen);
+#else
+  pr_debug("W 0x%llx 0x%llx 0x%llx 0x%x\n", (u64)off, (u64)(sdpiton->data_pos), (u64)buf, buflen);
+#endif
+  my_cpy(off + (char*)(sdpiton->ioptr), buf, buflen);
+  wmb();
+}
+
+static void read_transfer(struct pitonsd_device *sdpiton, int off, void *buf, int buflen)
+{
+#ifdef SIMPLE_DEBUG
+  printk("read_data 0x%llx 0x%llx 0x%x\n", (u64)((off >> SECTOR_SHIFT) + sdpiton->data_pos), (u64)buf, buflen);
+#else
+  pr_debug("R 0x%llx 0x%llx 0x%llx 0x%x\n", (u64)off, (u64)(sdpiton->data_pos), (u64)buf, buflen);
+#endif
+  my_cpy(buf, off + (char*)(sdpiton->ioptr), buflen);
+#ifdef DEBUG_VERBOSE
+  {
+    int j;
+    u8 *dbgptr = buf;
+    for (i = 0; i < 512; i+=32)
+      {
+        char tmpbuf[100];
+        for (j = 0; j < 32; j++) sprintf(tmpbuf+j*3, "%.2X ", dbgptr[i+j]);
+        pr_debug("%.3X: %s", i, tmpbuf);
+      }
+  }
+#endif
+  wmb();
+}
+
+static void verify_transfer(struct pitonsd_device *sdpiton, int off, void *buf, int buflen)
+{
+  u8 *ioptr = off + (char*)(sdpiton->ioptr);
+  u8 *dbgptr = buf;
+#ifdef SIMPLE_DEBUG
+  printk("verify_data 0x%llx 0x%llx 0x%x\n", (u64)((off >> SECTOR_SHIFT) + sdpiton->data_pos), (u64)buf, buflen);
+#else
+  pr_debug("V 0x%llx 0x%llx 0x%llx 0x%x\n", (u64)off, (u64)(sdpiton->data_pos), (u64)buf, buflen);
+#endif
+  if (my_cmp(dbgptr, ioptr, buflen))
+    {
+#ifdef VERIFY_DEBUG      
+      int i, j;
+      for (i = 0; i < 512; i+=32)
+        {
+          char tmpbuf[100];
+          for (j = 0; j < 32; j++) sprintf(tmpbuf+j*3, "%.2X ", dbgptr[i+j]);
+          printk("%.3X: %s\n", i, tmpbuf);
+          for (j = 0; j < 32; j++) sprintf(tmpbuf+j*3, "%.2X ", ioptr[i+j]);
+          printk("%.3X: %s\n", i, tmpbuf);
+        }
+#endif      
+      sdpiton->iostat = BLK_STS_AGAIN;
+    }
+}
+
+static int my_rq_foreach(struct pitonsd_device *sdpiton, void (*my_transfer)(struct pitonsd_device *, int, void *, int))
+{
+  int off = 0;
+  struct bio_vec bvec;        /* iteration control */
+  struct req_iterator iter;
+#ifdef DEBUG_VERBOSE
+  pitonsd_dump_regs(sdpiton);
+#endif
+  rq_for_each_segment(bvec, sdpiton->req, iter)
+    {
+      my_transfer(sdpiton, off, page_address(bvec.bv_page) + bvec.bv_offset, bvec.bv_len);
+      off += bvec.bv_len;
+    }
+  return off >> SECTOR_SHIFT;
+}
+
+static bool pitonsd_has_next_request(struct request_queue *q)
+{
+	struct pitonsd_device *sdpiton = q->queuedata;
+
+	return !list_empty(&sdpiton->rq_list);
+}
+
+/* Get the next read/write request; ending requests that we don't handle */
+static struct request *pitonsd_get_next_request(struct request_queue *q)
+{
+	struct pitonsd_device *sdpiton = q->queuedata;
+	struct request *rq;
+
+	rq = list_first_entry_or_null(&sdpiton->rq_list, struct request, queuelist);
+	if (rq) {
+		list_del_init(&rq->queuelist);
+		blk_mq_start_request(rq);
+                return rq;
+	}
+
+	return NULL;
+}
+
+static void task_prepare(struct pitonsd_device *sdpiton)
+{
+                int dir = rq_data_dir(sdpiton->req); /* direction */
+                /* count buffers to be transferred, and clear the hardware buffer */
+                sdpiton->blkcnt = my_rq_foreach(sdpiton, pattern_transfer);
+
+                sdpiton->data_pos = blk_rq_pos(sdpiton->req);
+
+		pr_debug(
+			"request: sec=0x%llx dir=0x%i blkcnt=0x%i\n",
+			(unsigned long long)(sdpiton->data_pos),
+			dir, sdpiton->blkcnt);
+
+		if (dir) {
+                        /* copy buffers to be written */
+                        my_rq_foreach(sdpiton, write_transfer);
+                        /* Kick off write request */
+                        wmb();
+                        sdpiton->iter = 0;
+			sdpiton->fsm_task = _piton_sd_TASK_WRITE;
+                        /* SD sector address */
+                        sdpiton->baseaddr[ _piton_sd_ADDR_SD ] = sdpiton->data_pos;
+                        /* always start at beginning of DMA buffer */
+                        sdpiton->baseaddr[ _piton_sd_ADDR_DMA ] = 0;
+                        /* set sector count */
+	                sdpiton->baseaddr[ _piton_sd_BLKCNT ] = 1; /* this is a BUG, should be blkcnt */
+			sdpiton->baseaddr[ _piton_sd_REQ_WR ] = 1;
+                        sdpiton->baseaddr[ _piton_sd_IRQ_EN ] = 1;
+                        wmb();
+#ifdef SIMPLE_DEBUG
+                        printk("write_buffer 0x%llx 0x%llx\n", (u64)(sdpiton->data_pos), (u64)(sdpiton->blkcnt));
+#endif
+		} else {
+			/* Kick off read request */
+			sdpiton->fsm_task = _piton_sd_TASK_READ;
+                        /* SD sector address */
+                        sdpiton->baseaddr[ _piton_sd_ADDR_SD ] = sdpiton->data_pos;
+                        /* always start at beginning of DMA buffer */
+                        sdpiton->baseaddr[ _piton_sd_ADDR_DMA ] = 0;
+                        /* set sector count */
+	                sdpiton->baseaddr[ _piton_sd_BLKCNT ] = sdpiton->blkcnt;
+			sdpiton->baseaddr[ _piton_sd_REQ_RD ] = 1;
+                        sdpiton->baseaddr[ _piton_sd_IRQ_EN ] = 1;
+                        wmb();
+#ifdef SIMPLE_DEBUG
+                        printk("read_buffer 0x%llx 0x%llx\n", (u64)(sdpiton->data_pos), (u64)(sdpiton->blkcnt));
+#endif
+		}
+ }
+
+static void pitonsd_fsm_tasklet(unsigned long data)
+{
+	struct pitonsd_device *sdpiton = (void *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sdpiton->lock, flags);
+
+        if (sdpiton->req)
+          {
+            u64 mask, creg;
+            sdpiton->iostat = BLK_STS_OK;
+            /* Transfer the next buffer */
+            switch (sdpiton->fsm_task)
+              {
+              case _piton_sd_TASK_READ:
+                sdpiton->baseaddr[ _piton_sd_REQ_RD ] = 0;
+                /* Copy the read buffers */
+                my_rq_foreach(sdpiton, read_transfer);
+                mask = (1 << sdpiton->blkcnt) - 1;
+                creg = sdpiton->baseaddr[ _piton_sd_ERROR ] & mask;
+                /* Check for error occurrence */
+                if (mask != creg)
+                  {
+#ifdef SIMPLE_DEBUG
+                    dev_err(sdpiton->dev, "transfer failure (mask=%llx, creg=%llx)\n", mask, creg);
+#endif
+                    task_prepare(sdpiton);
+                    sdpiton->iostat = BLK_STS_AGAIN;
+                  }
+                else
+                  {
+                    blk_mq_end_request(sdpiton->req, sdpiton->iostat);
+                    sdpiton->req = NULL;
+                  }
+                tasklet_schedule(&sdpiton->fsm_tasklet);
+                break;
+              case _piton_sd_TASK_WRITE:
+                sdpiton->baseaddr[ _piton_sd_REQ_WR ] = 0;
+                sdpiton->baseaddr[ _piton_sd_ADDR_DMA ] = 0;
+                if (++(sdpiton->iter) == sdpiton->blkcnt)
+                  {
+                    my_rq_foreach(sdpiton, pattern_transfer);
+                    /* SD sector address */
+                    sdpiton->baseaddr[ _piton_sd_ADDR_SD ] = sdpiton->data_pos;
+                    /* always start at beginning of DMA buffer */
+                    sdpiton->baseaddr[ _piton_sd_ADDR_DMA ] = 0;
+                    /* set sector count for verify operation */
+                    sdpiton->baseaddr[ _piton_sd_BLKCNT ] = sdpiton->blkcnt;
+                    sdpiton->baseaddr[ _piton_sd_REQ_RD ] = 1;
+                    sdpiton->baseaddr[ _piton_sd_IRQ_EN ] = 1;
+                    sdpiton->fsm_task = _piton_sd_TASK_VERIFY;
+                  }
+                else
+                  {
+                    /* SD sector address */
+                    sdpiton->baseaddr[ _piton_sd_ADDR_SD ] = sdpiton->data_pos + sdpiton->iter;
+                    /* advance DMA address */
+                    sdpiton->baseaddr[ _piton_sd_ADDR_DMA ] = (sdpiton->iter) << SECTOR_SHIFT;
+                    sdpiton->baseaddr[ _piton_sd_REQ_WR ] = 1;
+                    sdpiton->baseaddr[ _piton_sd_IRQ_EN ] = 1;
+                  }
+                break;
+              case _piton_sd_TASK_VERIFY:
+                sdpiton->baseaddr[ _piton_sd_REQ_RD ] = 0;
+                my_rq_foreach(sdpiton, verify_transfer);
+                /* Check for error occurrence */
+                if (sdpiton->iostat != BLK_STS_OK)
+                  {
+                    dev_err(sdpiton->dev, "SD-Card write verify failure, sector %d\n", sdpiton->data_pos);
+                    task_prepare(sdpiton);
+                  }
+                else
+                  {
+                    blk_mq_end_request(sdpiton->req, sdpiton->iostat);
+                    sdpiton->req = NULL;
+                  }
+                tasklet_schedule(&sdpiton->fsm_tasklet);
+                break;
+              default:
+                pitonsd_dump_regs(sdpiton);
+              }
+            
+          }
+        else if (pitonsd_has_next_request(sdpiton->queue))
+          {
+            mod_timer(&sdpiton->stall_timer, jiffies + TIMEOUT);
+            if (!timer_pending(&sdpiton->stall_timer))
+              add_timer(&sdpiton->stall_timer);
+            sdpiton->req = pitonsd_get_next_request(sdpiton->queue);
+            if (sdpiton->req)
+              task_prepare(sdpiton);
+            else
+              {
+                pr_debug("prepare was empty");
+                tasklet_schedule(&sdpiton->fsm_tasklet);                
+              }
+            
+          }
+        else
+          {
+            del_timer(&sdpiton->stall_timer);
+          }
+	spin_unlock_irqrestore(&sdpiton->lock, flags);
+}
+
+static void pitonsd_card_reset(struct pitonsd_device *sdpiton)
+{
+  /* Verify that there is actually a SD-Card in the slot. If not, then
+   * bail out back to the idle state and wake up all the waiters */
+  
+  if (_piton_sd_STATUS_SD_DETECT & sdpiton->baseaddr[_piton_sd_STATUS])
+    {
+      set_capacity(sdpiton->gd, 0);
+      dev_info(sdpiton->dev, "No SD-Card in slot\n");
+      
+      /* Drop all in-flight and pending requests */
+      if (sdpiton->req) {
+        blk_mq_end_request(sdpiton->req, BLK_STS_IOERR);
+        sdpiton->req = NULL;
+        
+      }
+    while ((sdpiton->req = pitonsd_get_next_request(sdpiton->queue)) != NULL)
+      blk_mq_end_request(sdpiton->req, BLK_STS_IOERR);
+    }
+  else
+    {
+      int init_state, old_init_state = -1;
+      /* SD sector address */
+      sdpiton->baseaddr[ _piton_sd_ADDR_SD ] = 0;
+      /* always start at beginning of DMA buffer */
+      sdpiton->baseaddr[ _piton_sd_ADDR_DMA ] = 0;
+      /* set sector count */
+      sdpiton->baseaddr[ _piton_sd_BLKCNT ] = 0;
+      sdpiton->baseaddr[ _piton_sd_REQ_RD ] = 0;
+      sdpiton->baseaddr[ _piton_sd_REQ_WR ] = 0;
+      sdpiton->baseaddr[ _piton_sd_IRQ_EN ] = 0;
+      sdpiton->baseaddr[ _piton_sd_SYS_RST ] = 0;
+      
+      /* reset HW state machine */
+      sdpiton->baseaddr[ _piton_sd_SYS_RST ] = 1;
+
+      do
+        {
+          fence();
+          init_state = sdpiton->baseaddr[_piton_sd_INIT_STATE];
+          if (old_init_state != init_state)
+            pitonsd_dump_regs(sdpiton);
+          old_init_state = init_state;
+        }
+      while (_piton_sd_STATUS_INIT_DONE & ~sdpiton->baseaddr[_piton_sd_STATUS]);
+      
+      pitonsd_dump_regs(sdpiton);
+    }
+}
+
+static void pitonsd_stall_timer(struct timer_list *t)
+{
+	struct pitonsd_device *sdpiton = from_timer(sdpiton, t, stall_timer);
+	unsigned long flags;
+        
+	dev_warn(sdpiton->dev, "kicking stalled fsm; status=%lld task=%i iter=%i\n",
+		 sdpiton->baseaddr[_piton_sd_STATUS], sdpiton->fsm_task, sdpiton->fsm_iter_num);
+
+        pitonsd_dump_regs(sdpiton);
+        
+	/* Rearm the stall timer *before* entering FSM (which may then
+	 * delete the timer) */
+        
+	mod_timer(&sdpiton->stall_timer, jiffies + TIMEOUT);
+
+        /* If the card is idle and we missed the interrupt (can this happen ?)
+           call the tasklet to find the next action */
+        
+        if (sdpiton->baseaddr[_piton_sd_STATUS] & _piton_sd_STATUS_REQ_RDY)
+          {
+            /* SD card is ready */
+            spin_lock_irqsave(&sdpiton->lock, flags);
+            tasklet_schedule(&sdpiton->fsm_tasklet);
+            spin_unlock_irqrestore(&sdpiton->lock, flags);
+          }
+        else if (sdpiton->req)
+          {
+            pitonsd_card_reset(sdpiton);
+            task_prepare(sdpiton);
+          }
+        
+}
+
+/* ---------------------------------------------------------------------
+ * Interrupt handling routines
+ * The hardware only interrupts when it reaches idle and either REQ_RD or REQ_WR is high
+ */
+
+static irqreturn_t pitonsd_interrupt(int irq, void *dev_id)
+{
+	struct pitonsd_device *sdpiton = dev_id;
+
+	/* be safe and get the lock */
+	spin_lock(&sdpiton->lock);
+
+	/* clear the interrupt */
+	sdpiton->baseaddr[ _piton_sd_IRQ_EN ] = 0;
+
+	tasklet_schedule(&sdpiton->fsm_tasklet);
+
+	/* done with interrupt; drop the lock */
+	spin_unlock(&sdpiton->lock);
+
+	return IRQ_HANDLED;
+}
+
+/* ---------------------------------------------------------------------
+ * Block ops
+ */
+static blk_status_t pitonsd_queue_rq(struct blk_mq_hw_ctx *hctx,
+				 const struct blk_mq_queue_data *bd)
+{
+	struct pitonsd_device *sdpiton = hctx->queue->queuedata;
+	struct request *req = bd->rq;
+        int idle = (sdpiton->req == NULL) && !pitonsd_has_next_request(sdpiton->queue);
+        
+	if (blk_rq_is_passthrough(req)) {
+		blk_mq_start_request(req);
+		return BLK_STS_IOERR;
+	}
+        
+	spin_lock_irq(&sdpiton->lock);
+	list_add_tail(&req->queuelist, &sdpiton->rq_list);
+	spin_unlock_irq(&sdpiton->lock);
+
+	if (idle)
+          tasklet_schedule(&sdpiton->fsm_tasklet);
+	return BLK_STS_OK;
+}
+
+static void pitonsd_unlock_native_capacity(struct gendisk *disk)
+{
+        int p;
+	size_t inferred_capacity = 1;
+        struct block_device *bdev = bdget_disk(disk, 0);
+        struct parsed_partitions *mbr = check_partition(disk, bdev);
+        printk("native partitions %d", mbr->limit);
+        for (p = 1; p < mbr->limit; p++) {
+                sector_t size, from;
+
+                size = mbr->parts[p].size;
+                if (!size)
+                        continue;
+
+                from = mbr->parts[p].from;
+                printk("%s: p%d start %llu size %llu",
+                       disk->disk_name, p,
+                       (unsigned long long) from,
+                       (unsigned long long) size);
+                if (from + size > inferred_capacity) {
+                  inferred_capacity = from + size;
+                }
+        }
+        printk("Inferred capacity %lu", inferred_capacity);
+        set_capacity(disk, inferred_capacity); // should come from hardware
+}
+
+static const struct block_device_operations pitonsd_fops = {
+	.owner = THIS_MODULE,
+        .unlock_native_capacity = pitonsd_unlock_native_capacity,
+};
+
+static const struct blk_mq_ops pitonsd_mq_ops = {
+	.queue_rq	= pitonsd_queue_rq,
+};
+
+/* --------------------------------------------------------------------
+ * LowRISC_piton_sd device setup/teardown code
+ */
+static int pitonsd_setup(struct pitonsd_device *sdpiton, int sdpiton_id)
+{
+        int rc;
+        
+	printk("pitonsd_setup(sdpiton=0x%llx)\n", (u64)sdpiton);
+
+	spin_lock_init(&sdpiton->lock);
+	INIT_LIST_HEAD(&sdpiton->rq_list);
+
+	/*
+	 * Map the device
+	 */
+	sdpiton->baseaddr = ioremap(sdpiton->physaddr, sdpiton->physaddrend - sdpiton->physaddr);
+        sdpiton->ioptr = sdpiton->baseaddr+0x1000;
+	if (!sdpiton->baseaddr)
+		goto err_ioremap;
+
+	printk("physaddr=0x%llx, vstart=%llx, vsiz=%llx, irq=%i\n",
+		(unsigned long long)sdpiton->physaddr,
+		(unsigned long long)sdpiton->baseaddr,
+                (unsigned long long)(sdpiton->physaddrend - sdpiton->physaddr),
+                sdpiton->irq);
+
+        pitonsd_card_reset(sdpiton);
+	/*
+	 * Initialize the state machine tasklet and stall timer
+	 */
+	tasklet_init(&sdpiton->fsm_tasklet, pitonsd_fsm_tasklet, (unsigned long)sdpiton);
+
+	timer_setup(&sdpiton->stall_timer, pitonsd_stall_timer, 0);
+
+	/*
+	 * Initialize the request queue
+	 */
+	sdpiton->queue = blk_mq_init_sq_queue(&sdpiton->tag_set, &pitonsd_mq_ops, 2, BLK_MQ_F_SHOULD_MERGE);
+	if (IS_ERR(sdpiton->queue)) {
+		rc = PTR_ERR(sdpiton->queue);
+		sdpiton->queue = NULL;
+		goto err_blk_initq;
+        }
+        sdpiton->queue->queuedata = sdpiton;
+        
+	blk_queue_bounce_limit(sdpiton->queue, BLK_BOUNCE_HIGH);
+
+	/*
+	 * Allocate and initialize GD structure
+	 */
+	sdpiton->gd = alloc_disk(_piton_sd_NUM_MINORS);
+	if (!sdpiton->gd)
+		goto err_alloc_disk;
+
+	sdpiton->gd->major = pitonsd_major;
+	sdpiton->gd->first_minor = sdpiton_id * _piton_sd_NUM_MINORS;
+	sdpiton->gd->fops = &pitonsd_fops;
+	sdpiton->gd->queue = sdpiton->queue;
+	sdpiton->gd->private_data = sdpiton;
+	snprintf(sdpiton->gd->disk_name, 32, "rd%c", sdpiton_id + 'a');
+        // We haven't read the partition table yet, so return a legacy capacity value
+        set_capacity(sdpiton->gd, 255*1023*31); // dummy (255 heads, 1023 cyl, 31 sectors)
+        /* Tell the block layer that this is not a rotational device */
+        blk_queue_flag_set(QUEUE_FLAG_NONROT, sdpiton->queue);
+        //        blk_queue_flag_clear(QUEUE_FLAG_ADD_RANDOM, sdpiton->queue);
+        blk_queue_max_hw_sectors(sdpiton->queue, 8);
+        sdpiton->queue->limits.max_sectors = queue_max_hw_sectors(sdpiton->queue);
+        blk_queue_max_segments(sdpiton->queue, 8);
+        blk_queue_max_segment_size(sdpiton->queue, PAGE_SIZE);
+	blk_queue_logical_block_size(sdpiton->queue, 512);
+        
+	/* Now we can hook up the irq handler */
+	if (sdpiton->irq) {
+		rc = request_irq(sdpiton->irq, pitonsd_interrupt, 0, "pitonsd", sdpiton);
+		if (rc) {
+			/* Failure - fall back to polled mode */
+			dev_err(sdpiton->dev, "request_irq failed\n");
+			sdpiton->irq = 0;
+		}
+	}
+
+	printk("LowRISC_piton_sd physaddr 0x%llx, mapped to 0x%llx, irq=%i\n",
+               (u64) sdpiton->physaddr, (u64) sdpiton->baseaddr, sdpiton->irq);
+
+	/* Make the device 'live' */
+	add_disk(sdpiton->gd);
+
+	return 0;
+
+err_alloc_disk:
+	blk_cleanup_queue(sdpiton->queue);
+        blk_mq_free_tag_set(&sdpiton->tag_set);
+err_blk_initq:
+	iounmap(sdpiton->baseaddr);
+err_ioremap:
+	dev_info(sdpiton->dev, "pitonsd: error initializing device at 0x%llx\n",
+		 (unsigned long long) sdpiton->physaddr);
+	return -ENOMEM;
+}
+
+static void pitonsd_teardown(struct pitonsd_device *sdpiton)
+{
+	if (sdpiton->gd) {
+		del_gendisk(sdpiton->gd);
+		put_disk(sdpiton->gd);
+	}
+
+	if (sdpiton->queue) {
+		blk_cleanup_queue(sdpiton->queue);
+		blk_mq_free_tag_set(&sdpiton->tag_set);
+	}
+
+	tasklet_kill(&sdpiton->fsm_tasklet);
+
+	if (sdpiton->irq)
+		free_irq(sdpiton->irq, sdpiton);
+
+	iounmap(sdpiton->baseaddr);
+}
+
+static int pitonsd_alloc(struct device *dev, int id, resource_size_t physaddr, resource_size_t physaddrend, int irq)
+{
+	struct pitonsd_device *sdpiton;
+	int rc;
+	dev_dbg(dev, "pitonsd_alloc(%llx)\n", (u64)dev);
+
+	if (!physaddr) {
+		rc = -ENODEV;
+		goto err_noreg;
+	}
+
+	/* Allocate and initialize the sdpiton device structure */
+	sdpiton = kzalloc(sizeof(struct pitonsd_device), GFP_KERNEL);
+	if (!sdpiton) {
+		rc = -ENOMEM;
+		goto err_alloc;
+	}
+
+	sdpiton->dev = dev;
+	sdpiton->physaddr = physaddr;
+	sdpiton->physaddrend = physaddrend;
+	sdpiton->irq = irq;
+
+	/* Call the setup code */
+	rc = pitonsd_setup(sdpiton, id);
+	if (rc)
+		goto err_setup;
+
+	dev_set_drvdata(dev, sdpiton);
+        pr_debug("pitonsd_alloc returned success\n");
+	return 0;
+
+err_setup:
+	dev_set_drvdata(dev, NULL);
+	kfree(sdpiton);
+err_alloc:
+err_noreg:
+	dev_err(dev, "could not initialize device, err=%i\n", rc);
+	return rc;
+}
+
+static void pitonsd_free(struct device *dev)
+{
+	struct pitonsd_device *sdpiton = dev_get_drvdata(dev);
+	dev_dbg(dev, "pitonsd_free(%llx)\n", (u64)dev);
+
+	if (sdpiton) {
+		pitonsd_teardown(sdpiton);
+		dev_set_drvdata(dev, NULL);
+		kfree(sdpiton);
+	}
+}
+
+/* ---------------------------------------------------------------------
+ * Platform Bus Support
+ */
+
+static int pitonsd_probe(struct platform_device *dev)
+{
+	resource_size_t physaddr = 0;
+	resource_size_t physaddrend = 0;
+	int irq = 0;
+	int i;
+
+	printk("pitonsd_probe(%llx)\n", (u64)dev);
+
+	for (i = 0; i < dev->num_resources; i++) {
+		if (dev->resource[i].flags & IORESOURCE_MEM)
+                  {
+                    physaddr = dev->resource[i].start;
+                    physaddrend = dev->resource[i].end;
+                  }
+		if (dev->resource[i].flags & IORESOURCE_IRQ)
+			irq = dev->resource[i].start;
+	}
+
+	/* Call the bus-independent setup code */
+	return pitonsd_alloc(&dev->dev, pitonsd_nxt_devid++, physaddr, physaddrend, irq);
+}
+
+/*
+ * Platform bus remove() method
+ */
+static int pitonsd_remove(struct platform_device *dev)
+{
+	pitonsd_free(&dev->dev);
+	return 0;
+}
+
+/* Match table for of_platform binding */
+static const struct of_device_id pitonsd_of_match[] = {
+	{ .compatible = "lowrisc-pitonsd" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pitonsd_of_match);
+
+static struct platform_driver pitonsd_platform_driver = {
+	.probe = pitonsd_probe,
+	.remove = pitonsd_remove,
+	.driver = {
+		.name = "lowrisc-pitonsd",
+		.of_match_table = pitonsd_of_match,
+	},
+};
+
+/* ---------------------------------------------------------------------
+ * Module init/exit routines
+ */
+static int __init pitonsd_init(void)
+{
+	int rc;
+
+	pitonsd_major = register_blkdev(0, "pitonsd");
+	if (pitonsd_major <= 0) {
+		rc = -ENOMEM;
+		goto err_blk;
+	}
+
+	rc = platform_driver_register(&pitonsd_platform_driver);
+	if (rc)
+		goto err_plat;
+
+	pr_info("LowRISC_piton_sd device driver, major=%i\n", pitonsd_major);
+	return 0;
+
+err_plat:
+	unregister_blkdev(pitonsd_major, "pitonsd");
+err_blk:
+	printk(KERN_ERR "pitonsd: registration failed; err=%i\n", rc);
+	return rc;
+}
+module_init(pitonsd_init);
+
+static void __exit pitonsd_exit(void)
+{
+	pr_debug("Unregistering LowRISC_piton_sd driver\n");
+	platform_driver_unregister(&pitonsd_platform_driver);
+	unregister_blkdev(pitonsd_major, "pitonsd");
+}
+module_exit(pitonsd_exit);
diff --git a/drivers/block/lowrisc_pitonsd.h b/drivers/block/lowrisc_pitonsd.h
new file mode 100644
index 000000000..1d806a6ae
--- /dev/null
+++ b/drivers/block/lowrisc_pitonsd.h
@@ -0,0 +1,59 @@
+/* LowRISC_piton_sd register definitions
+ *
+ * Copyright 2019 University of Cambridge
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+This header file is designed to also be usable outside Linux in which case
+it is not covered by the GPL. When linked with the rest of Linux it is covered
+by the GPL.
+ *
+ */
+
+enum {
+  _piton_sd_ADDR_SD     ,
+  _piton_sd_ADDR_DMA    ,
+  _piton_sd_BLKCNT      ,
+  _piton_sd_REQ_RD      ,
+  _piton_sd_REQ_WR      ,
+  _piton_sd_IRQ_EN      ,
+  _piton_sd_SYS_RST     };
+
+enum {
+  _piton_sd_ADDR_SD_F=32,
+  _piton_sd_ADDR_DMA_F  ,
+  _piton_sd_STATUS      ,
+  _piton_sd_ERROR       ,
+  _piton_sd_INIT_STATE  ,
+  _piton_sd_COUNTER     ,
+  _piton_sd_INIT_FSM    ,
+  _piton_sd_TRAN_STATE  ,
+  _piton_sd_TRAN_FSM    };
+
+enum {
+  _piton_sd_STATUS_REQ_RD       = (0x00000001),
+  _piton_sd_STATUS_REQ_WR       = (0x00000002),
+  _piton_sd_STATUS_IRQ_EN       = (0x00000004),
+  _piton_sd_STATUS_SD_IRQ       = (0x00000008),
+  _piton_sd_STATUS_REQ_RDY      = (0x00000010),
+  _piton_sd_STATUS_INIT_DONE    = (0x00000020),
+  _piton_sd_STATUS_HCXC         = (0x00000040),
+  _piton_sd_STATUS_SD_DETECT    = (0x00000080)
+  };
+
+enum { _piton_sd_NUM_MINORS = 16 };
+
+static inline void fence(void)
+{
+        asm volatile ("fence" ::: "memory");
+}
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index 90e8a7f2f..530926f79 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -787,3 +787,19 @@ config KEYBOARD_MTK_PMIC
 	  module will be called pmic-keys.
 
 endif
+
+config KEYBOARD_LOWRISC
+	tristate "LowRISC keyboard"
+	select INPUT_POLLDEV
+	default n
+	help
+	  Say Y here if you want to use a LowRISC keyboard.
+	  If unsure, say N.
+
+config KEYBOARD_LOWRISC_FAKE
+	tristate "Translate LowRISC serial characters to fake keyboard events"
+	select INPUT_POLLDEV
+	default n
+	help
+	  Say Y here if you want to use a serial device as a fake keyboard input device.
+	  If unsure, say N.
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index 06a0af6ef..8a6cc90df 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -69,3 +69,5 @@ obj-$(CONFIG_KEYBOARD_TM2_TOUCHKEY)	+= tm2-touchkey.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYBOARD_LOWRISC)		+= lowrisc-kbd.o
+obj-$(CONFIG_KEYBOARD_LOWRISC_FAKE)	+= lowrisc-fake-keys.o
diff --git a/drivers/input/keyboard/lowrisc-fake-keys.c b/drivers/input/keyboard/lowrisc-fake-keys.c
new file mode 100644
index 000000000..11ef08ca9
--- /dev/null
+++ b/drivers/input/keyboard/lowrisc-fake-keys.c
@@ -0,0 +1,273 @@
+/*
+ * Lowrisc Dummy Keyboard Controller Driver - Translates UART input to fake key events
+ * http://www.lowrisc.org/
+ *
+ * based on opencores Javier Herrero <jherrero@hvsistemas.es>
+ * Copyright 2007-2009 HV Sistemas S.L.
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ * This driver acts as a shadow console, forwarding serial port events to the main console
+ * using the input event mechanism. It's primary use is to allow LowRISC to be used via
+ * a serial port without screen and keyboard being connected.
+ *
+ * It also may be used as a conduit to shadow an approximation of console output to the serial port
+ *
+ * Since console output is already processed according to the type of device at this point, it would
+ * be too complicated to replicate all the behaviour of a serial console. So everything other than
+ * emergency hacking should be done via ssh (for editing) or sftp (for uploading)
+ */
+
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input-polldev.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <asm/sbi.h>
+
+#define DRIVER_NAME "lowrisc-fake"
+
+static struct lowrisc_fake {
+  struct platform_device *pdev;
+  struct resource *fake;
+  spinlock_t lock;
+  volatile uint32_t *fake_base;
+  struct input_dev *input;
+  unsigned short keycodes[128];
+} lowrisc_fake_static;
+
+void lowrisc_shadow_console_putchar(int ch)
+{
+  volatile uint64_t *tx = (volatile uint64_t *)(lowrisc_fake_static.fake_base);
+  if (tx)
+    {
+      *tx = ch & 0x7f; /* just send the US ASCII subset */
+    }
+  else /* probe function not called yet */
+    {
+      sbi_console_putchar(ch);
+    }
+}
+
+static int upper(int ch)
+{
+  if ( ch >= 'A' && ch <= 'Z' ) return 1;
+  switch ( ch )
+    {
+    case '!' : return 1;
+    case '"' : return 1;
+    case '#' : return 1;
+    case '$' : return 1;
+    case '%' : return 1;
+    case '^' : return 1;
+    case '&' : return 1;
+    case '*' : return 1;
+    case '<' : return 1;
+    case '>' : return 1;
+    case '~' : return 1;
+    case '@' : return 1;
+    case '+' : return 1;
+    case '_' : return 1;
+    case '(' : return 1;
+    case ')' : return 1;
+    case '{' : return 1;
+    case '}' : return 1;
+    case '|' : return 1;
+    case ':' : return 1;
+    case '?' : return 1;
+    default  : return 0;
+    }
+}
+
+static void lowrisc_keys_poll(struct input_polled_dev *dev)
+{
+  struct lowrisc_fake *lowrisc_fake = dev->private;
+  struct input_dev *input = dev->input;
+  unsigned char c;
+  volatile uint64_t *rx = (volatile uint64_t *)(lowrisc_fake->fake_base);
+  int ch = *rx;
+  if (0x200 & ~ch)
+    {
+      enum {lctrl=0x1d, lshift=0x2a};
+      int ctrl;
+      rx[0x200] = 0; // pop FIFO
+      ch = *rx & 0x7f;
+      ctrl = ch >= 1 && ch <= 26;
+      if (ctrl)
+	{
+	  input_report_key(input, lctrl, 1);
+          ch = ch + 'a' - 1; // Convert ctrl-key back to normal key
+	}      
+      switch(ch)
+	{
+	case '\e' : c =  	  0x01; break;
+	case '1' : case '!' : c = 0x02; break;
+	case '2' : case '@' : c =  	  0x03; break;
+	case '3' : case '#' : c =  	  0x04; break;
+	case '4' : case '$' : c =  	  0x05; break;
+	case '5' : case '%' : c =  	  0x06; break;
+	case '6' : case '^' : c =  	  0x07; break;
+	case '7' : case '&' : c =  	  0x08; break;
+	case '8' : case '*' : c =  	  0x09; break;
+	case '9' : case '(' : c =  	  0x0a; break;
+	case '0' : case ')' : c =  	      0x0b; break;
+	case '-' : case '_' : c =  	  0x0c; break;
+	case '=' : case '+' : c =  	  0x0d; break;
+	case 0x7f : c = 0x0e; break;
+	case '\t' : c = 0x0f; break;
+	case 'Q' : case 'q' : c =  	  0x10; break;
+	case 'W' : case 'w' : c =  	  0x11; break;
+	case 'E' : case 'e' : c =  	  0x12; break;
+	case 'R' : case 'r' : c =  	  0x13; break;
+	case 'T' : case 't' : c =  	  0x14; break;
+	case 'Y' : case 'y' : c =  	  0x15; break;
+	case 'U' : case 'u' : c =  	  0x16; break;
+	case 'I' : case 'i' : c =  	  0x17; break;
+	case 'O' : case 'o' : c =  	  0x18; break;
+	case 'P' : case 'p' : c =  	  0x19; break;
+	case '[' : case '{' : c =  	  0x1a; break;
+	case ']' : case '}' : c =  	  0x1b; break;
+	case '\r' : c =  	  0x1c; break;
+	case 'A' : case 'a' : c =  	  0x1e; break;
+	case 'S' : case 's' : c =  	  0x1f; break;
+	case 'D' : case 'd' : c =  	  0x20; break;
+	case 'F' : case 'f' : c =  	  0x21; break;
+	case 'G' : case 'g' : c =  	  0x22; break;
+	case 'H' : case 'h' : c =  	  0x23; break;
+	case 'J' : case 'j' : c =  	  0x24; break;
+	case 'K' : case 'k' : c =  	  0x25; break;
+	case 'L' : case 'l' : c =  	  0x26; break;
+	case ';' : case ':' : c =  	  0x27; break;
+	case '\'' : case '"' : c =  	  0x28; break;
+	case '`' : case '~' : c =  	  0x29; break;
+	case '\\' : case '|' : c =  	  0x2b; break;
+	case 'Z' : case 'z' : c =   0x2c; break;
+	case 'X' : case 'x' : c =   0x2d; break;
+	case 'C' : case 'c' : c =   0x2e; break;
+	case 'V' : case 'v' : c =   0x2f; break;
+	case 'B' : case 'b' : c =   0x30; break;
+	case 'N' : case 'n' : c =   0x31; break;
+	case 'M' : case 'm' : c =   0x32; break;
+	case ',' : case '<' : c =   0x33; break;
+	case '.' : case '>' : c =   0x34; break;
+	case '/' : case '?' : c =   0x35; break;
+	case ' ' : c =   0x39; break;
+	default: c = 0; printk("input_report_key 0x%x not translated\n", ch);
+	}
+      if (upper(ch))
+	{
+	  input_report_key(input, lshift, 1);
+	}
+      input_report_key(input, c, 1);
+      input_report_key(input, c, 0);
+      if (ctrl)
+	{
+	  input_report_key(input, lctrl, 0);
+	}
+      if (upper(ch))
+	{
+	  input_report_key(input, lshift, 0);
+	}
+      input_sync(input);
+    }
+}
+
+static int lowrisc_fake_probe(struct platform_device *pdev)
+{
+  struct input_dev *input;
+  struct lowrisc_fake *lowrisc_fake;
+  int i, error;
+  struct input_polled_dev *poll_dev;
+  struct device *dev = &pdev->dev;
+
+  printk("lowrisc_fake_probe\n");
+  lowrisc_fake = &lowrisc_fake_static;
+  
+  if (lowrisc_fake->fake_base) /* Only one instance allowed */
+    {
+    return -ENOMEM;
+    }
+
+  lowrisc_fake->fake = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  if (!request_mem_region(lowrisc_fake->fake->start, resource_size(lowrisc_fake->fake), "lowrisc_fake"))
+    {
+    dev_err(&pdev->dev, "cannot request LowRISC UART region\n");
+    return -EBUSY;
+    }
+
+  lowrisc_fake->fake_base = (volatile uint32_t *)ioremap(lowrisc_fake->fake->start, resource_size(lowrisc_fake->fake));
+  printk("fake_keyboard address %llx, remapped to %lx\n", lowrisc_fake->fake->start, (size_t)lowrisc_fake->fake_base);
+
+  poll_dev = devm_input_allocate_polled_device(dev);
+  if (!poll_dev) {
+    dev_err(dev, "failed to allocate input device\n");
+    return -ENOMEM;
+  }
+  
+  poll_dev->poll_interval = 100;
+  
+  poll_dev->poll = lowrisc_keys_poll;
+  poll_dev->private = lowrisc_fake;
+  
+  input = poll_dev->input;
+
+  lowrisc_fake->input = input;
+
+  input->name = pdev->name;
+  input->phys = "lowrisc-fake/input0";
+  
+  input->id.bustype = BUS_HOST;
+  input->id.vendor = 0x0001;
+  input->id.product = 0x0001;
+  input->id.version = 0x0100;
+  
+  input->keycode = lowrisc_fake->keycodes;
+  input->keycodesize = sizeof(lowrisc_fake->keycodes[0]);
+  input->keycodemax = ARRAY_SIZE(lowrisc_fake->keycodes);
+  
+  __set_bit(EV_KEY, input->evbit);
+  
+  for (i = 0; i < ARRAY_SIZE(lowrisc_fake->keycodes); i++) {
+    /*
+     * Lowrisc lowrisc_faketroller happens to have scancodes match
+     * our KEY_* definitions.
+     */
+    lowrisc_fake->keycodes[i] = i;
+    __set_bit(lowrisc_fake->keycodes[i], input->keybit);
+  }
+  __clear_bit(KEY_RESERVED, input->keybit);
+  
+  error = input_register_polled_device(poll_dev);
+  if (error) {
+    dev_err(dev, "Unable to register input device: %d\n", error);
+    return error;
+  }
+ 
+  return 0;
+}
+
+static const struct of_device_id lowrisc_fake_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, lowrisc_fake_of_match);
+
+static struct platform_driver lowrisc_fake_device_driver = {
+	.probe    = lowrisc_fake_probe,
+	.driver   = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_fake_of_match,
+	},
+};
+module_platform_driver(lowrisc_fake_device_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jonathan Kimmitt <jonathan@kimmitt.uk>");
+MODULE_DESCRIPTION("Dummy Keyboard input events for Lowrisc");
diff --git a/drivers/input/keyboard/lowrisc-kbd.c b/drivers/input/keyboard/lowrisc-kbd.c
new file mode 100644
index 000000000..6a473b3c5
--- /dev/null
+++ b/drivers/input/keyboard/lowrisc-kbd.c
@@ -0,0 +1,168 @@
+/*
+ * Lowrisc Keyboard Controller Driver
+ * http://www.lowrisc.org/
+ *
+ * based on opencores Javier Herrero <jherrero@hvsistemas.es>
+ * Copyright 2007-2009 HV Sistemas S.L.
+ *
+ * Licensed under the GPL-2 or later.
+ *
+ * This driver polls the Nexys4DDR onboard PIC which has a PS/2 to USB converter for legacy keyboards
+ * Newer keyboards such as Apple USB do not use PS/2 emulation so you are out of luck.
+ * This driver was tested with a Microsoft Wired Keyboard 200, which meets the above criterion.
+ * Alternatively PS/2 keyboards that have a USB adaptor plug would probably be suitable (but untested)
+ *
+ * The Verilog sub-system generates raw scancodes which this driver converts to PC standard codes, and
+ * the input subsystem then converts them to ASCII according National/Regional preferences.
+ *
+ * There may be missing or incorrect codes which can be corrected in RTL, but the PIC programming is not
+ * open source as far as I am aware, so unhappy users should use the lowrisc-fake-keys.c driver which
+ * emulates serial events for all keyboards over the serial port. In the latter case the USB port is free
+ * to attach a mouse or similar device, but emulation speeds are too limited for effective graphical console
+ * use (and VGA graphics RTL would have to be designed).
+ */
+
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input-polldev.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <asm/sbi.h>
+
+#define DRIVER_NAME "lowrisc-keyb"
+
+struct lowrisc_kbd {
+  struct platform_device *pdev;
+  struct resource *keyb;
+  spinlock_t lock;
+  volatile uint32_t *keyb_base;
+  struct input_dev *input;
+  unsigned short keycodes[128];
+};
+
+enum {scan_code_mask=0xFF, scan_released=0x100, keyb_empty=0x200, no_keyboard=0x400};
+
+const struct { char scan,lwr,upr; } scancode[] = {
+#include "lowrisc-scancode.h"
+};
+
+static void lowrisc_keys_poll(struct input_polled_dev *dev)
+{
+  struct lowrisc_kbd *lowrisc_kbd = dev->private;
+  struct input_dev *input = dev->input;
+  unsigned char c;
+  uint32_t key = *lowrisc_kbd->keyb_base;
+  while (keyb_empty & ~key)
+    {
+      *lowrisc_kbd->keyb_base = 0; // bump FIFO location
+      key = *lowrisc_kbd->keyb_base;
+      c = scancode[key&scan_code_mask].scan; /* convert to standard AT keyboard codes */
+      if (c != 0x3A) // Ignore caps lock for now (and hopefully always)
+        {
+          input_report_key(input, c, key & scan_released ? 0 : 1);
+          input_sync(input);
+        }
+      pr_debug("input event key %c\n", scancode[key&scan_code_mask].lwr);
+    }
+}
+
+static int lowrisc_kbd_probe(struct platform_device *pdev)
+{
+  struct input_dev *input;
+  struct lowrisc_kbd *lowrisc_kbd;
+  int i, error;
+  struct input_polled_dev *poll_dev;
+  struct device *dev = &pdev->dev;
+
+  printk("lowrisc_kbd_probe\n");
+  lowrisc_kbd = devm_kzalloc(&pdev->dev, sizeof(struct lowrisc_kbd), GFP_KERNEL);
+  if (!lowrisc_kbd) {
+    return -ENOMEM;
+  }
+  lowrisc_kbd->keyb = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  if (!request_mem_region(lowrisc_kbd->keyb->start, resource_size(lowrisc_kbd->keyb), "lowrisc_kbd"))
+    {
+    dev_err(&pdev->dev, "cannot request LowRISC keyboard region\n");
+    return -EBUSY;
+    }
+  lowrisc_kbd->keyb_base = (volatile uint32_t *)ioremap(lowrisc_kbd->keyb->start, resource_size(lowrisc_kbd->keyb));
+  printk("hid_keyboard address %llx, remapped to %lx\n", lowrisc_kbd->keyb->start, (size_t)lowrisc_kbd->keyb_base);
+
+  poll_dev = devm_input_allocate_polled_device(dev);
+  if (!poll_dev) {
+    dev_err(dev, "failed to allocate input device\n");
+    return -ENOMEM;
+  }
+  
+  poll_dev->poll_interval = 100;
+  
+  poll_dev->poll = lowrisc_keys_poll;
+  poll_dev->private = lowrisc_kbd;
+  
+  input = poll_dev->input;
+
+  lowrisc_kbd->input = input;
+
+  input->name = pdev->name;
+  input->phys = "lowrisc-kbd/input0";
+  
+  input->id.bustype = BUS_HOST;
+  input->id.vendor = 0x0001;
+  input->id.product = 0x0001;
+  input->id.version = 0x0100;
+  
+  input->keycode = lowrisc_kbd->keycodes;
+  input->keycodesize = sizeof(lowrisc_kbd->keycodes[0]);
+  input->keycodemax = ARRAY_SIZE(lowrisc_kbd->keycodes);
+  
+  __set_bit(EV_KEY, input->evbit);
+  
+  for (i = 0; i < ARRAY_SIZE(lowrisc_kbd->keycodes); i++) {
+    /*
+     * Lowrisc lowrisc_kbdtroller happens to have scancodes match
+     * our KEY_* definitions.
+     */
+    lowrisc_kbd->keycodes[i] = i;
+    __set_bit(lowrisc_kbd->keycodes[i], input->keybit);
+  }
+  __clear_bit(KEY_RESERVED, input->keybit);
+  
+  error = input_register_polled_device(poll_dev);
+  if (error) {
+    dev_err(dev, "Unable to register input device: %d\n", error);
+    return error;
+  }
+  printk("Clear any pending input\n");
+  while ((1<<9) & ~*lowrisc_kbd->keyb_base)
+    {
+      *lowrisc_kbd->keyb_base = 0; // bump FIFO location
+    }
+  printk("Loading keyboard input device returns success\n");  
+  return 0;
+}
+
+static const struct of_device_id lowrisc_kbd_of_match[] = {
+	{ .compatible = "lowrisc-keyb" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, lowrisc_kbd_of_match);
+
+static struct platform_driver lowrisc_kbd_device_driver = {
+	.probe    = lowrisc_kbd_probe,
+	.driver   = {
+		.name = "lowrisc-keyb",
+		.of_match_table = lowrisc_kbd_of_match,
+	},
+};
+module_platform_driver(lowrisc_kbd_device_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Jonathan Kimmitt <jonathan@kimmitt.uk>");
+MODULE_DESCRIPTION("Keyboard driver for Lowrisc Keyboard Lowrisc_controller");
diff --git a/drivers/input/keyboard/lowrisc-scancode.h b/drivers/input/keyboard/lowrisc-scancode.h
new file mode 100644
index 000000000..871184347
--- /dev/null
+++ b/drivers/input/keyboard/lowrisc-scancode.h
@@ -0,0 +1,282 @@
+//////////////////////////////////////////////////////////////////////
+////                                                              ////
+//// A table of PS/2 to AT scan code conversions,                 ////
+//// based on ps2_defines.v                                       ////
+//// Copyright (C) 2000 Miha Dolenc, mihad@opencores.org          ////
+////                                                              ////
+//// This source file may be used and distributed without         ////
+//// restriction provided that this copyright statement is not    ////
+//// removed from the file and that any derivative work contains  ////
+//// the original copyright notice and the associated disclaimer. ////
+////                                                              ////
+//// This source file is free software; you can redistribute it   ////
+//// and/or modify it under the terms of the GNU Lesser General   ////
+//// Public License as published by the Free Software Foundation; ////
+//// either version 2.1 of the License, or (at your option) any   ////
+//// later version.                                               ////
+////                                                              ////
+//// This source is distributed in the hope that it will be       ////
+//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////
+//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////
+//// PURPOSE.  See the GNU Lesser General Public License for more ////
+//// details.                                                     ////
+////                                                              ////
+//// You should have received a copy of the GNU Lesser General    ////
+//// Public License along with this source; if not, download it   ////
+//// from http://www.opencores.org/lgpl.shtml                     ////
+[  0] = {0x00,0x00,0x00},
+[  1] = {0x43,0x00,0x00},
+[  2] = {0x41,0x00,0x00},
+[  3] = {0x3f,0x00,0x00},
+[  4] = {0x3d,0x00,0x00},
+[  5] = {0x3b,0x00,0x00},
+[  6] = {0x3c,0x00,0x00},
+[  7] = {0x58,0x00,0x00},
+[  8] = {0x64,0x00,0x00},
+[  9] = {0x44,0x00,0x00},
+[ 10] = {0x42,0x00,0x00},
+[ 11] = {0x40,0x00,0x00},
+[ 12] = {0x3e,0x00,0x00},
+[ 13] = {0x0f,0x09,0x09},
+[ 14] = {0x29,0x60,0x60},
+[ 15] = {0x59,0x00,0x00},
+[ 16] = {0x65,0x00,0x00},
+[ 17] = {0x38,0x00,0x00},
+[ 18] = {0x2a,0x00,0x00},
+[ 19] = {0x70,0x00,0x00},
+[ 20] = {0x1d,0x00,0x00},
+[ 21] = {0x10,0x71,0x51},
+[ 22] = {0x02,0x31,0x21},
+[ 23] = {0x5a,0x00,0x00},
+[ 24] = {0x66,0x00,0x00},
+[ 25] = {0x71,0x00,0x00},
+[ 26] = {0x2c,0x7a,0x5a},
+[ 27] = {0x1f,0x73,0x53},
+[ 28] = {0x1e,0x61,0x41},
+[ 29] = {0x11,0x77,0x57},
+[ 30] = {0x03,0x32,0x22},
+[ 31] = {0x5b,0x00,0x00},
+[ 32] = {0x67,0x00,0x00},
+[ 33] = {0x2e,0x63,0x43},
+[ 34] = {0x2d,0x78,0x58},
+[ 35] = {0x20,0x64,0x44},
+[ 36] = {0x12,0x65,0x45},
+[ 37] = {0x05,0x34,0x24},
+[ 38] = {0x04,0x33,0x23},
+[ 39] = {0x5c,0x00,0x00},
+[ 40] = {0x68,0x00,0x00},
+[ 41] = {0x39,0x20,0x20},
+[ 42] = {0x2f,0x76,0x56},
+[ 43] = {0x21,0x66,0x46},
+[ 44] = {0x14,0x74,0x54},
+[ 45] = {0x13,0x72,0x52},
+[ 46] = {0x06,0x35,0x25},
+[ 47] = {0x5d,0x00,0x00},
+[ 48] = {0x69,0x00,0x00},
+[ 49] = {0x31,0x6e,0x4e},
+[ 50] = {0x30,0x62,0x42},
+[ 51] = {0x23,0x68,0x48},
+[ 52] = {0x22,0x67,0x47},
+[ 53] = {0x15,0x79,0x59},
+[ 54] = {0x07,0x36,0x5e},
+[ 55] = {0x5e,0x00,0x00},
+[ 56] = {0x6a,0x00,0x00},
+[ 57] = {0x72,0x00,0x00},
+[ 58] = {0x32,0x6d,0x4d},
+[ 59] = {0x24,0x6a,0x4a},
+[ 60] = {0x16,0x75,0x55},
+[ 61] = {0x08,0x37,0x26},
+[ 62] = {0x09,0x38,0x2a},
+[ 63] = {0x5f,0x00,0x00},
+[ 64] = {0x6b,0x00,0x00},
+[ 65] = {0x33,0x2c,0x3c},
+[ 66] = {0x25,0x6b,0x4b},
+[ 67] = {0x17,0x69,0x49},
+[ 68] = {0x18,0x6f,0x4f},
+[ 69] = {0x0b,0x30,0x29},
+[ 70] = {0x0a,0x39,0x28},
+[ 71] = {0x60,0x00,0x00},
+[ 72] = {0x6c,0x00,0x00},
+[ 73] = {0x34,0x2e,0x3e},
+[ 74] = {0x35,0x2f,0x3f},
+[ 75] = {0x26,0x6c,0x4c},
+[ 76] = {0x27,0x3b,0x3a},
+[ 77] = {0x19,0x70,0x50},
+[ 78] = {0x0c,0x2d,0x5f},
+[ 79] = {0x61,0x00,0x00},
+[ 80] = {0x6d,0x00,0x00},
+[ 81] = {0x73,0x00,0x00},
+[ 82] = {0x28,0x27,0x40},
+[ 83] = {0x74,0x00,0x00},
+[ 84] = {0x1a,0x5b,0x7b},
+[ 85] = {0x0d,0x3d,0x2b},
+[ 86] = {0x62,0x00,0x00},
+[ 87] = {0x6e,0x00,0x00},
+[ 88] = {0x3a,0x00,0x00},
+[ 89] = {0x36,0x00,0x00},
+[ 90] = {0x1c,0x0d,0x0d},
+[ 91] = {0x1b,0x5d,0x7d},
+[ 92] = {0x75,0x00,0x00},
+[ 93] = {0x2b,0x5c,0x7c},
+[ 94] = {0x63,0x00,0x00},
+[ 95] = {0x76,0x00,0x00},
+[ 96] = {0x55,0x00,0x00},
+[ 97] = {0x56,0x00,0x00},
+[ 98] = {0x77,0x00,0x00},
+[ 99] = {0x78,0x00,0x00},
+[100] = {0x79,0x00,0x00},
+[101] = {0x7a,0x00,0x00},
+[102] = {0x0e,0x08,0x08},
+[103] = {0x7b,0x00,0x00},
+[104] = {0x7c,0x00,0x00},
+[105] = {0x4f,0x00,0x00},
+[106] = {0x7d,0x00,0x00},
+[107] = {0x4b,0x00,0x00},
+[108] = {0x47,0x00,0x00},
+[109] = {0x7e,0x00,0x00},
+[110] = {0x7f,0x00,0x00},
+[111] = {0x6f,0x00,0x00},
+[112] = {0x52,0x00,0x00},
+[113] = {0x53,0x00,0x00},
+[114] = {0x50,0x00,0x00},
+[115] = {0x4c,0x00,0x00},
+[116] = {0x4d,0x00,0x00},
+[117] = {0x48,0x00,0x00},
+[118] = {0x01,0x1b,0x1b},
+[119] = {0x45,0x00,0x00},
+[120] = {0x57,0x00,0x00},
+[121] = {0x4e,0x2b,0x2b},
+[122] = {0x51,0x00,0x00},
+[123] = {0x4a,0x2d,0x5f},
+[124] = {0x37,0x2a,0x2a},
+[125] = {0x49,0x00,0x00},
+[126] = {0x46,0x00,0x00},
+[127] = {0x54,0x00,0x00},
+[128] = {0x80,0x00,0x00},
+[129] = {0x81,0x1b,0x1b},
+[130] = {0x82,0x31,0x21},
+[131] = {0x41,0x00,0x00},
+[132] = {0x54,0x00,0x00},
+[133] = {0x85,0x34,0x24},
+[134] = {0x86,0x35,0x25},
+[135] = {0x87,0x36,0x5e},
+[136] = {0x88,0x37,0x26},
+[137] = {0x89,0x38,0x2a},
+[138] = {0x8a,0x39,0x28},
+[139] = {0x8b,0x30,0x29},
+[140] = {0x8c,0x2d,0x5f},
+[141] = {0x8d,0x3d,0x2b},
+[142] = {0x8e,0x08,0x08},
+[143] = {0x8f,0x09,0x09},
+[144] = {0x90,0x71,0x51},
+[145] = {0x91,0x77,0x57},
+[146] = {0x92,0x65,0x45},
+[147] = {0x93,0x72,0x52},
+[148] = {0x94,0x74,0x54},
+[149] = {0x95,0x79,0x59},
+[150] = {0x96,0x75,0x55},
+[151] = {0x97,0x69,0x49},
+[152] = {0x98,0x6f,0x4f},
+[153] = {0x99,0x70,0x50},
+[154] = {0x9a,0x5b,0x7b},
+[155] = {0x9b,0x5d,0x7d},
+[156] = {0x9c,0x0d,0x0d},
+[157] = {0x9d,0x00,0x00},
+[158] = {0x9e,0x61,0x41},
+[159] = {0x9f,0x73,0x53},
+[160] = {0xa0,0x64,0x44},
+[161] = {0xa1,0x66,0x46},
+[162] = {0xa2,0x67,0x47},
+[163] = {0xa3,0x68,0x48},
+[164] = {0xa4,0x6a,0x4a},
+[165] = {0xa5,0x6b,0x4b},
+[166] = {0xa6,0x6c,0x4c},
+[167] = {0xa7,0x3b,0x3a},
+[168] = {0xa8,0x27,0x40},
+[169] = {0xa9,0x60,0x60},
+[170] = {0xaa,0x00,0x00},
+[171] = {0xab,0x5c,0x7c},
+[172] = {0xac,0x7a,0x5a},
+[173] = {0xad,0x78,0x58},
+[174] = {0xae,0x63,0x43},
+[175] = {0xaf,0x76,0x56},
+[176] = {0xb0,0x62,0x42},
+[177] = {0xb1,0x6e,0x4e},
+[178] = {0xb2,0x6d,0x4d},
+[179] = {0xb3,0x2c,0x3c},
+[180] = {0xb4,0x2e,0x3e},
+[181] = {0xb5,0x2f,0x3f},
+[182] = {0xb6,0x00,0x00},
+[183] = {0xb7,0x2a,0x2a},
+[184] = {0xb8,0x00,0x00},
+[185] = {0xb9,0x20,0x20},
+[186] = {0xba,0x00,0x00},
+[187] = {0xbb,0x00,0x00},
+[188] = {0xbc,0x00,0x00},
+[189] = {0xbd,0x00,0x00},
+[190] = {0xbe,0x00,0x00},
+[191] = {0xbf,0x00,0x00},
+[192] = {0xc0,0x00,0x00},
+[193] = {0xc1,0x00,0x00},
+[194] = {0xc2,0x00,0x00},
+[195] = {0xc3,0x00,0x00},
+[196] = {0xc4,0x00,0x00},
+[197] = {0xc5,0x00,0x00},
+[198] = {0xc6,0x00,0x00},
+[199] = {0xc7,0x00,0x00},
+[200] = {0xc8,0x00,0x00},
+[201] = {0xc9,0x00,0x00},
+[202] = {0xca,0x2d,0x5f},
+[203] = {0xcb,0x00,0x00},
+[204] = {0xcc,0x00,0x00},
+[205] = {0xcd,0x00,0x00},
+[206] = {0xce,0x2b,0x2b},
+[207] = {0xcf,0x00,0x00},
+[208] = {0xd0,0x00,0x00},
+[209] = {0xd1,0x00,0x00},
+[210] = {0xd2,0x00,0x00},
+[211] = {0xd3,0x00,0x00},
+[212] = {0xd4,0x00,0x00},
+[213] = {0xd5,0x00,0x00},
+[214] = {0xd6,0x00,0x00},
+[215] = {0xd7,0x00,0x00},
+[216] = {0xd8,0x00,0x00},
+[217] = {0xd9,0x00,0x00},
+[218] = {0xda,0x00,0x00},
+[219] = {0xdb,0x00,0x00},
+[220] = {0xdc,0x00,0x00},
+[221] = {0xdd,0x00,0x00},
+[222] = {0xde,0x00,0x00},
+[223] = {0xdf,0x00,0x00},
+[224] = {0xe0,0x00,0x00},
+[225] = {0xe1,0x00,0x00},
+[226] = {0xe2,0x00,0x00},
+[227] = {0xe3,0x00,0x00},
+[228] = {0xe4,0x00,0x00},
+[229] = {0xe5,0x00,0x00},
+[230] = {0xe6,0x00,0x00},
+[231] = {0xe7,0x00,0x00},
+[232] = {0xe8,0x00,0x00},
+[233] = {0xe9,0x00,0x00},
+[234] = {0xea,0x00,0x00},
+[235] = {0xeb,0x00,0x00},
+[236] = {0xec,0x00,0x00},
+[237] = {0xed,0x00,0x00},
+[238] = {0xee,0x00,0x00},
+[239] = {0xef,0x00,0x00},
+[240] = {0xf0,0x00,0x00},
+[241] = {0xf1,0x00,0x00},
+[242] = {0xf2,0x00,0x00},
+[243] = {0xf3,0x00,0x00},
+[244] = {0xf4,0x00,0x00},
+[245] = {0xf5,0x00,0x00},
+[246] = {0xf6,0x00,0x00},
+[247] = {0xf7,0x00,0x00},
+[248] = {0xf8,0x00,0x00},
+[249] = {0xf9,0x00,0x00},
+[250] = {0xfa,0x00,0x00},
+[251] = {0xfb,0x00,0x00},
+[252] = {0xfc,0x00,0x00},
+[253] = {0xfd,0x00,0x00},
+[254] = {0xfe,0x00,0x00},
+[255] = {0xff,0x00,0x00},
diff --git a/drivers/input/mouse/Kconfig b/drivers/input/mouse/Kconfig
index 652c38e3c..eb2dc7ad5 100644
--- a/drivers/input/mouse/Kconfig
+++ b/drivers/input/mouse/Kconfig
@@ -394,6 +394,15 @@ config MOUSE_GPIO
 	  To compile this driver as a module, choose M here: the
 	  module will be called gpio_mouse.
 
+config MOUSE_LOWRISC
+	tristate "LowRISC mouse"
+	depends on RISCV
+	select INPUT_POLLDEV
+	help
+	  This driver connects a PS/2 mouse on the LowRISC AXI bus
+
+	  Say Y here if your hardware is Nexys4DDR.
+
 config MOUSE_PXA930_TRKBALL
 	tristate "PXA930 Trackball mouse"
 	depends on CPU_PXA930 || CPU_PXA935
diff --git a/drivers/input/mouse/Makefile b/drivers/input/mouse/Makefile
index e49f08565..e21170928 100644
--- a/drivers/input/mouse/Makefile
+++ b/drivers/input/mouse/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_MOUSE_ELAN_I2C)		+= elan_i2c.o
 obj-$(CONFIG_MOUSE_GPIO)		+= gpio_mouse.o
 obj-$(CONFIG_MOUSE_INPORT)		+= inport.o
 obj-$(CONFIG_MOUSE_LOGIBM)		+= logibm.o
+obj-$(CONFIG_MOUSE_LOWRISC)		+= lowrisc_mouse.o
 obj-$(CONFIG_MOUSE_MAPLE)		+= maplemouse.o
 obj-$(CONFIG_MOUSE_NAVPOINT_PXA27x)	+= navpoint.o
 obj-$(CONFIG_MOUSE_PC110PAD)		+= pc110pad.o
diff --git a/drivers/input/mouse/lowrisc_mouse.c b/drivers/input/mouse/lowrisc_mouse.c
new file mode 100644
index 000000000..ad0d2e3fa
--- /dev/null
+++ b/drivers/input/mouse/lowrisc_mouse.c
@@ -0,0 +1,192 @@
+/*
+ * Driver for LowRISC mouse on AXI bus with PS/2 interface.
+ *
+ * Based on gpio_mouse.c
+ *
+ * Copyright (C) 2007 Atmel Corporation
+ * Copyright (C) 2017 Linus Walleij <linus.walleij@linaro.org>
+ * Copyright (C) 2017 Hans-Christian Egtvedt <egtvedt@samfundet.no>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/input-polldev.h>
+#include <linux/property.h>
+#include <linux/of.h>
+
+enum {MAX_X=640, MAX_Y=480};
+
+/**
+ * struct lowrisc_mouse
+ * @mouse_base: The virtual base address on the AXI bus
+ * @mouse: The resources reported by the device tree blob
+ * @scan_ms: the scan interval in milliseconds.
+ * @left, middle, right, X, Y: previous value reported by hardware
+ *
+ * This struct must be added to the platform_device in the board code.
+ * It is used by the lowrisc_mouse driver to calculate mouse movement.
+ */
+struct lowrisc_mouse {
+  volatile uint64_t *mouse_base;
+  struct resource *mouse;
+  u32 scan_ms;
+  int left, middle, right, X, Y;
+};
+
+/*
+ * Timer function which is run every scan_ms ms when the device is opened.
+ * The dev input variable is set to the the input_dev pointer.
+ */
+static void lowrisc_mouse_scan(struct input_polled_dev *dev)
+{
+  struct lowrisc_mouse *mouse = dev->private;
+  struct input_dev *input = dev->input;
+  int ev = 0;
+  do
+    {
+      uint32_t mouse_ev = mouse->mouse_base[0];
+      int X = mouse_ev & 1023;
+      int Y = (mouse_ev>>12) & 1023;
+      int Z = (mouse_ev>>24) & 15;
+      int right = (mouse_ev>>29) & 1;
+      int middle = (mouse_ev>>30) & 1;
+      int left = (mouse_ev>>31) & 1;
+      if (mouse->left != left)
+        {
+          ev = 1;
+          input_report_key(input, BTN_LEFT, left);
+        }
+      if (mouse->middle != middle)
+        {
+          ev = 1;
+          input_report_key(input, BTN_MIDDLE, middle);
+        }
+      if (mouse->right != right)
+        {
+          ev = 1;
+          input_report_key(input, BTN_RIGHT, right);
+        }
+      if (mouse->X != X)
+        {
+          ev = 1;
+          input_report_abs(input, ABS_X, X);
+        }
+      if (mouse->Y != Y)
+        {
+          ev = 1;
+          input_report_abs(input, ABS_Y, Y);
+        }
+      if (ev)
+        {
+          pr_debug("Mouse(%d,%d,%d), ev=%d, left=%d, middle=%d, right=%d\n",
+             X, Y, Z, ev, left, middle, right);
+          input_sync(input);
+        }
+      mouse->left = left;
+      mouse->middle = middle;
+      mouse->right = right;
+      mouse->X = X;
+      mouse->Y = Y;
+      mouse->mouse_base[0] = 0; // bump FIFO location
+    }
+  while (ev && (0x100000000ULL & ~(mouse->mouse_base[0])));
+}
+
+static int lowrisc_open(struct input_dev *dev)
+{
+  printk("Opening mouse");
+  return 0;
+}
+
+static void lowrisc_close(struct input_dev *dev)
+{
+  printk("Closing mouse");
+}
+
+static int lowrisc_mouse_probe(struct platform_device *pdev)
+{
+  struct device *dev = &pdev->dev;
+  struct lowrisc_mouse *lowrisc_mouse;
+  struct input_polled_dev *input_poll;
+  struct input_dev *input;
+  int ret;
+
+  printk("lowrisc_mouse_probe\n");
+  lowrisc_mouse = devm_kzalloc(dev, sizeof(*lowrisc_mouse), GFP_KERNEL);
+  if (!lowrisc_mouse)
+    return -ENOMEM;
+  
+  lowrisc_mouse->scan_ms = 50;
+  lowrisc_mouse->mouse = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  if (!request_mem_region(lowrisc_mouse->mouse->start, resource_size(lowrisc_mouse->mouse), "lowrisc_mouse"))
+    {
+    dev_err(&pdev->dev, "cannot request LowRISC mouse region\n");
+    return -EBUSY;
+    }
+  lowrisc_mouse->mouse_base = (volatile uint64_t *)ioremap(lowrisc_mouse->mouse->start, resource_size(lowrisc_mouse->mouse));
+  printk("hid_mouse address %llx, remapped to %lx\n", lowrisc_mouse->mouse->start, (size_t)lowrisc_mouse->mouse_base);
+
+  lowrisc_mouse->mouse_base[0x800] = 0; // Reset Mouse
+  input_poll = devm_input_allocate_polled_device(dev);
+  if (!input_poll) {
+    dev_err(dev, "not enough memory for input device\n");
+    return -ENOMEM;
+  }
+
+  platform_set_drvdata(pdev, input_poll);
+
+  /* set input-polldev handlers */
+  input_poll->private = lowrisc_mouse;
+  input_poll->poll = lowrisc_mouse_scan;
+  input_poll->poll_interval = lowrisc_mouse->scan_ms;
+  
+  input = input_poll->input;
+  input->name = pdev->name;
+  input->id.bustype = BUS_HOST;
+  input->dev.parent = &pdev->dev;
+  input->open = lowrisc_open;
+  input->close = lowrisc_close;
+  
+  input_set_capability(input, EV_KEY, BTN_LEFT);
+  input_set_capability(input, EV_KEY, BTN_MIDDLE);
+  input_set_capability(input, EV_KEY, BTN_RIGHT);
+  input_set_capability(input, EV_ABS, ABS_X);
+  input_set_capability(input, EV_ABS, ABS_Y);
+  input_set_abs_params(input, ABS_X, 0, MAX_X, 0, 0);
+  input_set_abs_params(input, ABS_Y, 0, MAX_Y, 0, 0);
+
+  ret = input_register_polled_device(input_poll);
+  if (ret) {
+    dev_err(dev, "could not register input device\n");
+    return ret;
+  }
+  
+  dev_dbg(dev, "%d ms scan time\n", lowrisc_mouse->scan_ms);
+  
+  return 0;
+}
+
+static const struct of_device_id lowrisc_mouse_of_match[] = {
+	{ .compatible = "lowrisc-mouse", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, lowrisc_mouse_of_match);
+
+static struct platform_driver lowrisc_mouse_device_driver = {
+	.probe		= lowrisc_mouse_probe,
+	.driver		= {
+		.name	= "lowrisc_mouse",
+		.of_match_table = lowrisc_mouse_of_match,
+	}
+};
+module_platform_driver(lowrisc_mouse_device_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt <jrrk2@cam.ac.uk>");
+MODULE_DESCRIPTION("LowRISC PS/2 mouse driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lowrisc_mouse"); /* work with hotplug and coldplug */
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 14d89a108..f962b0518 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -940,6 +940,12 @@ config MMC_BCM2835
 
 	  If unsure, say N.
 
+config MMC_LOWRISC
+        tristate "LowRISC SD/MMC Card Interface Driver"
+        depends on RISCV
+        help
+          This selects the LowRISC SD-card driver based on Nexys4-DDR from Digilent
+
 config MMC_MTK
 	tristate "MediaTek SD/MMC Card Interface support"
 	depends on HAS_DMA
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index 73578718f..2656d1a40 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -73,6 +73,7 @@ obj-$(CONFIG_MMC_SUNXI)		+= sunxi-mmc.o
 obj-$(CONFIG_MMC_USDHI6ROL0)	+= usdhi6rol0.o
 obj-$(CONFIG_MMC_TOSHIBA_PCI)	+= toshsd.o
 obj-$(CONFIG_MMC_BCM2835)	+= bcm2835.o
+obj-$(CONFIG_MMC_LOWRISC)       += lowrisc_sd.o
 
 obj-$(CONFIG_MMC_REALTEK_PCI)	+= rtsx_pci_sdmmc.o
 obj-$(CONFIG_MMC_REALTEK_USB)	+= rtsx_usb_sdmmc.o
diff --git a/drivers/mmc/host/lowrisc_sd.c b/drivers/mmc/host/lowrisc_sd.c
new file mode 100644
index 000000000..d2570eb8a
--- /dev/null
+++ b/drivers/mmc/host/lowrisc_sd.c
@@ -0,0 +1,803 @@
+/*
+ *  LowRISC Secure Digital Host Controller Interface driver
+ *
+ *  Copyright (C) 2018 LowRISC CIC
+ *
+ *    Based on toshsd.c
+ *    Copyright (C) 2014 Ondrej Zary
+ *    Copyright (C) 2007 Richard Betts, All Rights Reserved.
+ *
+ *	Based on asic3_mmc.c, copyright (c) 2005 SDG Systems, LLC and,
+ *	sdhci.c, copyright (C) 2005-2006 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/scatterlist.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/platform_device.h>
+
+#include "lowrisc_sd.h"
+
+#define DRIVER_NAME "lowrisc-mmc"
+#define LOG(l) printk l
+#define LOGV(l) pr_debug l
+
+static volatile uint64_t *led_sd_base;
+static uint32_t led_last;
+
+#ifdef CONFIG_LOWRISC_GPIO
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#define GPIO_MAJOR  200
+#define GPIO_MINOR  0
+#define GPIO_DEV_COUNT 2
+
+static int     gpio_open( struct inode *, struct file * );
+static ssize_t gpio_read( struct file * ,        char *  , size_t, loff_t *);
+static ssize_t gpio_write(struct file * , const  char *  , size_t, loff_t *);
+static int     gpio_close(struct inode *, struct file * );
+struct file_operations gpio_fops = {
+        read    :       gpio_read,
+        write   :       gpio_write,
+        open    :       gpio_open,
+        release :       gpio_close,
+        owner   :       THIS_MODULE
+};
+
+struct cdev gpio_cdev;
+
+int gpio_init_module(void)
+{
+
+	dev_t devno;
+	unsigned int count = GPIO_DEV_COUNT; // apply for two minor for two LED
+	int err;
+
+	devno = MKDEV(GPIO_MAJOR, GPIO_MINOR);
+	register_chrdev_region(devno, count , "myLED");
+
+	// -- initial the char device 
+	cdev_init(&gpio_cdev, &gpio_fops);
+	gpio_cdev.owner = THIS_MODULE;
+	err = cdev_add(&gpio_cdev, devno, count);
+
+	if (err < 0)
+	{
+		printk("Device Add Error\n");
+		return -1;
+	}
+
+	printk("This is lowrisc-gpio driver.\n");
+
+        return 0;
+}
+
+void gpio_cleanup_module(void)
+{
+	dev_t devno;
+
+	devno = MKDEV(GPIO_MAJOR, GPIO_MINOR);
+
+	unregister_chrdev_region(devno, GPIO_DEV_COUNT);
+	cdev_del(&gpio_cdev);
+}
+
+/*
+ * file operation: OPEN 
+ * */
+static int gpio_open(struct inode *inod, struct file *fil)
+{
+    return 0;
+}
+
+/*
+ * file operation: READ
+ * */
+static ssize_t gpio_read(struct file *filp, char *buff, size_t len, loff_t *off)
+{
+  static const char hex[] = "0123456789ABCDEF";
+  
+	int led_value = 0;
+	short count;
+        char msg[5];
+
+        if (*off)
+          return 0;
+        
+        if (led_sd_base)
+          led_value = led_sd_base[from_dip];
+        
+        msg[0] = hex[(led_value >> 12)&0xF];
+        msg[1] = hex[(led_value >> 8)&0xF];
+        msg[2] = hex[(led_value >> 4)&0xF];
+        msg[3] = hex[(led_value >> 0)&0xF];
+
+        if (len > 4)
+          len = 4;
+
+	count = raw_copy_to_user(buff, msg, len);
+
+	return len;
+}
+
+/*
+ * file operation: WRITE
+ * */
+static ssize_t gpio_write(struct file *filp, const char *buff, size_t len, loff_t *off)
+{
+	short count;
+        char *endp, msg[7];
+
+        if (*off)
+          return 0;
+        
+        if (len > 6)
+          len = 6;
+	count = raw_copy_from_user( msg, buff, len );
+        msg[len] = 0;
+        
+        if (led_sd_base)
+          {
+            led_last = (led_last&red_led) | (simple_strtol(msg, &endp, 16) & ~red_led);
+            printk("User msg %s, led=%X", msg, led_last);
+            led_sd_base[led_reg] = led_last;
+          }
+	return len;
+}
+
+/*
+ * file operation : CLOSE
+ * */
+static int gpio_close(struct inode *inod, struct file *fil)
+{
+	return 0;
+}
+#endif
+
+static void lowrisc_sd_set_led(struct lowrisc_sd_host *host, unsigned char state)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  if (!led_sd_base)
+    led_sd_base = sd_base;
+  if (state)
+    led_last |= red_led;
+  else
+    led_last &= ~red_led;
+  led_sd_base[led_reg] = led_last;
+}
+
+void sd_align(struct lowrisc_sd_host *host, int d_align)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[align_reg] = d_align;
+}
+
+void sd_clk_div(struct lowrisc_sd_host *host, int clk_div)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  /* This section is incomplete */
+  sd_base[clk_din_reg] = clk_div;
+}
+
+void sd_arg(struct lowrisc_sd_host *host, uint32_t arg)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[arg_reg] = arg;
+}
+
+void sd_cmd(struct lowrisc_sd_host *host, uint32_t cmd)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[cmd_reg] = cmd;
+}
+
+void sd_setting(struct lowrisc_sd_host *host, int setting)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[setting_reg] = setting;
+}
+
+void sd_cmd_start(struct lowrisc_sd_host *host, int sd_cmd)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[start_reg] = sd_cmd;
+}
+
+void sd_reset(struct lowrisc_sd_host *host, int sd_rst, int clk_rst, int data_rst, int cmd_rst)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[reset_reg] = ((sd_rst&1) << 3)|((clk_rst&1) << 2)|((data_rst&1) << 1)|((cmd_rst&1) << 0);
+}
+
+void sd_blkcnt(struct lowrisc_sd_host *host, int d_blkcnt)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[blkcnt_reg] = d_blkcnt&0xFFFF;
+}
+
+void sd_blksize(struct lowrisc_sd_host *host, int d_blksize)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[blksiz_reg] = d_blksize&0xFFF;
+}
+
+void sd_timeout(struct lowrisc_sd_host *host, int d_timeout)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[timeout_reg] = d_timeout;
+}
+
+void sd_irq_en(struct lowrisc_sd_host *host, int mask)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  sd_base[irq_en_reg] = mask;
+  host->int_en = mask;
+  pr_debug("sd_irq_en(%X)\n", mask);
+}
+
+static void lowrisc_sd_init(struct lowrisc_sd_host *host)
+{
+
+}
+
+/* Set MMC clock / power */
+static void __lowrisc_sd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+	switch (ios->power_mode) {
+	case MMC_POWER_OFF:
+	  mdelay(1);
+	  break;
+	case MMC_POWER_UP:
+	  break;
+	case MMC_POWER_ON:
+#if 0
+	  mdelay(20);
+#endif          
+	  break;
+	}
+
+	switch (ios->bus_width) {
+	case MMC_BUS_WIDTH_1:
+	  host->width_setting = 0;
+	  break;
+	case MMC_BUS_WIDTH_4:
+	  host->width_setting = 0x20;
+	  break;
+	}
+}
+
+static void lowrisc_sd_finish_request(struct lowrisc_sd_host *host)
+{
+	struct mmc_request *mrq = host->mrq;
+
+	/* Write something to end the command */
+	host->mrq = NULL;
+	host->cmd = NULL;
+	host->data = NULL;
+
+	sd_reset(host, 0,1,0,1);
+	sd_cmd_start(host, 0);
+	sd_reset(host, 0,1,1,1);
+	lowrisc_sd_set_led(host, 0);
+	mmc_request_done(host->mmc, mrq);
+}
+  
+static void lowrisc_sd_cmd_irq(struct lowrisc_sd_host *host)
+{
+	struct mmc_command *cmd = host->cmd;
+        volatile uint64_t *sd_base = host->ioaddr;
+
+	LOGV (("lowrisc_sd_cmd_irq\n"));
+	
+	if (!host->cmd) {
+		dev_warn(&host->pdev->dev, "Spurious CMD irq\n");
+		return;
+	}
+	host->cmd = NULL;
+
+        LOGV (("lowrisc_sd_cmd_irq IRQ line %d\n", __LINE__));
+	if (cmd->flags & MMC_RSP_PRESENT && cmd->flags & MMC_RSP_136) {
+	  int i;
+	  LOGV (("lowrisc_sd_cmd_irq IRQ line %d\n", __LINE__));
+		/* R2 */
+	  for (i = 0;i < 4;i++)
+	    {
+	    cmd->resp[i] = sd_base[resp0 + (3-i)] << 8;
+	    if (i != 3)
+	      cmd->resp[i] |= sd_base[resp0 + (2-i)] >> 24;
+	    } 
+	} else if (cmd->flags & MMC_RSP_PRESENT) {
+	  LOGV (("lowrisc_sd_cmd_irq IRQ line %d\n", __LINE__));
+		/* R1, R1B, R3, R6, R7 */
+	  cmd->resp[0] = sd_base[resp0];
+	}
+
+LOGV (("Command IRQ complete %d %d %x\n", cmd->opcode, cmd->error, cmd->flags));
+
+	/* If there is data to handle we will
+	 * finish the request in the mmc_data_end_irq handler.*/
+	if (host->data)
+	  {
+	    host->int_en |= SD_CARD_RW_END;
+	  }
+	else
+	  lowrisc_sd_finish_request(host);
+}
+
+static void lowrisc_sd_data_end_irq(struct lowrisc_sd_host *host)
+{
+	struct mmc_data *data = host->data;
+	unsigned long flags;
+	
+	LOGV (("lowrisc_sd_data_end_irq\n"));
+
+	host->data = NULL;
+
+	if (!data) {
+		dev_warn(&host->pdev->dev, "Spurious data end IRQ\n");
+		return;
+	}
+
+        if (data->flags & MMC_DATA_READ)
+	  {
+            volatile uint64_t *sd_base = 0x1000 + (volatile uint64_t *)(host->ioaddr);
+            int len;
+	    size_t blksize = data->blksz;
+
+	    local_irq_save(flags);
+
+            BUG_ON(!sg_miter_next(&host->sg_miter));
+            BUG_ON(host->sg_miter.length < blksize);
+	  	  
+	    if (!((sizeof(u64)-1) & (size_t)(host->sg_miter.addr))) // optimise case for aligned buffer
+	      {
+		u64 *buf = (u64 *)(host->sg_miter.addr);
+		for (len = blksize; len > 0; len -= sizeof(u64))
+		  {
+		  *buf++ = *sd_base++;
+		  }
+	      }
+	    else
+	      {
+		u8 *buf = host->sg_miter.addr;
+		for (len = blksize; len > 0; len -= sizeof(u64))
+		  {
+		  u64 scratch = *sd_base++;
+		  memcpy(buf, &scratch, sizeof(u64));
+		  buf += sizeof(u64);
+		  }
+	      }
+            host->sg_miter.consumed = blksize;
+	    sg_miter_stop(&host->sg_miter);
+
+	    local_irq_restore(flags);
+	  }
+
+	if (data->error == 0)
+		data->bytes_xfered = data->blocks * data->blksz;
+	else
+		data->bytes_xfered = 0;
+
+	LOGV (("Completed data request xfr=%d\n",
+	      data->bytes_xfered));
+
+        //	iowrite16(0, host->ioaddr + SD_STOPINTERNAL);
+
+	lowrisc_sd_finish_request(host);
+}
+
+static irqreturn_t lowrisc_sd_irq(int irq, void *dev_id)
+{
+	struct lowrisc_sd_host *host = dev_id;
+        volatile uint64_t *sd_base = host->ioaddr;
+	u32 int_reg, int_status;
+	int error = 0, ret = IRQ_HANDLED;
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	int_status = sd_base[irq_stat_resp];
+	int_reg = int_status & host->int_en;
+
+	/* nothing to do: it's not our IRQ */
+	if (!int_reg) {
+		ret = IRQ_NONE;
+		goto irq_end;
+	}
+
+	LOGV (("lowrisc_sd IRQ status:%x enabled:%x\n", int_status, host->int_en));
+
+	if (sd_base[wait_resp] >= sd_base[timeout_resp]) {
+		error = -ETIMEDOUT;
+		LOGV (("lowrisc_sd timeout %lld clocks\n", sd_base[timeout_resp]));
+	} else if (int_reg & 0) {
+		error = -EILSEQ;
+		dev_err(&host->pdev->dev, "BadCRC\n");
+        }
+        
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+	if (error) {
+	  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+		if (host->cmd)
+			host->cmd->error = error;
+
+		if (error == -ETIMEDOUT) {
+		  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+                  sd_cmd_start(host, 0);
+                  sd_setting(host, 0);
+		} else {
+		  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+			lowrisc_sd_init(host);
+			__lowrisc_sd_set_ios(host->mmc, &host->mmc->ios);
+			goto irq_end;
+		}
+	}
+
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+        /* Card insert/remove. The mmc controlling code is stateless. */
+	if (int_reg & SD_CARD_CARD_REMOVED_0)
+	  {
+	    int mask = (host->int_en & ~SD_CARD_CARD_REMOVED_0) | SD_CARD_CARD_INSERTED_0;
+	    sd_irq_en(host, mask);
+	    printk("Card removed, mask changed to %d\n", mask);
+	    mmc_detect_change(host->mmc, 1);
+	  }
+	
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+	if (int_reg & SD_CARD_CARD_INSERTED_0)
+	  {
+	    int mask = (host->int_en & ~SD_CARD_CARD_INSERTED_0) | SD_CARD_CARD_REMOVED_0 ;
+	    sd_irq_en(host, mask);
+	    printk("Card inserted, mask changed to %d\n", mask);
+	    lowrisc_sd_init(host);
+	    mmc_detect_change(host->mmc, 1);
+	  }
+
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+	/* Command completion */
+	if (int_reg & SD_CARD_RESP_END) {
+	  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+		lowrisc_sd_cmd_irq(host);
+		host->int_en &= ~SD_CARD_RESP_END;
+	}
+
+        LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+	/* Data transfer completion */
+	if (int_reg & SD_CARD_RW_END) {
+	  LOGV (("lowrisc_sd IRQ line %d\n", __LINE__));
+
+		lowrisc_sd_data_end_irq(host);
+		host->int_en &= ~SD_CARD_RW_END;
+	}
+irq_end:
+        sd_irq_en(host, host->int_en);
+	spin_unlock_irqrestore(&host->lock, flags);
+	return ret;
+}
+
+static void lowrisc_sd_start_cmd(struct lowrisc_sd_host *host, struct mmc_command *cmd)
+{
+  int setting = 0;
+  int timeout = 1000000;
+  struct mmc_data *data = host->data;
+  volatile uint64_t *sd_base = host->ioaddr;
+  unsigned long flags;
+  spin_lock_irqsave(&host->lock, flags);
+
+  LOGV (("Command opcode: %d\n", cmd->opcode));
+/*
+  if (cmd->opcode == MMC_STOP_TRANSMISSION) {
+    sd_cmd(host, SD_STOPINT_ISSUE_CMD12);
+
+    cmd->resp[0] = cmd->opcode;
+    cmd->resp[1] = 0;
+    cmd->resp[2] = 0;
+    cmd->resp[3] = 0;
+    
+    lowrisc_sd_finish_request(host);
+    return;
+  }
+*/
+  if (!(cmd->flags & MMC_RSP_PRESENT))
+    setting = 0;
+  else if (cmd->flags & MMC_RSP_136)
+    setting = 3;
+  else if (cmd->flags & MMC_RSP_BUSY)
+    setting = 1;
+  else
+    setting = 1;
+  setting |= host->width_setting;
+  
+  host->cmd = cmd;
+  
+  if (cmd->opcode == MMC_APP_CMD)
+    {
+      /* placeholder */
+    }
+  
+  if (cmd->opcode == MMC_GO_IDLE_STATE)
+    {
+      /* placeholder */
+    }
+
+  LOGV (("testing data flags\n"));
+  if (data) {
+    setting |= 0x4;
+    if (data->flags & MMC_DATA_READ)
+      setting |= 0x10;
+    else
+      {
+      setting |= 0x8;
+      }
+  }
+
+  LOGV (("writing registers\n"));
+  /* Send the command */
+  sd_reset(host, 0,1,0,1);
+  sd_align(host, 0);
+  sd_arg(host, cmd->arg);
+  sd_cmd(host, cmd->opcode);
+  sd_setting(host, setting);
+  sd_cmd_start(host, 0);
+  sd_reset(host, 0,1,1,1);
+  sd_timeout(host, timeout);
+  /* start the transaction */ 
+  sd_cmd_start(host, 1);
+  LOGV (("enabling interrupt\n"));
+  sd_irq_en(host, sd_base[irq_en_resp] | SD_CARD_RESP_END);
+  spin_unlock_irqrestore(&host->lock, flags);
+ LOGV (("leaving lowrisc_sd_start_cmd\n"));
+}
+
+static void lowrisc_sd_start_data(struct lowrisc_sd_host *host, struct mmc_data *data)
+{
+	unsigned int flags = SG_MITER_ATOMIC;
+
+	LOGV (("setup data transfer: blocksize %08x  nr_blocks %d, offset: %08x\n",
+	      data->blksz, data->blocks, data->sg->offset));
+
+	host->data = data;
+
+	if (data->flags & MMC_DATA_READ)
+		flags |= SG_MITER_TO_SG;
+	else
+		flags |= SG_MITER_FROM_SG;
+
+	sg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);
+
+	/* Set transfer length and blocksize */
+	sd_blkcnt(host, data->blocks);
+	sd_blksize(host, data->blksz);
+
+        if (!(data->flags & MMC_DATA_READ))
+	  {
+            volatile uint64_t *sd_base = 0x1000 + (volatile uint64_t *)(host->ioaddr);
+            struct mmc_data *data = host->data;
+            if (sg_miter_next(&host->sg_miter))
+              {
+                int len;
+                size_t blksize = data->blksz;
+                BUG_ON(host->sg_miter.length < blksize);
+		if (!((sizeof(u64)-1) & (size_t)(host->sg_miter.addr))) // optimise case for aligned buffer
+		  {
+		    u64 *buf = (u64 *)(host->sg_miter.addr);
+		    for (len = blksize; len > 0; len -= sizeof(u64))
+		      {
+			*sd_base++ = *buf++;
+		      }
+		  }
+		else
+		  {
+		    u8 *buf = host->sg_miter.addr;
+		    for (len = blksize; len > 0; len -= sizeof(u64))
+		      {
+			u64 scratch;
+			memcpy(&scratch, buf, sizeof(u64));
+			buf += sizeof(u64);
+			*sd_base++ = scratch;
+		      }
+		  }
+                host->sg_miter.consumed = blksize;
+                sg_miter_stop(&host->sg_miter);
+              }
+          }
+}
+
+/* Process requests from the MMC layer */
+static void lowrisc_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+	unsigned long flags;
+
+	/* abort if card not present */
+	if (sd_base[detect_resp]) {
+		mrq->cmd->error = -ENOMEDIUM;
+		mmc_request_done(mmc, mrq);
+		return;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	WARN_ON(host->mrq != NULL);
+
+	host->mrq = mrq;
+
+	if (mrq->data)
+		lowrisc_sd_start_data(host, mrq->data);
+
+	lowrisc_sd_set_led(host, 1);
+
+	lowrisc_sd_start_cmd(host, mrq->cmd);
+
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static void lowrisc_sd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+	unsigned long flags;
+
+	spin_lock_irqsave(&host->lock, flags);
+	__lowrisc_sd_set_ios(mmc, ios);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
+static int lowrisc_sd_get_ro(struct mmc_host *mmc)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+	return sd_base[detect_resp];
+}
+
+static int lowrisc_sd_get_cd(struct mmc_host *mmc)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+
+	return !sd_base[detect_resp];
+}
+
+static int lowrisc_sd_card_busy(struct mmc_host *mmc)
+{
+	struct lowrisc_sd_host *host = mmc_priv(mmc);
+        volatile uint64_t *sd_base = host->ioaddr;
+	return sd_base[start_resp];
+}
+
+static struct mmc_host_ops lowrisc_sd_ops = {
+	.request = lowrisc_sd_request,
+	.set_ios = lowrisc_sd_set_ios,
+	.get_ro = lowrisc_sd_get_ro,
+	.get_cd = lowrisc_sd_get_cd,
+	.card_busy = lowrisc_sd_card_busy,
+};
+
+
+static void lowrisc_sd_powerdown(struct lowrisc_sd_host *host)
+{
+  volatile uint64_t *sd_base = host->ioaddr;
+  /* mask all interrupts */
+  sd_base[irq_en_reg] = 0;
+  /* disable card clock */
+}
+
+static int lowrisc_sd_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct lowrisc_sd_host *host;
+	struct mmc_host *mmc;
+        struct resource *iomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mmc = mmc_alloc_host(sizeof(struct lowrisc_sd_host), &pdev->dev);
+	if (!mmc) {
+		ret = -ENOMEM;
+		goto release;
+	}
+
+	host = mmc_priv(mmc);
+	host->mmc = mmc;
+
+	host->pdev = pdev;
+
+	if (!request_mem_region(iomem->start, resource_size(iomem),
+		mmc_hostname(host->mmc))) {
+		dev_err(&pdev->dev, "cannot request region\n");
+		ret = -EBUSY;
+		goto release;
+	}
+        
+        led_sd_base = host->ioaddr;
+#ifdef CONFIG_LOWRISC_GPIO
+        gpio_init_module();
+#endif
+	host->ioaddr = ioremap(iomem->start, resource_size(iomem));
+	if (!host->ioaddr) {
+		ret = -ENOMEM;
+		goto release;
+	}
+	printk("lowrisc-digilent-sd: Lowrisc sd platform driver (%llX-%llX) mapped to %lx\n",
+               iomem[0].start,
+               iomem[0].end,
+               (size_t)(host->ioaddr));
+        
+        host->irq = platform_get_irq(pdev, 0);
+        
+	/* Set MMC host parameters */
+	mmc->ops = &lowrisc_sd_ops;
+	mmc->caps = MMC_CAP_4_BIT_DATA;
+	mmc->ocr_avail = MMC_VDD_32_33;
+
+	mmc->f_min = 5000000;
+	mmc->f_max = 5000000;
+	mmc->max_blk_count = 1;
+	
+	spin_lock_init(&host->lock);
+
+	lowrisc_sd_init(host);
+
+	ret = request_irq(host->irq, lowrisc_sd_irq, 0, DRIVER_NAME, host);
+        
+	if (ret)
+          {
+            printk("request_irq failed\n");
+            goto unmap;
+          }
+
+	mmc_add_host(mmc);
+
+	printk("lowrisc-sd driver loaded, IRQ %d\n", host->irq);
+	sd_irq_en(host, SD_CARD_CARD_INSERTED_0 | SD_CARD_CARD_REMOVED_0); /* get an interrupt either way */
+	return 0;
+
+unmap:
+release:
+	mmc_free_host(mmc);
+	return ret;
+}
+
+static int lowrisc_sd_remove(struct platform_device *pdev)
+{
+	struct lowrisc_sd_host *host = platform_get_drvdata(pdev);
+
+	mmc_remove_host(host->mmc);
+	lowrisc_sd_powerdown(host);
+	free_irq(host->irq, host);
+	mmc_free_host(host->mmc);
+        return 0;
+}
+
+static const struct of_device_id lowrisc_sd_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, lowrisc_sd_of_match);
+
+static struct platform_driver lowrisc_sd_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_sd_of_match,
+	},
+	.probe = lowrisc_sd_probe,
+	.remove = lowrisc_sd_remove,
+};
+
+module_platform_driver(lowrisc_sd_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("LowRISC Secure Digital Host Controller Interface driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/lowrisc_sd.h b/drivers/mmc/host/lowrisc_sd.h
new file mode 100644
index 000000000..8aa18fa0e
--- /dev/null
+++ b/drivers/mmc/host/lowrisc_sd.h
@@ -0,0 +1,52 @@
+/*
+ *  LowRISC PCI Secure Digital Host Controller Interface driver
+ *
+ *  Based on toshsd.h
+ *
+ *  Copyright (C) 2014 Ondrej Zary
+ *  Copyright (C) 2007 Richard Betts, All Rights Reserved.
+ *
+ *      Based on asic3_mmc.c Copyright (c) 2005 SDG Systems, LLC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+enum {align_reg,clk_din_reg,arg_reg,cmd_reg,
+      setting_reg,start_reg,reset_reg,blkcnt_reg,
+      blksiz_reg,timeout_reg,clk_pll_reg,irq_en_reg,
+      unused1,unused2,unused3,led_reg};
+
+enum {resp0,resp1,resp2,resp3,
+      wait_resp,status_resp,packet_resp0,packet_resp1,
+      data_wait_resp,trans_cnt_resp,obsolete1,obsolet2,
+      detect_resp,xfr_addr_resp,irq_stat_resp,pll_resp,
+      align_resp,clk_din_resp,arg_resp,cmd_i_resp,
+      setting_resp,start_resp,reset_resp,blkcnt_resp,
+      blksize_resp,timeout_resp,clk_pll_resp,irq_en_resp,
+      dead1,dead2,dead3,from_dip};
+
+enum {SD_APP_OP_COND=41, data_buffer_offset=0x2000};
+
+enum {SD_CARD_RESP_END=1,SD_CARD_RW_END=2, SD_CARD_CARD_REMOVED_0=4, SD_CARD_CARD_INSERTED_0=8};
+
+enum {red_led = 1 << 21};
+
+struct lowrisc_sd_host {
+  struct platform_device *pdev;
+  struct mmc_host *mmc;
+
+  spinlock_t lock;
+
+  struct mmc_request *mrq;/* Current request */
+  struct mmc_command *cmd;/* Current command */
+  struct mmc_data *data;	/* Current data request */
+
+  struct sg_mapping_iter sg_miter; /* for PIO */
+
+  void __iomem *ioaddr; /* mapped address */
+  int irq;
+  int int_en, width_setting;
+};
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 93a2d4deb..ff0cb807c 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -117,6 +117,7 @@ config LANTIQ_XRX200
 	  Support for the PMAC of the Gigabit switch (GSWIP) inside the
 	  Lantiq / Intel VRX200 VDSL SoC
 
+source "drivers/net/ethernet/lowrisc/Kconfig"
 source "drivers/net/ethernet/marvell/Kconfig"
 source "drivers/net/ethernet/mediatek/Kconfig"
 source "drivers/net/ethernet/mellanox/Kconfig"
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index fb9155cff..8798dbdea 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -51,6 +51,7 @@ obj-$(CONFIG_JME) += jme.o
 obj-$(CONFIG_KORINA) += korina.o
 obj-$(CONFIG_LANTIQ_ETOP) += lantiq_etop.o
 obj-$(CONFIG_LANTIQ_XRX200) += lantiq_xrx200.o
+obj-$(CONFIG_NET_VENDOR_LOWRISC) += lowrisc/
 obj-$(CONFIG_NET_VENDOR_MARVELL) += marvell/
 obj-$(CONFIG_NET_VENDOR_MEDIATEK) += mediatek/
 obj-$(CONFIG_NET_VENDOR_MELLANOX) += mellanox/
diff --git a/drivers/net/ethernet/lowrisc/Kconfig b/drivers/net/ethernet/lowrisc/Kconfig
new file mode 100644
index 000000000..802422de6
--- /dev/null
+++ b/drivers/net/ethernet/lowrisc/Kconfig
@@ -0,0 +1,33 @@
+#
+# Xilink device configuration
+#
+
+config NET_VENDOR_LOWRISC
+	bool "Lowrisc devices"
+	default y
+	depends on RISCV
+	---help---
+	  If you have a network (Ethernet) card belonging to this class, say Y.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about Lowrisc devices. If you say Y, you will be asked
+	  for your specific card in the following questions.
+
+if NET_VENDOR_LOWRISC
+
+config LOWRISC_DIGILENT_100MHZ
+	tristate "Lowrisc 100MHz Ethernet Nexys4_DDR support"
+	depends on RISCV
+	select PHYLIB
+	---help---
+	  This driver supports the 100MHz Ethernet for Nexys4_DDR Digilent boards from Lowrisc.
+
+config LOWRISC_MII_INIT
+       bool "Make PHY visible to Ethernet driver"
+       default y
+       depends on RISCV
+       ---help---
+         If you have software that interferes with correct PHY operation, disable this option.
+
+endif # NET_VENDOR_LOWRISC
diff --git a/drivers/net/ethernet/lowrisc/Makefile b/drivers/net/ethernet/lowrisc/Makefile
new file mode 100644
index 000000000..4eb3adee1
--- /dev/null
+++ b/drivers/net/ethernet/lowrisc/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the Lowrisc network device driver.
+#
+
+obj-$(CONFIG_LOWRISC_DIGILENT_100MHZ) += lowrisc_100MHz.o
+CFLAGS_lowrisc_100MHz.o := -DDEBUG
diff --git a/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c b/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c
new file mode 100644
index 000000000..430665bc3
--- /dev/null
+++ b/drivers/net/ethernet/lowrisc/lowrisc_100MHz.c
@@ -0,0 +1,841 @@
+/*
+ * Lowrisc Ether100MHz Linux driver for the Lowrisc Ethernet 100MHz device.
+ *
+ * This is an experimental driver which is based on the original emac_lite
+ * driver from John Williams <john.williams@xilinx.com>.
+ *
+ * 2007 - 2013 (c) Xilinx, Inc.
+ * PHY control portions copyright (C) 2015 Microchip Technology
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/phy.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/of_device.h>
+#include <linux/phy.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/spinlock.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/mdio-bitbang.h>
+#include <linux/mdio-gpio.h>
+#include "lowrisc_100MHz.h"
+
+#define DRIVER_AUTHOR	"WOOJUNG HUH <woojung.huh@microchip.com>"
+#define DRIVER_DESC	"Microchip LAN8720 PHY driver"
+#define DRIVER_NAME     "lowrisc-eth"
+
+/* General Ethernet Definitions */
+#define XEL_ARP_PACKET_SIZE		28	/* Max ARP packet size */
+#define XEL_HEADER_IP_LENGTH_OFFSET	16	/* IP Length Offset */
+
+#define TX_TIMEOUT		(60*HZ)		/* Tx timeout is 60 seconds. */
+
+/**
+ * struct net_local - Our private per device data
+ * @ndev:		instance of the network device
+ * @reset_lock:		lock used for synchronization
+ * @phy_dev:		pointer to the PHY device
+ * @phy_node:		pointer to the PHY device node
+ * @mii_bus:		pointer to the MII bus
+ * @last_link:		last link status
+ */
+struct net_local {
+  struct mdiobb_ctrl ctrl; /* must be first for bitbang driver to work */
+  void __iomem *ioaddr;
+  struct net_device *ndev;
+  u32 msg_enable;
+  
+  struct phy_device *phy_dev;
+  struct mii_bus *mii_bus;
+  int last_duplex;
+  int last_carrier;
+  
+  /* Spinlock */
+  struct mutex lock;
+  uint32_t last_mdio_gpio;
+  int irq, num_tests, phy_addr;
+  uint32_t crc_err_old, fram_err_old;
+  
+  struct napi_struct napi;
+};
+
+static void inline eth_write(struct net_local *priv, size_t addr, uint64_t data)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  eth_base[addr >> 3] = data;
+}
+
+static void inline eth_copyout(struct net_local *priv, uint8_t *data, int len)
+{
+  int i, rnd = ((len-1)|7)+1;
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (!(((size_t)data) & 7))
+    {
+      uint64_t *ptr = (uint64_t *)data;
+      for (i = 0; i < rnd/8; i++)
+        eth_base[TXBUFF_OFFSET/8 + i] = ptr[i];
+    }
+  else // We can't unfortunately rely on the skb being word aligned
+    {
+      uint64_t notptr;
+      for (i = 0; i < rnd/8; i++)
+        {
+          memcpy(&notptr, data+(i<<3), sizeof(uint64_t));
+          eth_base[TXBUFF_OFFSET/8 + i] = notptr;
+        }
+    }
+}
+
+static volatile inline uint64_t eth_read(struct net_local *priv, size_t addr)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  return eth_base[addr >> 3];
+}
+
+static inline void eth_copyin(struct net_local *priv, uint8_t *data, int len, int start)
+{
+  int i, rnd = ((len-1)|7)+1;
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (!(((size_t)data) & 7))
+    {
+      uint64_t *ptr = (uint64_t *)data;
+      for (i = 0; i < rnd/8; i++)
+        ptr[i] = eth_base[start + i];
+    }
+  else // We can't unfortunately rely on the skb being word aligned
+    {
+      for (i = 0; i < rnd/8; i++)
+        {
+          uint64_t notptr = eth_base[start + i];
+          memcpy(data+(i<<3), &notptr, sizeof(uint64_t));
+        }
+    }
+}
+
+static void inline eth_enable_irq(struct net_local *priv)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  eth_base[MACHI_OFFSET >> 3] |= MACHI_IRQ_EN;
+  mmiowb();
+}
+
+static void inline eth_disable_irq(struct net_local *priv)
+{
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  eth_base[MACHI_OFFSET >> 3] &= ~MACHI_IRQ_EN;
+  mmiowb();
+}
+
+/**
+ * lowrisc_update_address - Update the MAC address in the device
+ * @drvdata:	Pointer to the Ether100MHz device private data
+ * @address_ptr:Pointer to the MAC address (MAC address is a 48-bit value)
+ *
+ * Tx must be idle and Rx should be idle for deterministic results.
+ * It is recommended that this function should be called after the
+ * initialization and before transmission of any packets from the device.
+ * The MAC address can be programmed using any of the two transmit
+ * buffers (if configured).
+ */
+
+static void lowrisc_update_address(struct net_local *priv, u8 *address_ptr)
+{
+  uint32_t macaddr_lo, macaddr_hi;
+  memcpy (&macaddr_lo, address_ptr+2, sizeof(uint32_t));
+  memcpy (&macaddr_hi, address_ptr+0, sizeof(uint16_t));
+  mutex_lock(&priv->lock);
+  eth_write(priv, MACLO_OFFSET, htonl(macaddr_lo));
+  eth_write(priv, MACHI_OFFSET, htons(macaddr_hi));
+  eth_write(priv, RFCS_OFFSET, 8); /* use 8 buffers */
+  mutex_unlock(&priv->lock);
+}
+
+/**
+ * lowrisc_read_mac_address - Read the MAC address in the device
+ * @drvdata:	Pointer to the Ether100MHz device private data
+ * @address_ptr:Pointer to the 6-byte buffer to receive the MAC address (MAC address is a 48-bit value)
+ *
+ * In lowrisc the starting value is programmed by the boot loader according to DIP switch [15:12]
+ */
+
+static void lowrisc_read_mac_address(struct net_local *priv, u8 *address_ptr)
+{
+  uint32_t macaddr_hi, macaddr_lo;
+  mutex_lock(&priv->lock);
+  macaddr_hi = ntohs(eth_read(priv, MACHI_OFFSET)&MACHI_MACADDR_MASK);
+  macaddr_lo = ntohl(eth_read(priv, MACLO_OFFSET));
+  mutex_unlock(&priv->lock);
+  memcpy (address_ptr+2, &macaddr_lo, sizeof(uint32_t));
+  memcpy (address_ptr+0, &macaddr_hi, sizeof(uint16_t));
+}
+
+/**
+ * lowrisc_set_mac_address - Set the MAC address for this device
+ * @dev:	Pointer to the network device instance
+ * @addr:	Void pointer to the sockaddr structure
+ *
+ * This function copies the HW address from the sockaddr strucutre to the
+ * net_device structure and updates the address in HW.
+ *
+ * Return:	Error if the net device is busy or 0 if the addr is set
+ *		successfully
+ */
+static int lowrisc_set_mac_address(struct net_device *ndev, void *address)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	struct sockaddr *addr = address;
+	memcpy(ndev->dev_addr, addr->sa_data, ndev->addr_len);
+	lowrisc_update_address(priv, ndev->dev_addr);
+	return 0;
+}
+
+/**
+ * lowrisc_tx_timeout - Callback for Tx Timeout
+ * @dev:	Pointer to the network device
+ *
+ * This function is called when Tx time out occurs for Ether100MHz device.
+ */
+static void lowrisc_tx_timeout(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+
+	dev_err(&priv->ndev->dev, "Exceeded transmit timeout of %lu ms\n",
+		TX_TIMEOUT * 1000UL / HZ);
+
+	ndev->stats.tx_errors++;
+
+	/* Reset the device */
+	mutex_lock(&priv->lock);
+
+	/* Shouldn't really be necessary, but shouldn't hurt */
+	netif_stop_queue(ndev);
+
+	/* To exclude tx timeout */
+        netif_trans_update(ndev); /* prevent tx timeout */
+
+	/* We're all ready to go. Start the queue */
+	netif_wake_queue(ndev);
+	mutex_unlock(&priv->lock);
+}
+
+/**
+ * lowrisc_close - Close the network device
+ * @dev:	Pointer to the network device
+ *
+ * This function stops the Tx queue, disables interrupts and frees the IRQ for
+ * the Ether100MHz device.
+ * It also disconnects the phy device associated with the Ether100MHz device.
+ */
+static int lowrisc_close(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+
+	netif_stop_queue(ndev);
+        napi_disable(&priv->napi);
+        mutex_lock(&priv->lock);
+	eth_disable_irq(priv);
+        mutex_unlock(&priv->lock);
+
+	if (priv->irq)
+		free_irq(priv->irq, priv);
+
+        pr_debug("Close device, free interrupt\n");
+        
+	if (priv->phy_dev)
+		phy_disconnect(priv->phy_dev);
+	priv->phy_dev = NULL;
+
+	return 0;
+}
+
+/**
+ * lowrisc_remove_ndev - Free the network device
+ * @ndev:	Pointer to the network device to be freed
+ *
+ * This function un maps the IO region of the Ether100MHz device and frees the net
+ * device.
+ */
+static void lowrisc_remove_ndev(struct net_device *ndev)
+{
+	if (ndev) {
+		free_netdev(ndev);
+	}
+}
+
+#ifdef CONFIG_LOWRISC_MII_INIT
+static void lowrisc_phy_adjust_link(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	struct phy_device *phy_dev = priv->phy_dev;
+	int carrier;
+
+	if (phy_dev->duplex != priv->last_duplex) {
+		if (phy_dev->duplex) {
+			netif_dbg(priv, link, priv->ndev, "full duplex mode\n");
+		} else {
+			netif_dbg(priv, link, priv->ndev, "half duplex mode\n");
+		}
+
+		priv->last_duplex = phy_dev->duplex;
+	}
+
+	carrier = netif_carrier_ok(ndev);
+	if (carrier != priv->last_carrier) {
+		if (carrier)
+			netif_dbg(priv, link, priv->ndev, "carrier OK\n");
+		else
+			netif_dbg(priv, link, priv->ndev, "no carrier\n");
+		priv->last_carrier = carrier;
+	}
+}
+
+static int lowrisc_mii_probe(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+	const char *phyname;
+
+	BUG_ON(priv->phy_dev);
+
+	/* find the first (lowest address) PHY
+	 * on the current MAC's MII bus
+	 */
+	for (priv->phy_addr = 1; priv->phy_addr < PHY_MAX_ADDR; priv->phy_addr++)
+          {
+            phydev = mdiobus_get_phy(priv->mii_bus, priv->phy_addr);
+            if (phydev) {
+              /* break out with first one found */
+              break;
+            }
+          }
+	if (!phydev) {
+          netdev_err(ndev, "no PHY found in range address 0..%d\n", PHY_MAX_ADDR-1);
+		return -ENODEV;
+	}
+
+	phyname = phydev_name(phydev);
+	printk("Probing %s (address %d)\n", phyname, priv->phy_addr);
+	
+	phydev = phy_connect(ndev, phyname,
+			     lowrisc_phy_adjust_link, PHY_INTERFACE_MODE_MII);
+
+	if (IS_ERR(phydev)) {
+		netdev_err(ndev, "Could not attach to PHY\n");
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	linkmode_copy(phydev->advertising, phydev->supported);
+
+	phy_attached_info(phydev);
+
+	priv->phy_dev = phydev;
+	priv->last_duplex = -1;
+	priv->last_carrier = -1;
+
+	return 0;
+}
+
+static void mdio_dir(struct mdiobb_ctrl *ctrl, int dir)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (dir)
+    priv->last_mdio_gpio |= MDIOCTRL_MDIOOEN_MASK; // output driving
+  else
+    priv->last_mdio_gpio &= ~MDIOCTRL_MDIOOEN_MASK; // input receiving
+  eth_base[MDIOCTRL_OFFSET >> 3] = priv->last_mdio_gpio;
+  mmiowb();
+}
+
+static int mdio_get(struct mdiobb_ctrl *ctrl)
+{
+  int retval;
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  retval = eth_base[MDIOCTRL_OFFSET >> 3];
+  return retval & MDIOCTRL_MDIOIN_MASK ? 1:0;
+}
+
+static void mdio_set(struct mdiobb_ctrl *ctrl, int what)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (what)
+    priv->last_mdio_gpio |= MDIOCTRL_MDIOOUT_MASK;
+  else
+    priv->last_mdio_gpio &= ~MDIOCTRL_MDIOOUT_MASK;
+  eth_base[MDIOCTRL_OFFSET >> 3] = priv->last_mdio_gpio;
+  mmiowb();
+}
+
+static void mdc_set(struct mdiobb_ctrl *ctrl, int what)
+{
+  struct net_local *priv = (struct net_local *)ctrl; /* struct mdiobb_ctrl must be first in net_local for bitbang driver to work */
+  volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+  if (what)
+    priv->last_mdio_gpio |= MDIOCTRL_MDIOCLK_MASK;
+  else
+    priv->last_mdio_gpio &= ~MDIOCTRL_MDIOCLK_MASK;
+  eth_base[MDIOCTRL_OFFSET >> 3] = priv->last_mdio_gpio;
+  mmiowb();
+}
+
+static struct mdiobb_ops mdio_gpio_ops = {
+        .owner = THIS_MODULE,
+        .set_mdc = mdc_set,
+        .set_mdio_dir = mdio_dir,
+        .set_mdio_data = mdio_set,
+        .get_mdio_data = mdio_get,
+};
+
+static int lowrisc_mii_init(struct net_device *ndev)
+{
+        struct mii_bus *new_bus;
+	struct net_local *priv = netdev_priv(ndev);
+	int err = -ENXIO;
+	
+	priv->ctrl.ops = &mdio_gpio_ops;
+        new_bus = alloc_mdio_bitbang(&(priv->ctrl));
+
+	if (!new_bus) {
+		err = -ENOMEM;
+		goto err_out_1;
+	}
+	snprintf(new_bus->id, MII_BUS_ID_SIZE, "lowrisc-0");
+        new_bus->name = "GPIO Bitbanged LowRISC",
+
+        new_bus->phy_mask = ~(1 << 1);
+        new_bus->phy_ignore_ta_mask = 0;
+
+	mutex_init(&(new_bus->mdio_lock));
+	
+	priv->mii_bus = new_bus;
+	priv->mii_bus->priv = priv;
+
+	/* Mask all PHYs except ID 1 (internal) */
+	priv->mii_bus->phy_mask = ~(1 << 1);
+
+	if (mdiobus_register(priv->mii_bus)) {
+		netif_warn(priv, probe, priv->ndev, "Error registering mii bus\n");
+		goto err_out_free_bus_2;
+	}
+
+	if (lowrisc_mii_probe(ndev) < 0) {
+		netif_warn(priv, probe, priv->ndev, "Error probing mii bus\n");
+		goto err_out_unregister_bus_3;
+	}
+
+	return 0;
+
+err_out_unregister_bus_3:
+	mdiobus_unregister(priv->mii_bus);
+err_out_free_bus_2:
+	mdiobus_free(priv->mii_bus);
+err_out_1:
+	return err;
+}
+#endif
+
+/**********************/
+/* Interrupt Handlers */
+/**********************/
+
+/**
+ * lowrisc_ether_isr - Interrupt handler for frames received
+ * @priv:	Pointer to the struct net_local
+ *
+ * This function allocates memory for a socket buffer, fills it with data
+ * received and hands it over to the TCP/IP stack.
+ */
+
+static int lowrisc_ether_poll(struct napi_struct *napiptr, int budget)
+{
+  int rsr, buf, rx_count = 0;
+  struct net_local *priv = container_of(napiptr, struct net_local, napi);
+  struct net_device *ndev = priv->ndev;
+  rsr = eth_read(priv, RSR_OFFSET);
+  buf = rsr & RSR_RECV_FIRST_MASK;
+  /* Check if there is Rx Data available */
+  while ((rsr & RSR_RECV_DONE_MASK) && (rx_count < budget))
+    {
+      int len = eth_read(priv, RPLR_OFFSET+((buf&7)<<3)) - 4; /* discard FCS bytes ?? */
+      if ((len >= 60) && (len <= ETH_FRAME_LEN + ETH_FCS_LEN))
+	{
+	  int rnd = ((len-1)|7)+1; /* round to a multiple of 8 */
+	  struct sk_buff *skb = __napi_alloc_skb(&priv->napi, rnd, GFP_ATOMIC|__GFP_NOWARN); // Don't warn, just drop surplus packets
+	  if (unlikely(!skb))
+	    {
+	      /* Couldn't get memory, we carry on regardless and drop if necessary */
+	      ndev->stats.rx_dropped++;
+	    }
+	  else
+	    {
+	      int start = RXBUFF_OFFSET/8 + ((buf&7)<<8);
+              skb_put(skb, len);	/* Tell the skb how much data we got */
+	      
+              eth_copyin(priv, skb->data, len, start);
+              skb->protocol = eth_type_trans(skb, ndev);
+              netif_receive_skb(skb);
+              ndev->stats.rx_packets++;
+              ndev->stats.rx_bytes += len;
+              ++rx_count;
+            }
+        }
+      else
+        {
+	  ndev->stats.rx_length_errors++;
+        }
+      ndev->stats.rx_crc_errors = (eth_read(priv, RFCS_OFFSET) >> 32) - priv->crc_err_old;
+      ndev->stats.rx_frame_errors = (eth_read(priv, TFCS_OFFSET) >> 32) - priv->fram_err_old;
+      /* acknowledge, even if an error occurs, to reset irq */
+      eth_write(priv, RSR_OFFSET, ++buf);
+      rsr = eth_read(priv, RSR_OFFSET);
+    }
+
+  if (rsr & RSR_RECV_DONE_MASK)
+    {
+      return 1;
+    }
+  else
+    {
+      napi_complete_done(&priv->napi, rx_count);
+      eth_enable_irq(priv);
+      return 0;
+    }
+}
+
+irqreturn_t lowrisc_ether_isr(int irq, void *priv_id)
+{
+  int rsr = 0;
+  struct net_local *priv = priv_id;
+  struct net_device *ndev = priv->ndev;
+  if (napi_schedule_prep(&priv->napi))
+    {
+      eth_disable_irq(priv);
+      __napi_schedule(&priv->napi);
+    }
+  else /* we are in denial of service mode */
+    do
+      {
+        int buf = rsr & RSR_RECV_FIRST_MASK;
+        ndev->stats.rx_dropped++;            
+        eth_write(priv, RSR_OFFSET, ++buf);
+        rsr = eth_read(priv, RSR_OFFSET);
+      }
+    while (rsr & RSR_RECV_DONE_MASK);
+  return IRQ_HANDLED;
+}
+
+static int lowrisc_get_regs_len(struct net_device __always_unused *netdev)
+{
+#define LOWRISC_REGS_LEN 64	/* overestimate */
+  return LOWRISC_REGS_LEN * sizeof(u32);
+}
+
+static void lowrisc_get_regs(struct net_device *ndev,
+			   struct ethtool_regs *regs, void *p)
+{
+  struct net_local *priv = netdev_priv(ndev);
+  struct phy_device *phy = priv->phy_dev;
+
+  u32 *regs_buff = p;
+  int i;
+
+  memset(p, 0, LOWRISC_REGS_LEN * sizeof(u32));
+
+  regs->version = 0;
+  mutex_lock(&priv->lock);
+  for (i = 0; i < LOWRISC_REGS_LEN; i++)
+    {
+      if (i >= 32)
+	regs_buff[i] = eth_read(priv, MACLO_OFFSET+((i-32)/2)*8) >> (i%2 << 5);
+      else
+	{
+	regs_buff[i] = phy_read(phy, i);
+	}
+    }
+  mutex_unlock(&priv->lock);
+}
+
+static const struct ethtool_ops lowrisc_ethtool_ops = {
+	.get_regs_len		= lowrisc_get_regs_len,
+	.get_regs		= lowrisc_get_regs,
+        .get_link_ksettings     = phy_ethtool_get_link_ksettings,
+        .set_link_ksettings     = phy_ethtool_set_link_ksettings        
+};
+
+/**
+ * lowrisc_open - Open the network device
+ * @dev:	Pointer to the network device
+ *
+ * This function sets the MAC address, requests an IRQ and enables interrupts
+ * for the Ether100MHz device and starts the Tx queue.
+ * It also connects to the phy device, if MDIO is included in Ether100MHz device.
+ */
+
+static int lowrisc_open(struct net_device *ndev)
+{
+  int retval = 0;
+  struct net_local *priv = netdev_priv(ndev);
+  ndev->ethtool_ops = &lowrisc_ethtool_ops;
+
+  /* Set the MAC address each time opened */
+  lowrisc_update_address(priv, ndev->dev_addr);
+  /* reset stats */
+  memset(&(ndev->stats), 0, sizeof(ndev->stats));
+  priv->crc_err_old = eth_read(priv, RFCS_OFFSET) >> 32;
+  priv->fram_err_old = eth_read(priv, TFCS_OFFSET) >> 32;
+  
+  if (priv->phy_dev) {
+    linkmode_copy(priv->phy_dev->advertising, priv->phy_dev->supported);
+    phy_start(priv->phy_dev);
+  }
+  
+  /* Grab the IRQ */
+  pr_debug("Open device, request interrupt %d\n", priv->irq);
+  retval = request_irq(priv->irq, lowrisc_ether_isr, 0, ndev->name, priv);
+  if (retval) {
+    dev_err(&priv->ndev->dev, "Could not allocate interrupt %d\n", priv->irq);
+    if (priv->phy_dev)
+      phy_disconnect(priv->phy_dev);
+    priv->phy_dev = NULL;
+    return retval;
+  }
+  
+  lowrisc_update_address(priv, ndev->dev_addr);
+
+  /* We're ready to go */
+  napi_enable(&priv->napi);
+  netif_start_queue(ndev);
+
+  /* enable the irq */
+  eth_enable_irq(priv);
+  return 0;
+}
+
+/**
+ * lowrisc_send - Transmit a frame
+ * @orig_skb:	Pointer to the socket buffer to be transmitted
+ * @dev:	Pointer to the network device
+ *
+ * This function checks if the Tx buffer of the Ether100MHz device is free to send
+ * data. If so, it fills the Tx buffer with data from socket buffer data,
+ * updates the stats and frees the socket buffer.
+ * Return:	0, always.
+ */
+static netdev_tx_t lowrisc_send(struct sk_buff *new_skb, struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+	unsigned int len = new_skb->len;
+        int rslt;
+	if (mutex_is_locked(&priv->lock))
+          return NETDEV_TX_BUSY;
+        rslt = eth_read(priv, TPLR_OFFSET);
+        if (rslt & TPLR_BUSY_MASK)
+          return NETDEV_TX_BUSY;
+        eth_copyout(priv, new_skb->data, len);
+        eth_write(priv, TPLR_OFFSET, len);
+
+	skb_tx_timestamp(new_skb);
+
+	ndev->stats.tx_bytes += len;
+	ndev->stats.tx_packets++;
+	dev_consume_skb_any(new_skb);
+
+	return NETDEV_TX_OK;
+}
+
+static int lowrisc_mii_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+        struct net_local *priv = netdev_priv(netdev);
+	struct phy_device *phy = priv->phy_dev;
+        struct mii_ioctl_data *data = if_mii(ifr);
+
+        switch (cmd) {
+        case SIOCGMIIPHY:
+                data->phy_id = 1;
+                break;
+        case SIOCGMIIREG:
+                data->val_out = phy_read(phy, data->reg_num);
+                break;
+        case SIOCSMIIREG:
+                phy_write(phy, data->reg_num, data->val_in);
+                break;
+        default:
+                return -EOPNOTSUPP;
+        }
+        return 0;
+	}
+
+static struct net_device_stats *lowrisc_get_stats(struct net_device *ndev)
+{
+        return &ndev->stats;
+}
+
+static void lowrisc_set_rx_mode(struct net_device *ndev)
+{
+	struct net_local *priv = netdev_priv(ndev);
+        volatile uint64_t *eth_base = (volatile uint64_t *)(priv->ioaddr);
+
+        if (ndev->flags & IFF_PROMISC)
+          {
+            /* Set promiscuous. */
+            eth_base[MACHI_OFFSET >> 3] |= MACHI_ALLPKTS_MASK;
+          }
+        else
+          {
+            eth_base[MACHI_OFFSET >> 3] &= ~MACHI_ALLPKTS_MASK;            
+          }
+}
+static struct net_device_ops lowrisc_netdev_ops = {
+	.ndo_open		= lowrisc_open,
+	.ndo_stop		= lowrisc_close,
+	.ndo_start_xmit		= lowrisc_send,
+        .ndo_get_stats          = lowrisc_get_stats,
+        .ndo_set_rx_mode        = lowrisc_set_rx_mode,
+	.ndo_set_mac_address	= lowrisc_set_mac_address,
+	.ndo_tx_timeout		= lowrisc_tx_timeout,
+	.ndo_do_ioctl           = lowrisc_mii_ioctl,
+};
+
+/**
+ * lowrisc_of_probe - Probe method for the Ether100MHz device.
+ * @ofdev:	Pointer to OF device structure
+ * @match:	Pointer to the structure used for matching a device
+ *
+ * This function probes for the Ether100MHz device in the device tree.
+ * It initializes the driver data structure and the hardware, sets the MAC
+ * address and registers the network device.
+ * It also registers a mii_bus for the Ether100MHz device, if MDIO is included
+ * in the device.
+ *
+ * Return:	0, if the driver is bound to the Ether100MHz device, or
+ *		a negative error if there is failure.
+ */
+static int lowrisc_100MHz_probe(struct platform_device *ofdev)
+{
+	struct net_device *ndev = NULL;
+	struct net_local *priv = NULL;
+	struct device *dev = &ofdev->dev;
+        struct resource *lowrisc_ethernet;
+	unsigned char mac_address[7];
+	int rc = 0;
+
+        lowrisc_ethernet = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+
+	/* Create an ethernet device instance */
+	ndev = alloc_etherdev(sizeof(struct net_local));
+	if (!ndev)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, ndev);
+	SET_NETDEV_DEV(ndev, &ofdev->dev);
+        platform_set_drvdata(ofdev, ndev);
+        
+	priv = netdev_priv(ndev);
+	priv->ndev = ndev;
+        priv->ioaddr = devm_ioremap_resource(&ofdev->dev, lowrisc_ethernet);
+	mutex_init(&priv->lock);
+
+        priv->num_tests = 1;
+        
+	ndev->netdev_ops = &lowrisc_netdev_ops;
+	ndev->flags &= ~IFF_MULTICAST;
+	ndev->watchdog_timeo = TX_TIMEOUT;
+        netif_napi_add(ndev, &priv->napi, lowrisc_ether_poll, 64);
+
+	printk("lowrisc-digilent-ethernet: Lowrisc ethernet platform (%llX-%llX) mapped to %lx\n",
+               lowrisc_ethernet[0].start,
+               lowrisc_ethernet[0].end,
+               (size_t)(priv->ioaddr));
+
+        priv->irq = platform_get_irq(ofdev, 0);
+        
+        /* get the MAC address set by the boot loader */
+        lowrisc_read_mac_address(priv, mac_address);
+	memcpy(ndev->dev_addr, mac_address, ETH_ALEN);
+
+	/* Set the MAC address in the Ether100MHz device */
+	lowrisc_update_address(priv, ndev->dev_addr);
+#ifdef CONFIG_LOWRISC_MII_INIT
+	lowrisc_mii_init(ndev);
+#else
+        /* skip MMI init */
+#endif
+	/* Finally, register the device */
+	rc = register_netdev(ndev);
+	if (rc) {
+          dev_err(dev,
+                  "Cannot register network device, aborting\n");
+          goto error;
+	}
+
+	dev_info(dev, "Lowrisc Ether100MHz registered\n");
+	
+	return 0;
+
+error:
+	lowrisc_remove_ndev(ndev);
+	return rc;
+}
+
+/* Match table for OF platform binding */
+static const struct of_device_id lowrisc_100MHz_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, lowrisc_100MHz_of_match);
+
+void lowrisc_100MHz_free(struct platform_device *of_dev)
+{
+        struct resource *iomem = platform_get_resource(of_dev, IORESOURCE_MEM, 0);
+        release_mem_region(iomem->start, resource_size(iomem));
+}
+
+int lowrisc_100MHz_unregister(struct platform_device *of_dev)
+{
+        lowrisc_100MHz_free(of_dev);
+        return 0;
+}
+
+static struct platform_driver lowrisc_100MHz_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_100MHz_of_match,
+	},
+	.probe = lowrisc_100MHz_probe,
+	.remove = lowrisc_100MHz_unregister,
+};
+
+module_platform_driver(lowrisc_100MHz_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("Lowrisc Ethernet 100MHz driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h b/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h
new file mode 100644
index 000000000..9d227c10d
--- /dev/null
+++ b/drivers/net/ethernet/lowrisc/lowrisc_100MHz.h
@@ -0,0 +1,55 @@
+// See LICENSE for license details.
+
+#ifndef ETH_HEADER_H
+#define ETH_HEADER_H
+
+/* Register offsets for the LowRISC Ethernet Core */
+
+/* Register offsets (in bytes) for the LowRISC Core */
+#define TXBUFF_OFFSET       0x1000          /* Transmit Buffer */
+
+#define MACLO_OFFSET        0x0800          /* MAC address low 32-bits */
+#define MACHI_OFFSET        0x0808          /* MAC address high 16-bits and MAC ctrl */
+#define TPLR_OFFSET         0x0810          /* Tx packet length */
+#define TFCS_OFFSET         0x0818          /* Tx frame check sequence register */
+#define MDIOCTRL_OFFSET     0x0820          /* MDIO Control Register */
+#define RFCS_OFFSET         0x0828          /* Rx frame check sequence register(read) and last register(write) */
+#define RSR_OFFSET          0x0830          /* Rx status and reset register */
+#define RBAD_OFFSET         0x0838          /* Rx bad frame and bad fcs register arrays */
+#define RPLR_OFFSET         0x0840          /* Rx packet length register array */
+
+#define RXBUFF_OFFSET       0x4000          /* Receive Buffer */
+
+/* MAC Ctrl Register (MACHI) Bit Masks */
+#define MACHI_MACADDR_MASK    0x0000FFFF     /* MAC high 16-bits mask */
+#define MACHI_COOKED_MASK     0x00010000     /* obsolete flag */
+#define MACHI_LOOPBACK_MASK   0x00020000     /* Rx loopback packets */
+#define MACHI_ALLPKTS_MASK    0x00400000     /* Rx all packets (promiscuous mode) */
+#define MACHI_IRQ_EN          0x00800000     /* Rx packet interrupt enable */
+
+/* MDIO Control Register Bit Masks */
+#define MDIOCTRL_MDIOCLK_MASK 0x00000001    /* MDIO Clock Mask */
+#define MDIOCTRL_MDIOOUT_MASK 0x00000002    /* MDIO Output Mask */
+#define MDIOCTRL_MDIOOEN_MASK 0x00000004    /* MDIO Output Enable Mask, 3-state enable, high=input, low=output */
+#define MDIOCTRL_MDIORST_MASK 0x00000008    /* MDIO Input Mask */
+#define MDIOCTRL_MDIOIN_MASK  0x00000008    /* MDIO Input Mask */
+
+/* Transmit Status Register (TPLR) Bit Masks */
+#define TPLR_FRAME_ADDR_MASK  0x0FFF0000     /* Tx frame address */
+#define TPLR_PACKET_LEN_MASK  0x00000FFF     /* Tx packet length */
+#define TPLR_BUSY_MASK        0x80000000     /* Tx busy mask */
+
+/* Receive Status Register (RSR) */
+#define RSR_RECV_FIRST_MASK   0x0000000F      /* first available buffer (static) */
+#define RSR_RECV_NEXT_MASK    0x000000F0      /* current rx buffer (volatile) */
+#define RSR_RECV_LAST_MASK    0x00000F00      /* last available rx buffer (static) */
+#define RSR_RECV_DONE_MASK    0x00001000      /* Rx complete */
+#define RSR_RECV_IRQ_MASK     0x00002000      /* Rx irq bit */
+
+/* General Ethernet Definitions */
+#define HEADER_OFFSET               12      /* Offset to length field */
+#define HEADER_SHIFT                16      /* Shift value for length */
+#define ARP_PACKET_SIZE             28      /* Max ARP packet size */
+#define HEADER_IP_LENGTH_OFFSET     16      /* IP Length Offset */
+
+#endif
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index add43c337..f0889b1eb 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1705,6 +1705,12 @@ config RTC_DRV_LOONGSON1
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ls1x.
 
+config RTC_DRV_LOWRISC
+	tristate "LowRISC Real Time Clock"
+	depends on RISCV
+	help
+	  Say yes to enable RTC driver for the LowRISC based FPGA platform.
+
 config RTC_DRV_MXC
 	tristate "Freescale MXC Real Time Clock"
 	depends on ARCH_MXC
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index 6b09c21dc..66d9ca2a6 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -85,6 +85,7 @@ obj-$(CONFIG_RTC_DRV_ISL12026)	+= rtc-isl12026.o
 obj-$(CONFIG_RTC_DRV_ISL1208)	+= rtc-isl1208.o
 obj-$(CONFIG_RTC_DRV_JZ4740)	+= rtc-jz4740.o
 obj-$(CONFIG_RTC_DRV_LOONGSON1)	+= rtc-ls1x.o
+obj-$(CONFIG_RTC_DRV_LOWRISC)	+= rtc-lowrisc.o
 obj-$(CONFIG_RTC_DRV_LP8788)	+= rtc-lp8788.o
 obj-$(CONFIG_RTC_DRV_LPC24XX)	+= rtc-lpc24xx.o
 obj-$(CONFIG_RTC_DRV_LPC32XX)	+= rtc-lpc32xx.o
diff --git a/drivers/rtc/rtc-lowrisc.c b/drivers/rtc/rtc-lowrisc.c
new file mode 100644
index 000000000..39bf5fdeb
--- /dev/null
+++ b/drivers/rtc/rtc-lowrisc.c
@@ -0,0 +1,152 @@
+/*
+ * LowRISC RTC interface driver.
+ *
+ * Based on rtc-au1xxx.c
+ * Copyright (C) 2008 Manuel Lauss <mano@roarinelk.homelinux.net>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/io.h>
+#include <generated/compile.h>
+
+struct lowrisc_rtc_device {
+  struct rtc_device *rtcdev;
+  struct device *dev;
+  resource_size_t physaddr, physaddrend;
+  uint64_t *iobase;
+  long unsigned int buildt;
+  int irq;
+};
+
+static const char * const months[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
+
+static int lowrisc_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct lowrisc_rtc_device *rtc = dev_get_drvdata(dev);
+	uint64_t t = rtc->iobase[7] >> 26;
+        if (t < rtc->buildt)
+          {
+            printk("Fast-forwarding time to kernel build date: "UTS_VERSION);
+            rtc_time_to_tm(rtc->buildt, tm);
+            printk("%s %d %.02d:%.02d:%.02d %d", months[tm->tm_mon], tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec, tm->tm_year+1900);
+          }
+	else
+          rtc_time_to_tm(t, tm);
+
+	return 0;
+}
+
+static int lowrisc_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct lowrisc_rtc_device *rtc = dev_get_drvdata(dev);
+	long unsigned int t;
+	uint64_t traw;
+	rtc_tm_to_time(tm, &t);
+        if (t < rtc->buildt)
+          {
+            printk("lowrisc_rtc_set_time not set earlier than kernel build date: \n" UTS_VERSION);
+            return -1;
+          }
+        else
+          {
+            traw = t << 26;
+            rtc->iobase[7] = traw;
+            return 0;
+          }
+}
+
+static const struct rtc_class_ops lowrisc_rtc_ops = {
+	.read_time	= lowrisc_rtc_read_time,
+	.set_time	= lowrisc_rtc_set_time,
+};
+
+static int lowrisc_rtc_probe(struct platform_device *pdev)
+{
+	resource_size_t physaddr = 0;
+	resource_size_t physaddrend = 0;
+	int ret = -ETIMEDOUT;
+	int i, irq = 0;
+	struct lowrisc_rtc_device *rtc = kzalloc(sizeof(struct lowrisc_rtc_device), GFP_KERNEL);
+        struct rtc_time tm;
+        char mon[8], dow[8], zon[8];
+        
+	printk("lowrisc_rtc_probe(%llx)\n", (u64)pdev);
+
+	for (i = 0; i < pdev->num_resources; i++) {
+		if (pdev->resource[i].flags & IORESOURCE_MEM)
+                  {
+                    physaddr = pdev->resource[i].start;
+                    physaddrend = pdev->resource[i].end;
+                  }
+		if (pdev->resource[i].flags & IORESOURCE_IRQ)
+			irq = pdev->resource[i].start;
+	}
+
+	rtc->dev = &pdev->dev;
+	rtc->physaddr = physaddr;
+	rtc->physaddrend = physaddrend;
+	rtc->iobase = ioremap(rtc->physaddr, rtc->physaddrend - rtc->physaddr);
+	rtc->irq = irq;
+	printk("physaddr=0x%llx, vstart=%llx, vsiz=%llx, irq=%i\n",
+		(unsigned long long)rtc->physaddr,
+		(unsigned long long)rtc->iobase,
+                (unsigned long long)(rtc->physaddrend - rtc->physaddr),
+                rtc->irq);
+	platform_set_drvdata(pdev, rtc);
+	rtc->rtcdev = devm_rtc_device_register(&pdev->dev, "rtc-lowrisc",
+				     &lowrisc_rtc_ops, THIS_MODULE);
+	if (IS_ERR(rtc->rtcdev)) {
+		ret = PTR_ERR(rtc->rtcdev);
+		goto out_err;
+	}	
+
+        sscanf(UTS_VERSION, "#%d %s %s %d %d:%d:%d %s %d", &i, dow, mon, &tm.tm_mday, &tm.tm_hour, &tm.tm_min, &tm.tm_sec, zon, &tm.tm_year);
+        tm.tm_mon = 0;
+        while ((tm.tm_mon < 12) && strcmp(months[tm.tm_mon],mon)) ++tm.tm_mon;
+        printk("%s %d %.02d:%.02d:%.02d %s %d", months[tm.tm_mon], tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, zon, tm.tm_year);
+        tm.tm_year -= 1900;
+        rtc_tm_to_time(&tm, &(rtc->buildt));
+        
+	return 0;
+
+out_err:
+	return ret;
+}
+
+/* Match table for of_platform binding */
+static const struct of_device_id lowrisc_of_match[] = {
+	{ .compatible = "lowrisc-rtc" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, lowrisc_of_match);
+
+static struct platform_driver lowrisc_driver = {
+        .probe          = lowrisc_rtc_probe,
+	.driver		= {
+                           .name = "lowrisc-rtc",
+			   .of_match_table = lowrisc_of_match,
+	},
+};
+
+static int __init pitonsd_init(void)
+{
+  int rc = platform_driver_register(&lowrisc_driver);
+  if (!rc) pr_info("LowRISC-rtc device driver\n");
+  return rc;
+}
+
+module_init(pitonsd_init);
+
+MODULE_DESCRIPTION("LowRISC counter-based RTC driver");
+MODULE_AUTHOR("Jonathan Kimmitt <jrrk2@cam.ac.uk>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rtc-lowrisc");
diff --git a/drivers/video/console/lowrisc-con.c b/drivers/video/console/lowrisc-con.c
new file mode 100644
index 000000000..c3c782f24
--- /dev/null
+++ b/drivers/video/console/lowrisc-con.c
@@ -0,0 +1,303 @@
+/*
+ *  linux/drivers/video/lowrisc_con.c -- A lowrisc console driver
+ *
+ *  Based on dummycon.c (for plain VGA text)
+ *
+ *  This lowrisc device is designed to replicate some of the functions of a PC VGA console
+ *  It does not have graphics, colour is rudimentary and scrolling primitive. Cursor control is TBD.
+ */
+
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/console.h>
+#include <linux/vt_kern.h>
+#include <linux/screen_info.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/of.h>
+#include <asm/sbi.h>
+
+#define DRIVER_NAME     "lowrisc-vga"
+
+/*
+ *  Lowrisc console driver
+ */
+
+#define LOWRISC_MEM	4096
+#define LOWRISC_REGS	8192
+#define LOWRISC_COLUMNS	128
+#define LOWRISC_ROWS	32
+#define LOWRISC_REGS_MODE      (0<<2)
+#define LOWRISC_REGS_CURSV     (1<<2)
+#define LOWRISC_REGS_XCUR      (2<<2)
+#define LOWRISC_REGS_YCUR      (3<<2)
+#define LOWRISC_REGS_HSTART    (4<<2)
+#define LOWRISC_REGS_HSYN      (5<<2)
+#define LOWRISC_REGS_HSTOP     (6<<2)
+#define LOWRISC_REGS_VSTART    (7<<2)
+#define LOWRISC_REGS_VSTOP     (8<<2)
+#define LOWRISC_REGS_VPIXSTART (11<<2)
+#define LOWRISC_REGS_VPIXSTOP  (12<<2)
+#define LOWRISC_REGS_HPIXSTART (13<<2)
+#define LOWRISC_REGS_HPIXSTOP  (14<<2)
+#define LOWRISC_REGS_HPIX      (15<<2)
+#define LOWRISC_REGS_VPIX      (16<<2)
+#define LOWRISC_REGS_HDIV      (17<<2)
+#define LOWRISC_REGS_GHLIMIT   (18<<2)
+#define LOWRISC_REGS_PALETTE   (32<<2)
+
+static uint16_t *hid_vga_ptr;
+static int oldxpos, oldypos;
+
+static void mymove(uint16_t *dest, const uint16_t *src, size_t n)
+{
+  if (dest < hid_vga_ptr || dest+n > hid_vga_ptr+LOWRISC_MEM || src < hid_vga_ptr || src+n > hid_vga_ptr+LOWRISC_MEM)
+    printk("out of range scroll move %lx\n", (long)dest);
+  else
+    memmove(dest, src, n*sizeof(u16));
+}
+
+static void myset(uint16_t *dest, int c, size_t n)
+{
+  if (dest < hid_vga_ptr || dest+n > hid_vga_ptr+LOWRISC_MEM)
+    printk("out of range scroll set %lx\n", (long)dest);
+  else
+    memset(dest, c, n*sizeof(u16));
+}
+
+static const char *lowrisc_con_startup(void)
+{
+    return "lowrisc device";
+}
+
+static void lowrisc_con_init(struct vc_data *vc, int init)
+{
+    vc->vc_can_do_color = 1;
+    if (init) {
+	vc->vc_cols = LOWRISC_COLUMNS;
+	vc->vc_rows = LOWRISC_ROWS;
+    } else
+	vc_resize(vc, LOWRISC_COLUMNS, LOWRISC_ROWS);
+}
+
+static void lowrisc_con_deinit(struct vc_data *vc) { }
+
+static void lowrisc_con_clear(struct vc_data *vc, int sy, int sx, int height, int width)
+{
+  int y;
+  for (y = sy; y < height; y++)
+    {
+      myset(hid_vga_ptr+y*LOWRISC_COLUMNS+sx, 0, width);
+    }
+}
+
+static void lowrisc_con_cursor(struct vc_data *vc, int mode)
+{
+	int xcurs, ycurs;
+
+	switch (mode) {
+	case CM_ERASE:
+                hid_vga_ptr[LOWRISC_REGS+LOWRISC_REGS_YCUR] = 32;
+		break;
+
+	case CM_MOVE:
+	case CM_DRAW:
+                xcurs = vc->vc_pos >> 1;
+		ycurs = xcurs / LOWRISC_COLUMNS;
+		xcurs = xcurs % LOWRISC_COLUMNS;
+                hid_vga_ptr[LOWRISC_REGS+LOWRISC_REGS_XCUR] = xcurs;
+                hid_vga_ptr[LOWRISC_REGS+LOWRISC_REGS_YCUR] = ycurs;
+		break;
+	}
+}
+
+void lowrisc_con_palette(int idx, int palette)
+{
+  if (hid_vga_ptr)
+    hid_vga_ptr[LOWRISC_REGS+LOWRISC_REGS_PALETTE+(idx&15)] = palette;
+}
+
+static void lowrisc_con_putc(struct vc_data *vc, int c, int ypos, int xpos)
+{
+  extern void lowrisc_shadow_console_putchar(int);
+  hid_vga_ptr[LOWRISC_COLUMNS*ypos+xpos] = c;
+#ifdef CONFIG_KEYBOARD_LOWRISC_FAKE
+  if (xpos == oldxpos) lowrisc_shadow_console_putchar('\b');
+  else if (xpos < oldxpos) lowrisc_shadow_console_putchar('\r');
+  else if (xpos > oldxpos+1) lowrisc_shadow_console_putchar(' ');
+  if (ypos > oldypos) lowrisc_shadow_console_putchar('\n');
+  lowrisc_shadow_console_putchar(c);
+  if (xpos == oldxpos)
+    {
+      lowrisc_shadow_console_putchar('\b');
+      oldxpos = xpos-1;
+    }
+  else
+    oldxpos = xpos;
+#else
+  oldxpos = xpos;
+#endif
+  oldypos = ypos;
+}
+
+static void lowrisc_con_putcs(struct vc_data *vc, const unsigned short *s, int count, int ypos, int xpos)
+{
+  while (count--) lowrisc_con_putc(vc, *s++, ypos, xpos++);
+}
+
+static bool lowrisc_con_scroll(struct vc_data *vc, unsigned int top,
+                           unsigned int bottom, enum con_scroll dir,
+                           unsigned int lines)
+{
+  oldypos--;
+#if 0
+  if (lines <= 0)
+    return false;
+
+  if (lines > LOWRISC_ROWS)   /* maximum realistic size */
+    lines = LOWRISC_ROWS;
+
+  switch (dir)
+    {
+
+    case SM_UP:
+      mymove(hid_vga_ptr+top*LOWRISC_COLUMNS, hid_vga_ptr+(top+lines)*LOWRISC_COLUMNS, LOWRISC_MEM-(bottom-top-lines)*LOWRISC_COLUMNS);
+      myset(hid_vga_ptr+(bottom-lines)*LOWRISC_COLUMNS, 0, lines*LOWRISC_COLUMNS);
+      break;
+
+    case SM_DOWN:
+      mymove(hid_vga_ptr+(top+lines)*LOWRISC_COLUMNS, hid_vga_ptr+top*LOWRISC_COLUMNS, LOWRISC_MEM-(bottom-top-lines)*LOWRISC_COLUMNS);
+      myset(hid_vga_ptr+top*LOWRISC_COLUMNS, 0, lines*LOWRISC_COLUMNS);
+      break;
+    }
+
+  return true;
+
+#else
+
+  switch (dir)
+    {
+    case SM_UP:
+      mymove(hid_vga_ptr, hid_vga_ptr+LOWRISC_COLUMNS, LOWRISC_MEM-LOWRISC_COLUMNS);
+      myset(hid_vga_ptr+LOWRISC_MEM-LOWRISC_COLUMNS, 0, LOWRISC_COLUMNS);
+      break;
+
+    case SM_DOWN:
+      mymove(hid_vga_ptr+LOWRISC_COLUMNS, hid_vga_ptr, LOWRISC_MEM-LOWRISC_COLUMNS);
+      myset(hid_vga_ptr, 0, LOWRISC_COLUMNS);
+      break;
+    }
+  
+  return true;
+
+#endif        
+}
+
+static int lowrisc_con_switch(struct vc_data *vc)
+{
+	return 0;
+}
+
+static int lowrisc_con_blank(struct vc_data *vc, int blank, int mode_switch)
+{
+	return 0;
+}
+
+static int lowrisc_con_font_set(struct vc_data *vc, struct console_font *font,
+			     unsigned int flags)
+{
+	return 0;
+}
+
+static int lowrisc_con_font_default(struct vc_data *vc,
+				 struct console_font *font, char *name)
+{
+	return 0;
+}
+
+static int lowrisc_con_font_copy(struct vc_data *vc, int con)
+{
+	return 0;
+}
+
+/*
+ *  The console `switch' structure for the lowrisc console
+ *
+ *  Most of the operations are dummies.
+ */
+
+const struct consw lowrisc_con = {
+	.owner =		THIS_MODULE,
+	.con_startup =	lowrisc_con_startup,
+	.con_init =		lowrisc_con_init,
+	.con_deinit =	lowrisc_con_deinit,
+	.con_clear =	lowrisc_con_clear,
+	.con_putc =		lowrisc_con_putc,
+	.con_putcs =	lowrisc_con_putcs,
+	.con_cursor =	lowrisc_con_cursor,
+        .con_scroll =	lowrisc_con_scroll,
+	.con_switch =	lowrisc_con_switch,
+	.con_blank =	lowrisc_con_blank,
+	.con_font_set =	lowrisc_con_font_set,
+	.con_font_default =	lowrisc_con_font_default,
+	.con_font_copy =	lowrisc_con_font_copy,
+};
+
+static int lowrisc_con_probe(struct platform_device *ofdev)
+{
+        struct resource *lowrisc_vga;
+	int rc = 0;
+
+        lowrisc_vga = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+
+        hid_vga_ptr = devm_ioremap_resource(&ofdev->dev, lowrisc_vga);
+
+	printk(DRIVER_NAME": Lowrisc VGA console (%llX-%llX) mapped to %lx\n",
+               lowrisc_vga[0].start,
+               lowrisc_vga[0].end,
+               (size_t)(hid_vga_ptr));
+
+#ifdef CONFIG_VT_CONSOLE        
+        console_lock();
+        rc = do_take_over_console(&lowrisc_con, 0, MAX_NR_CONSOLES - 1, 1);
+        console_unlock();
+#endif
+	return rc;
+}
+
+/* Match table for OF platform binding */
+static const struct of_device_id lowrisc_con_of_match[] = {
+	{ .compatible = DRIVER_NAME },
+	{ /* end of list */ },
+};
+MODULE_DEVICE_TABLE(of, lowrisc_con_of_match);
+
+void lowrisc_con_free(struct platform_device *of_dev)
+{
+        struct resource *iomem = platform_get_resource(of_dev, IORESOURCE_MEM, 0);
+        release_mem_region(iomem->start, resource_size(iomem));
+}
+
+int lowrisc_con_unregister(struct platform_device *of_dev)
+{
+        lowrisc_con_free(of_dev);
+        return 0;
+}
+
+static struct platform_driver lowrisc_con_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = lowrisc_con_of_match,
+	},
+	.probe = lowrisc_con_probe,
+	.remove = lowrisc_con_unregister,
+};
+
+module_platform_driver(lowrisc_con_driver);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("Lowrisc VGA-compatible console driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 6b2de93bd..23dd687ed 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2256,6 +2256,12 @@ config FB_SIMPLE
 	  Configuration re: surface address, size, and format must be provided
 	  through device tree, or plain old platform data.
 
+config FB_LOWRISC
+	bool "Simple LowRISC framebuffer support"
+	depends on (FB = y)
+	help
+	  Say Y if you want support for a lowrisc frame-buffer.
+
 config FB_SSD1307
 	tristate "Solomon SSD1307 framebuffer support"
 	depends on FB && I2C
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 7dc4861a9..dbad23dfb 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -133,6 +133,7 @@ obj-$(CONFIG_FB_MX3)		  += mx3fb.o
 obj-$(CONFIG_FB_DA8XX)		  += da8xx-fb.o
 obj-$(CONFIG_FB_SSD1307)	  += ssd1307fb.o
 obj-$(CONFIG_FB_SIMPLE)           += simplefb.o
+obj-$(CONFIG_FB_LOWRISC)          += lowrisc_fb.o
 
 # the test framebuffer is last
 obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
diff --git a/drivers/video/fbdev/lowrisc_fb.c b/drivers/video/fbdev/lowrisc_fb.c
new file mode 100644
index 000000000..f0f21592d
--- /dev/null
+++ b/drivers/video/fbdev/lowrisc_fb.c
@@ -0,0 +1,738 @@
+/* lowrisc_fb.c, based on Sun XVR-1000 fb driver for sparc64 systems by David S. Miller (davem@davemloft.net)
+ *
+ * License: GPL
+ *
+ * Copyright (C) 2010 David S. Miller (davem@davemloft.net)
+ * Modications copyright (C) 2019 lowrisc.org
+ */
+
+#include <linux/kernel.h>
+#include <linux/random.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/of_device.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/console.h>
+#include <linux/vt_kern.h>
+#include <linux/screen_info.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/serial_core.h>
+#include <linux/of.h>
+#include <asm/sbi.h>
+
+#define LOWRISC_REGS_MODE      (0)
+#define LOWRISC_REGS_CURSV     (1)
+#define LOWRISC_REGS_XCUR      (2)
+#define LOWRISC_REGS_YCUR      (3)
+#define LOWRISC_REGS_HSTART    (4)
+#define LOWRISC_REGS_HSYN      (5)
+#define LOWRISC_REGS_HSTOP     (6)
+#define LOWRISC_REGS_VSTART    (7)
+#define LOWRISC_REGS_VSTOP     (8)
+#define LOWRISC_REGS_VPIXSTART (11)
+#define LOWRISC_REGS_VPIXSTOP  (12)
+#define LOWRISC_REGS_HPIXSTART (13)
+#define LOWRISC_REGS_HPIXSTOP  (14)
+#define LOWRISC_REGS_HPIX      (15)
+#define LOWRISC_REGS_VPIX      (16)
+#define LOWRISC_REGS_HDIV      (17)
+#define LOWRISC_REGS_GHLIMIT   (18)
+#define LOWRISC_REGS_LIMIT     (19)
+
+#define LOWRISC_MEM	4096
+#define LOWRISC_REGS	8192
+#define LOWRISC_COLUMNS	128
+#define LOWRISC_ROWS	32
+
+enum {ghwords=80, ghlimit=ghwords*8, gvlimit=480, width=1024, height=768, xpixels=1400, ypixels=682, xpixoff = 450};
+
+struct lowrisc_fb_par {
+  int ref_count;
+};
+
+static uint64_t __iomem *hid_reg_base;
+static uint64_t __iomem *plt_reg_base;
+static uint16_t *hid_fb_ptr;
+static uint16_t saved_txt[LOWRISC_COLUMNS*LOWRISC_ROWS];
+
+static void graphic_defaults(void);
+static void font_defaults(void);
+
+static int lowrisc_fb_open(struct fb_info *info, int user)
+{
+        struct lowrisc_fb_par *par = info->par;
+
+        if (!par->ref_count) {
+                printk("lowrisc_fb_open\n");
+                graphic_defaults();
+        }
+        par->ref_count++;
+
+        return 0;
+}
+
+static int lowrisc_fb_release(struct fb_info *info, int user)
+{
+        struct lowrisc_fb_par *par = info->par;
+
+        if (!par->ref_count)
+                return -EINVAL;
+
+        if (par->ref_count == 1)
+          {
+            printk("lowrisc_fb_release\n");
+            font_defaults();
+          }
+        par->ref_count--;
+
+        return 0;
+}
+
+static void lowrisc_fb_destroy(struct fb_info *info)
+{
+        iounmap(info->screen_base);
+        fb_dealloc_cmap(&info->cmap);
+        /* XXX unshare LOWRISC regions */
+        framebuffer_release(info);
+}
+
+static int lowrisc_fb_check_var(struct fb_var_screeninfo *var,
+                             struct fb_info *info)
+{
+  //        struct lowrisc_fb_par *par = info->par;
+        return 0;
+}
+
+static int lowrisc_fb_set_par(struct fb_info *info)
+{
+  //        struct lowrisc_fb_par *par = info->par;
+        return 0;
+}
+
+static int lowrisc_fb_setcmap(struct fb_cmap *cmap, struct fb_info *info)
+{
+  int i, start = cmap->start;
+  if (plt_reg_base && hid_reg_base)
+    {
+      pr_debug("Palette index %d..%d set\n", start, start+cmap->len-1);
+      for (i = 0; i < cmap->len; i++)
+        {
+          int regno = start + i;
+          unsigned red = cmap->red[i];
+          unsigned green = cmap->green[i];
+          unsigned blue = cmap->blue[i];
+          if (regno < 256)
+            {
+              uint64_t colour = ((blue&0xFF00) << 8) | (green&0xFF00) | ((red&0xFF00) >> 8);
+              pr_debug("palette[%d] = %llx\n", regno, colour);
+              plt_reg_base[regno] = colour;
+            }
+          else
+            return -EINVAL;
+        }
+      return 0;
+    }
+  else
+    return -EINVAL;
+}
+
+/**
+ *      lowrisc_fb_fillrect - REQUIRED function. Can use generic routines if 
+ *                       non acclerated hardware and packed pixel based.
+ *                       Draws a rectangle on the screen.               
+ *
+ *      @info: frame buffer structure that represents a single frame buffer
+ *      @region: The structure representing the rectangular region we 
+ *               wish to draw to.
+ *
+ *      This drawing operation places/removes a retangle on the screen 
+ *      depending on the rastering operation with the value of color which
+ *      is in the current color depth format.
+ */
+void lowrisc_fb_fillrect(struct fb_info *p, const struct fb_fillrect *region)
+{
+/*      Meaning of struct fb_fillrect
+ *
+ *      @dx: The x and y corrdinates of the upper left hand corner of the 
+ *      @dy: area we want to draw to. 
+ *      @width: How wide the rectangle is we want to draw.
+ *      @height: How tall the rectangle is we want to draw.
+ *      @color: The color to fill in the rectangle with. 
+ *      @rop: The raster operation. We can draw the rectangle with a COPY
+ *            of XOR which provides erasing effect. 
+ */
+  int y;
+  char *buf = p->screen_base + region->dy * p->fix.line_length + region->dx;
+  for (y = region->dy; y < region->dy+region->height; y++)
+    {
+      memset(buf, region->color, region->width);
+      buf += p->fix.line_length;
+    }
+}
+
+/**
+ *      lowrisc_fb_copyarea - REQUIRED function. Can use generic routines if
+ *                       non acclerated hardware and packed pixel based.
+ *                       Copies one area of the screen to another area.
+ *
+ *      @info: frame buffer structure that represents a single frame buffer
+ *      @area: Structure providing the data to copy the framebuffer contents
+ *             from one region to another.
+ *
+ *      This drawing operation copies a rectangular area from one area of the
+ *      screen to another area.
+ */
+void lowrisc_fb_copyarea(struct fb_info *p, const struct fb_copyarea *area) 
+{
+/*
+ *      @dx: The x and y coordinates of the upper left hand corner of the
+ *      @dy: destination area on the screen.
+ *      @width: How wide the rectangle is we want to copy.
+ *      @height: How tall the rectangle is we want to copy.
+ *      @sx: The x and y coordinates of the upper left hand corner of the
+ *      @sy: source area on the screen.
+ */
+  int y;
+  char *buf = p->screen_base + area->dy * p->fix.line_length + area->dx;
+  char *buf2 = p->screen_base + area->sy * p->fix.line_length + area->sx;
+  for (y = area->dy; y < area->dy+area->height; y++)
+    {
+      memcpy(buf, buf2, area->width);
+      buf += p->fix.line_length;
+      buf2 += p->fix.line_length;
+    }
+}
+
+/**
+ *      lowrisc_fb_imageblit - REQUIRED function. Can use generic routines if
+ *                        non acclerated hardware and packed pixel based.
+ *                        Copies a image from system memory to the screen. 
+ *
+ *      @info: frame buffer structure that represents a single frame buffer
+ *      @image: structure defining the image.
+ *
+ *      This drawing operation draws a image on the screen. It can be a 
+ *      mono image (needed for font handling) or a color image (needed for
+ *      tux). 
+ */
+void lowrisc_fb_imageblit(struct fb_info *p, const struct fb_image *image) 
+{
+/*
+ *      @dx: The x and y coordinates of the upper left hand corner of the
+ *      @dy: destination area to place the image on the screen.
+ *      @width: How wide the image is we want to copy.
+ *      @height: How tall the image is we want to copy.
+ *      @fg_color: For mono bitmap images this is color data for     
+ *      @bg_color: the foreground and background of the image to
+ *                 write directly to the frmaebuffer.
+ *      @depth: How many bits represent a single pixel for this image.
+ *      @data: The actual data used to construct the image on the display.
+ *      @cmap: The colormap used for color images.   
+ */
+  int y;
+  char *buf = p->screen_base + image->dy * p->fix.line_length + image->dx;
+  const char *buf2 = image->data;
+  for (y = image->dy; y < image->dy+image->height; y++)
+    {
+      memcpy(buf, buf2, image->width);
+      buf += p->fix.line_length;
+      buf2 += image->depth * image->width >> 3;
+    }
+}
+
+static struct fb_ops lowrisc_fb_ops = {
+	.owner			= THIS_MODULE,
+        .fb_open                = lowrisc_fb_open,
+        .fb_release             = lowrisc_fb_release,
+        .fb_destroy             = lowrisc_fb_destroy,
+        .fb_check_var           = lowrisc_fb_check_var,
+        .fb_set_par             = lowrisc_fb_set_par,
+	.fb_setcmap		= lowrisc_fb_setcmap,
+	.fb_fillrect		= lowrisc_fb_fillrect,
+	.fb_copyarea		= lowrisc_fb_copyarea,
+	.fb_imageblit		= lowrisc_fb_imageblit,
+};
+
+static const char lowrisc_mini_font[]={
+#include "lowrisc_mini_font.h"
+};
+
+static void font_defaults(void)
+{
+  int i;
+  /* set a simple 6x8 default font for /dev/tty1 */
+  for (i = ' '; i <= '~'; i++)
+    {
+      int j;
+      uint64_t tmp[2];
+      const char *zptr = lowrisc_mini_font + (i - ' ') * 8;
+      memset(tmp, 0, sizeof(tmp));
+      for (j = 0; j < 8; j++)
+        {
+          tmp[j/4] |= ((0xFC & *zptr++) >> 1) << (j&3)*8;
+        }
+      for (j = 0; j < 2; j++)
+        plt_reg_base[2*i+j] = tmp[j];
+    }
+}
+
+static void mode_defaults(void)
+{
+  /* set text mode defaults */
+  hid_reg_base[LOWRISC_REGS_CURSV] = 10;
+  hid_reg_base[LOWRISC_REGS_XCUR] = 0;
+  hid_reg_base[LOWRISC_REGS_YCUR] = 32;
+  hid_reg_base[LOWRISC_REGS_HSTART] = width*2;
+  hid_reg_base[LOWRISC_REGS_HSYN] = width*2+20;
+  hid_reg_base[LOWRISC_REGS_HSTOP] = width*2+51;
+  hid_reg_base[LOWRISC_REGS_VSTART] = height;
+  hid_reg_base[LOWRISC_REGS_VSTOP] = height+19;
+  hid_reg_base[LOWRISC_REGS_VPIXSTART ] = 16;
+  hid_reg_base[LOWRISC_REGS_VPIXSTOP ] = ypixels+16;
+  hid_reg_base[LOWRISC_REGS_HPIXSTART ] = xpixoff;
+  hid_reg_base[LOWRISC_REGS_HPIXSTOP ] = xpixels + xpixoff;
+  hid_reg_base[LOWRISC_REGS_HPIX ] = 6;
+  hid_reg_base[LOWRISC_REGS_VPIX ] = 9;
+  hid_reg_base[LOWRISC_REGS_HDIV ] = 1;
+  hid_reg_base[LOWRISC_REGS_GHLIMIT] = ghwords;
+}
+
+#ifdef LOWRISC_PALETTE
+const uint32_t lowrisc_palette[] = {
+#include "lowrisc_palette.h"
+};
+#endif
+
+static void graphic_defaults(void)
+{
+#ifdef LOWRISC_PALETTE
+  int i;
+  for (i = 0; i < sizeof(lowrisc_palette)/sizeof(lowrisc_palette); i++)
+    {
+      plt_reg_base[i] = lowrisc_palette[i];
+    }
+#endif
+  printk("switched to graphics mode\n");
+  hid_reg_base[LOWRISC_REGS_MODE] = 0x75;
+}
+
+const uint8_t logo[] = {
+#include "lowrisc_logo.h"
+};
+
+static void graphic_logo(void)
+{
+  const uint32_t image_width = 512;
+  const uint32_t image_height = 413;
+  const uint32_t palette_logo2[] = {
+  0x20272D,
+  0xE0354F,
+  0xE9374F,
+  0xE0354F,
+  0xE9374F,
+  0xE1E6E8,
+  };
+  size_t i = LOWRISC_COLUMNS*LOWRISC_ROWS*sizeof(uint16_t)/ghlimit + 1;
+  size_t j = 0;
+  size_t __ip = 0;
+  size_t __il = image_width*image_height;
+  const unsigned char *image_ptr = logo;
+  unsigned char *fb_ptr = (unsigned char *)hid_fb_ptr;
+  while (__ip < __il)
+    {
+      unsigned int __l = *(image_ptr++);
+      unsigned int cnt = __l & 127;
+      do {
+          fb_ptr[i*ghlimit + j] = *image_ptr;
+          if (++j >= image_width)
+            {
+	      if (j < ghlimit)
+		memset(fb_ptr+i*ghlimit + j, 0, ghlimit - j);
+              j = 0;
+              ++i;
+            }
+          __ip++;
+          if (~__l & 128)
+            image_ptr++;
+        }
+        while (--cnt);
+        if (__l & 128)
+          image_ptr++;
+    }
+  memset(fb_ptr+i*ghlimit, 0, ghlimit*(512-i));
+  for (i = 0; i < sizeof(palette_logo2)/sizeof(*palette_logo2); i++)
+    {
+      plt_reg_base[i] = ((palette_logo2[i] & 0xFF) << 16) | ((palette_logo2[i] & 0xFF00)) | ((palette_logo2[i] & 0xFF0000) >> 16);
+    }
+}
+
+#ifdef DUMMY_GRAPHIC
+static void dummy_graphic(void)
+{
+  size_t i;
+  unsigned char *fb_ptr = (unsigned char *)hid_fb_ptr;  
+  for (i = 0; i < 16384; i++)
+    {
+      fb_ptr[i] = get_random_u32();
+    }
+  
+  for (i = 0; i < 255; i++)
+    memset(fb_ptr+i*ghlimit, i, ghlimit);
+  
+  for (i = 0; i < gvlimit; i++)
+    {
+      fb_ptr[i*ghlimit + i] = 3;
+    }
+  
+  for (i = 0; i < gvlimit; i++)
+    {
+      int j;
+      for (j = 0; j < ghlimit; j += 100)
+        {
+          fb_ptr[i*ghlimit + j] = 1;
+        }
+      fb_ptr[(i+1)*ghlimit - 1] = 1;
+    }
+}
+#endif
+
+static int lowrisc_fb_set_fbinfo(struct fb_info *info, struct resource *lowrisc_fb, char __iomem *fb_base)
+{
+	struct fb_var_screeninfo *var = &info->var;
+
+        const char *txt = "LowRISC is booting - screen intentionally blank";
+        static uint16_t *savedp = saved_txt;
+        
+        while (*txt) *savedp++ = 0xE00 | *txt++;
+
+        mode_defaults();
+        graphic_defaults();
+        graphic_logo();
+        
+	info->flags = FBINFO_DEFAULT;
+	info->fbops = &lowrisc_fb_ops;
+
+	/* Fill fix common fields */
+	strlcpy(info->fix.id, "lowrisc_fb", sizeof(info->fix.id));
+        info->fix.smem_start = lowrisc_fb[0].start + 0x48000;
+        info->fix.smem_len = info->screen_size;
+        info->fix.type = FB_TYPE_PACKED_PIXELS;
+	info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	info->fix.line_length = 640;
+        info->fix.mmio_start = lowrisc_fb[0].start;
+	var->xres = info->fix.line_length;
+	var->yres = 512;
+	var->xres_virtual = var->xres;
+	var->yres_virtual = var->yres;
+	var->bits_per_pixel = 8;
+        var->grayscale = 0;
+
+	var->red.offset = 0;
+	var->red.length = var->bits_per_pixel;
+	var->green.offset = 0;
+	var->green.length = var->bits_per_pixel;
+	var->blue.offset = 0;
+	var->blue.length = var->bits_per_pixel;
+	var->transp.offset = 0;
+	var->transp.length = 0;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0)) {
+		printk(KERN_ERR "lowrisc_fb: Cannot allocate color map.\n");
+		return -ENOMEM;
+	}
+
+        return 0;
+}
+
+static void mymove(uint16_t *dest, const uint16_t *src, size_t n)
+{
+  if (dest < hid_fb_ptr || dest+n > hid_fb_ptr+LOWRISC_MEM || src < hid_fb_ptr || src+n > hid_fb_ptr+LOWRISC_MEM)
+    printk("out of range scroll move %lx\n", (long)dest);
+  else
+    memmove(dest, src, n*sizeof(u16));
+}
+
+static void myset(uint16_t *dest, int c, size_t n)
+{
+  if (dest < hid_fb_ptr || dest+n > hid_fb_ptr+LOWRISC_MEM)
+    printk("out of range scroll set %lx\n", (long)dest);
+  else
+    memset(dest, c, n*sizeof(u16));
+}
+
+static const char *lowrisc_fbcon_startup(void)
+{
+    return "lowrisc device";
+}
+
+static void lowrisc_fbcon_init(struct vc_data *vc, int init)
+{
+    vc->vc_can_do_color = 1;
+    if (init) {
+	vc->vc_cols = LOWRISC_COLUMNS;
+	vc->vc_rows = LOWRISC_ROWS;
+    } else
+	vc_resize(vc, LOWRISC_COLUMNS, LOWRISC_ROWS);
+    
+}
+
+static void lowrisc_fbcon_deinit(struct vc_data *vc) { }
+
+static void lowrisc_fbcon_clear(struct vc_data *vc, int sy, int sx, int height, int width)
+{
+  int y;
+  for (y = sy; y < height; y++)
+    {
+      myset(hid_fb_ptr+y*LOWRISC_COLUMNS+sx, 0, width);
+    }
+}
+
+static void lowrisc_fbcon_cursor(struct vc_data *vc, int mode)
+{
+	int xcurs, ycurs;
+
+	switch (mode) {
+	case CM_ERASE:
+                hid_fb_ptr[LOWRISC_REGS+LOWRISC_REGS_YCUR] = 32;
+		break;
+
+	case CM_MOVE:
+	case CM_DRAW:
+                xcurs = vc->vc_pos >> 1;
+		ycurs = xcurs / LOWRISC_COLUMNS;
+		xcurs = xcurs % LOWRISC_COLUMNS;
+                hid_fb_ptr[LOWRISC_REGS+LOWRISC_REGS_XCUR] = xcurs;
+                hid_fb_ptr[LOWRISC_REGS+LOWRISC_REGS_YCUR] = ycurs;
+		break;
+	}
+}
+
+static void lowrisc_fbcon_putc(struct vc_data *vc, int c, int ypos, int xpos)
+{
+  if (vc->vc_mode == KD_TEXT)
+    {
+      hid_reg_base[LOWRISC_REGS_MODE] = 0;  
+      hid_fb_ptr[LOWRISC_COLUMNS*ypos+xpos] = c;
+    }
+  else
+    {
+      saved_txt[LOWRISC_COLUMNS*ypos+xpos] = c;      
+    }
+}
+
+static void lowrisc_fbcon_putcs(struct vc_data *vc, const unsigned short *s, int count, int ypos, int xpos)
+{
+  while (count--) lowrisc_fbcon_putc(vc, *s++, ypos, xpos++);
+}
+
+static bool lowrisc_fbcon_scroll(struct vc_data *vc, unsigned int top,
+                           unsigned int bottom, enum con_scroll dir,
+                           unsigned int lines)
+{
+#if 0
+  if (lines <= 0)
+    return false;
+
+  if (lines > LOWRISC_ROWS)   /* maximum realistic size */
+    lines = LOWRISC_ROWS;
+
+  switch (dir)
+    {
+
+    case SM_UP:
+      mymove(hid_fb_ptr+top*LOWRISC_COLUMNS, hid_fb_ptr+(top+lines)*LOWRISC_COLUMNS, LOWRISC_MEM-(bottom-top-lines)*LOWRISC_COLUMNS);
+      myset(hid_fb_ptr+(bottom-lines)*LOWRISC_COLUMNS, 0, lines*LOWRISC_COLUMNS);
+      break;
+
+    case SM_DOWN:
+      mymove(hid_fb_ptr+(top+lines)*LOWRISC_COLUMNS, hid_fb_ptr+top*LOWRISC_COLUMNS, LOWRISC_MEM-(bottom-top-lines)*LOWRISC_COLUMNS);
+      myset(hid_fb_ptr+top*LOWRISC_COLUMNS, 0, lines*LOWRISC_COLUMNS);
+      break;
+    }
+
+  return true;
+
+#else
+
+  switch (dir)
+    {
+    case SM_UP:
+      mymove(hid_fb_ptr, hid_fb_ptr+LOWRISC_COLUMNS, LOWRISC_MEM-LOWRISC_COLUMNS);
+      myset(hid_fb_ptr+LOWRISC_MEM-LOWRISC_COLUMNS, 0, LOWRISC_COLUMNS);
+      break;
+
+    case SM_DOWN:
+      mymove(hid_fb_ptr+LOWRISC_COLUMNS, hid_fb_ptr, LOWRISC_MEM-LOWRISC_COLUMNS);
+      myset(hid_fb_ptr, 0, LOWRISC_COLUMNS);
+      break;
+    }
+  
+  return true;
+
+#endif        
+}
+
+static int lowrisc_fbcon_switch(struct vc_data *vc)
+{
+  printk("lowrisc_fbcon_switch %d called\n", vc->vc_num);
+  switch(vc->vc_mode)
+    {
+    case KD_TEXT: /* text console /dev/tty1 */
+      memcpy(hid_fb_ptr, saved_txt, sizeof(saved_txt));
+      font_defaults();
+      break;
+    case KD_GRAPHICS: /* X-windows graphical display /dev/fb0 */
+      memcpy(saved_txt, hid_fb_ptr, sizeof(saved_txt));
+      graphic_defaults();
+      break;
+    default:
+      break;
+    }
+  
+  return 0;
+}
+
+static int lowrisc_fbcon_blank(struct vc_data *vc, int blank, int mode_switch)
+{
+	return 0;
+}
+
+static int lowrisc_fbcon_font_set(struct vc_data *vc, struct console_font *font,
+			     unsigned int flags)
+{
+	return 0;
+}
+
+static int lowrisc_fbcon_font_default(struct vc_data *vc,
+				 struct console_font *font, char *name)
+{
+	return 0;
+}
+
+static int lowrisc_fbcon_font_copy(struct vc_data *vc, int con)
+{
+	return 0;
+}
+
+/*
+ *  The console `switch' structure for the lowrisc console
+ *
+ *  Most of the operations are dummies.
+ */
+
+const struct consw lowrisc_con = {
+	.owner =		THIS_MODULE,
+	.con_startup =          lowrisc_fbcon_startup,
+	.con_init =		lowrisc_fbcon_init,
+	.con_deinit =	        lowrisc_fbcon_deinit,
+	.con_clear =	        lowrisc_fbcon_clear,
+	.con_putc =		lowrisc_fbcon_putc,
+	.con_putcs =	        lowrisc_fbcon_putcs,
+	.con_cursor =	        lowrisc_fbcon_cursor,
+        .con_scroll =	        lowrisc_fbcon_scroll,
+	.con_switch =	        lowrisc_fbcon_switch,
+	.con_blank =	        lowrisc_fbcon_blank,
+	.con_font_set =	        lowrisc_fbcon_font_set,
+	.con_font_default =	lowrisc_fbcon_font_default,
+	.con_font_copy =	lowrisc_fbcon_font_copy,
+};
+
+static int lowrisc_fb_probe(struct platform_device *ofdev)
+{
+	struct device_node *dp = ofdev->dev.of_node;
+	struct fb_info *info;
+        struct resource *lowrisc_fb;
+        
+	char __iomem *fb_base;
+	int err = 0;
+
+        printk("lowrisc_fb_probe");
+        
+	info = framebuffer_alloc(0, &ofdev->dev);
+	if (!info) {
+		printk(KERN_ERR "lowrisc_fb: Cannot allocate fb_info\n");
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+        lowrisc_fb = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+        
+	fb_base = devm_ioremap_resource(&ofdev->dev, lowrisc_fb);
+
+	if (!fb_base) {
+		err = -ENOMEM;
+		goto err_release_fb;
+	}
+
+        info->fbcon_par = NULL;
+        info->par = kzalloc(sizeof(struct lowrisc_fb_par), GFP_KERNEL);
+        
+        hid_reg_base = (uint64_t __iomem *)(fb_base + 0x4000);
+        plt_reg_base = (uint64_t __iomem *)(fb_base + 0x6000);
+        info->screen_base = fb_base + 0x48000;
+        info->screen_size = 0x80000;
+        hid_fb_ptr = (uint16_t *)(info->screen_base);
+        
+	err = lowrisc_fb_set_fbinfo(info, lowrisc_fb, fb_base);
+	if (err)
+		goto err_unmap_fb;
+
+	printk("lowrisc_fb: Found device at %pOF, mapped to %lX (size=%lX)\n", dp, (size_t)(fb_base), info->screen_size);
+
+	err = register_framebuffer(info);
+	if (err < 0) {
+		printk(KERN_ERR "lowrisc_fb: Could not register framebuffer %pOF\n",
+		       dp);
+		goto err_unmap_fb;
+	}
+
+	dev_set_drvdata(&ofdev->dev, info);
+
+        console_lock();
+        err = do_take_over_console(&lowrisc_con, 0, MAX_NR_CONSOLES - 1, 1);
+        console_unlock();
+
+	return err;
+
+err_unmap_fb:
+        iounmap(fb_base);
+        
+err_release_fb:
+        framebuffer_release(info);
+
+err_out:
+	return err;
+}
+
+static const struct of_device_id lowrisc_fb_match[] = {
+	{
+		.name = "lowrisc-fb",
+	},
+	{},
+};
+
+static struct platform_driver lowrisc_fb_driver = {
+	.probe		= lowrisc_fb_probe,
+	.driver = {
+		.name			= "lowrisc-fb",
+		.of_match_table		= lowrisc_fb_match,
+		.suppress_bind_attrs	= true,
+	},
+};
+
+static int __init lowrisc_fb_init(void)
+{
+  printk("lowrisc_fb_init");
+  
+	return platform_driver_register(&lowrisc_fb_driver);
+}
+
+device_initcall(lowrisc_fb_init);
+
+MODULE_AUTHOR("Jonathan Kimmitt");
+MODULE_DESCRIPTION("Lowrisc FB-console driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/lowrisc_logo.h b/drivers/video/fbdev/lowrisc_logo.h
new file mode 100644
index 000000000..a99a1bf2f
--- /dev/null
+++ b/drivers/video/fbdev/lowrisc_logo.h
@@ -0,0 +1,660 @@
+0xFF, 0x00, 0xFA, 0x00, 0x8D, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xE9, 0x00, 0xA6, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xD6, 0x00, 0x83, 0x01, 0x82, 0x02, 0xAB, 0x01, 0x82, 0x02,
+0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xCC, 0x00, 0x83, 0x01, 0x82, 0x02, 0xB1, 0x01,
+0x82, 0x02, 0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xC4, 0x00, 0x83, 0x01, 0x01, 0x02,
+0xBC, 0x01, 0x01, 0x02, 0x84, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xBA, 0x00, 0x02, 0x01,
+0x02, 0xC8, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xB5, 0x00, 0x01, 0x01,
+0x82, 0x02, 0xCB, 0x01, 0x01, 0x02, 0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xAE, 0x00,
+0x82, 0x01, 0x01, 0x02, 0xD2, 0x01, 0x01, 0x02, 0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xAA, 0x00, 0x82, 0x01, 0x01, 0x02, 0xD5, 0x01, 0x01, 0x02, 0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xA5, 0x00, 0xE1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x9F, 0x00, 0xE5, 0x01,
+0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x9A, 0x00, 0x02, 0x01, 0x02, 0xE6, 0x01,
+0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x96, 0x00, 0x82, 0x01, 0x01, 0x02, 0xEB,
+0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x91, 0x00, 0xF3, 0x01, 0x01, 0x02,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x8E, 0x00, 0x01, 0x02, 0xF4, 0x01, 0x02, 0x02, 0x03, 0xFF,
+0x00, 0xFF, 0x00, 0xFF, 0x00, 0x89, 0x00, 0x02, 0x01, 0x02, 0xF8, 0x01, 0x02, 0x02, 0x03, 0xFF,
+0x00, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x02, 0x01, 0x02, 0xFE, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0x82, 0x00, 0xFF, 0x01, 0x84, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFD, 0x00, 0x02, 0x01,
+0x02, 0xFF, 0x01, 0x84, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xFB, 0x00, 0xFF, 0x01, 0x8A,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xF7, 0x00, 0x02, 0x01, 0x02, 0xFF, 0x01, 0x8B, 0x01, 0xFF, 0x00,
+0xFF, 0x00, 0xF4, 0x00, 0xE6, 0x01, 0x82, 0x02, 0x8A, 0x01, 0x82, 0x02, 0x9C, 0x01, 0xFF, 0x00,
+0xFF, 0x00, 0xF1, 0x00, 0xE5, 0x01, 0x82, 0x02, 0x82, 0x01, 0x8A, 0x00, 0x82, 0x01, 0x01, 0x02,
+0x9B, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xED, 0x00, 0x02, 0x01, 0x02, 0xE3, 0x01,
+0x02, 0x02, 0x03, 0x92, 0x00, 0x02, 0x01, 0x02, 0x9B, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xEB, 0x00,
+0x01, 0x02, 0xE4, 0x01, 0x98, 0x00, 0x9C, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE7, 0x00, 0xE4, 0x01,
+0x02, 0x02, 0x03, 0x9A, 0x00, 0x02, 0x01, 0x02, 0x9A, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE5, 0x00,
+0xE4, 0x01, 0x01, 0x02, 0x9E, 0x00, 0x01, 0x02, 0x9B, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE1, 0x00,
+0x02, 0x01, 0x02, 0xE4, 0x01, 0xA0, 0x00, 0x9C, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE0, 0x00, 0x01,
+0x02, 0xE4, 0x01, 0xA2, 0x00, 0x9A, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xDD, 0x00,
+0xE4, 0x01, 0x02, 0x02, 0x03, 0xA4, 0x00, 0x9B, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xDB,
+0x00, 0xE6, 0x01, 0xA6, 0x00, 0x9C, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xD9, 0x00, 0xE6, 0x01, 0xA7,
+0x00, 0x02, 0x01, 0x02, 0x9C, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xD5, 0x00, 0xE6, 0x01, 0x01, 0x02,
+0xAA, 0x00, 0x01, 0x02, 0x9C, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xD4, 0x00, 0x01, 0x02, 0xE6, 0x01,
+0xAA, 0x00, 0x01, 0x02, 0x9D, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xD1, 0x00, 0x02, 0x01, 0x02, 0xE6,
+0x01, 0xAC, 0x00, 0x9E, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xCF, 0x00, 0xE7, 0x01, 0x01, 0x02, 0xAE,
+0x00, 0x9F, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xCD, 0x00, 0x01, 0x02, 0xE7, 0x01, 0xAE, 0x00, 0x9F,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xCB, 0x00, 0x02, 0x01, 0x02, 0xE8, 0x01, 0xAE, 0x00, 0xA0, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0xC9, 0x00, 0xEA, 0x01, 0xB0, 0x00, 0x9F, 0x01, 0x02, 0x02, 0x03, 0xFF,
+0x00, 0xFF, 0x00, 0xC7, 0x00, 0x01, 0x02, 0xE9, 0x01, 0xB0, 0x00, 0xA0, 0x01, 0x01, 0x02, 0xFF,
+0x00, 0xFF, 0x00, 0xC5, 0x00, 0x02, 0x01, 0x02, 0xEA, 0x01, 0xB0, 0x00, 0x01, 0x02, 0xA1, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0xC3, 0x00, 0xEB, 0x01, 0x01, 0x02, 0xB1, 0x00, 0x02, 0x01, 0x02, 0xA2,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xC0, 0x00, 0x02, 0x01, 0x02, 0xEB, 0x01, 0xB1, 0x00, 0x02, 0x01,
+0x02, 0xA2, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xBF, 0x00, 0xEE, 0x01, 0xB2, 0x00, 0xA4, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0xBE, 0x00, 0x01, 0x02, 0xED, 0x01, 0xB2, 0x00, 0xA3, 0x01, 0x02, 0x02, 0x03,
+0xFF, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0x02, 0x01, 0x02, 0xED, 0x01, 0xB3, 0x00, 0xA6, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0xBA, 0x00, 0xEF, 0x01, 0xB3, 0x00, 0xA7, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xB8,
+0x00, 0xF0, 0x01, 0xB3, 0x00, 0xA6, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xB6, 0x00,
+0xF1, 0x01, 0xB3, 0x00, 0xA8, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xB5, 0x00, 0xF3, 0x01, 0xB2, 0x00,
+0xA8, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xB4, 0x00, 0x01, 0x02, 0xF2, 0x01, 0xB2, 0x00,
+0xAA, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xB2, 0x00, 0x01, 0x02, 0xF3, 0x01, 0xB2, 0x00, 0x01, 0x02,
+0xA8, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xB0, 0x00, 0xF4, 0x01, 0x01, 0x02, 0xB1,
+0x00, 0x02, 0x01, 0x02, 0xAB, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xAE, 0x00, 0xF7, 0x01, 0xB0, 0x00,
+0xAC, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xAD, 0x00, 0xF7, 0x01, 0x01, 0x02, 0xB0, 0x00,
+0xAE, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xAC, 0x00, 0xF8, 0x01, 0xB0, 0x00, 0xAD, 0x01, 0x02, 0x02,
+0x03, 0xFF, 0x00, 0xFF, 0x00, 0xAA, 0x00, 0xF9, 0x01, 0xAF, 0x00, 0xAF, 0x01, 0x01, 0x02, 0xFF,
+0x00, 0xFF, 0x00, 0xA9, 0x00, 0xFB, 0x01, 0xAE, 0x00, 0xB1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA8,
+0x00, 0x01, 0x02, 0xF9, 0x01, 0x01, 0x02, 0xAE, 0x00, 0xB0, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF,
+0x00, 0xA7, 0x00, 0xFD, 0x01, 0xAC, 0x00, 0xB2, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00,
+0xA4, 0x00, 0xC5, 0x01, 0x01, 0x02, 0x82, 0x01, 0x8B, 0x00, 0x83, 0x01, 0x01, 0x02, 0xA6, 0x01,
+0x02, 0x02, 0x03, 0xAA, 0x00, 0x01, 0x02, 0xB4, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA4, 0x00, 0x01,
+0x02, 0xC5, 0x01, 0x90, 0x00, 0x82, 0x01, 0x01, 0x02, 0xA5, 0x01, 0x01, 0x02, 0xAA, 0x00, 0xB6,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA2, 0x00, 0x01, 0x02, 0xC1, 0x01, 0x02, 0x02, 0x03, 0x96, 0x00,
+0x02, 0x01, 0x02, 0xA5, 0x01, 0xA7, 0x00, 0x02, 0x01, 0x02, 0xB7, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0xA0, 0x00, 0xC3, 0x01, 0x9A, 0x00, 0xA6, 0x01, 0xA6, 0x00, 0xB8, 0x01, 0x01, 0x02, 0xFF, 0x00,
+0xFF, 0x00, 0xA0, 0x00, 0xC2, 0x01, 0x9C, 0x00, 0xA4, 0x01, 0x02, 0x02, 0x03, 0xA4, 0x00, 0xBB,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9E, 0x00, 0xC1, 0x01, 0xA0, 0x00, 0x02, 0x01, 0x02, 0xA3, 0x01,
+0xA2, 0x00, 0xBB, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x9D, 0x00, 0xC1, 0x01, 0xA3, 0x00,
+0xA3, 0x01, 0x01, 0x02, 0x9F, 0x00, 0x02, 0x01, 0x02, 0xBD, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9C,
+0x00, 0xBF, 0x01, 0x01, 0x02, 0xA4, 0x00, 0xA5, 0x01, 0x9E, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x02,
+0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0x9B, 0x00, 0xBF, 0x01, 0xA6, 0x00, 0xA6, 0x01, 0x9A, 0x00,
+0xC2, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9A, 0x00, 0xBE, 0x01, 0x01, 0x02, 0xA7, 0x00, 0x02, 0x01,
+0x02, 0xA5, 0x01, 0x98, 0x00, 0xC3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x99, 0x00, 0x02, 0x01, 0x02,
+0xBE, 0x01, 0xA9, 0x00, 0x01, 0x02, 0xA4, 0x01, 0x02, 0x02, 0x03, 0x93, 0x00, 0x01, 0x01, 0x82,
+0x02, 0xC4, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x98, 0x00, 0xBF, 0x01, 0xAA, 0x00, 0xA8, 0x01, 0x01,
+0x02, 0x82, 0x01, 0x8B, 0x00, 0xCA, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x98, 0x00, 0xBD,
+0x01, 0x02, 0x02, 0x03, 0xAB, 0x00, 0xAC, 0x01, 0x88, 0x00, 0xCD, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0x96, 0x00, 0xBE, 0x01, 0xAD, 0x00, 0xAC, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCB, 0x01, 0x02, 0x02,
+0x03, 0xFF, 0x00, 0xFF, 0x00, 0x94, 0x00, 0xBE, 0x01, 0x01, 0x02, 0xAE, 0x00, 0xAB, 0x01, 0x88,
+0x00, 0x01, 0x02, 0xCD, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x94, 0x00, 0xBD, 0x01, 0x02, 0x02, 0x03,
+0xAE, 0x00, 0xAB, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCD, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x93, 0x00,
+0x02, 0x01, 0x02, 0xBD, 0x01, 0xB0, 0x00, 0x01, 0x02, 0xA9, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCE,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0x92, 0x00, 0x01, 0x02, 0xBE, 0x01, 0xB0, 0x00, 0x01, 0x02, 0xA9,
+0x01, 0x88, 0x00, 0x01, 0x02, 0xCE, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x92, 0x00, 0xBE, 0x01, 0xB1,
+0x00, 0xAA, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCF, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x90, 0x00, 0xBF,
+0x01, 0xB1, 0x00, 0xAA, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCE, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00,
+0xFF, 0x00, 0x8E, 0x00, 0x9D, 0x01, 0xA3, 0x02, 0xB2, 0x00, 0xA9, 0x01, 0x88, 0x00, 0x01, 0x02,
+0xCE, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0x8E, 0x00, 0x98, 0x01, 0x01, 0x02, 0x82,
+0x01, 0xD7, 0x00, 0x01, 0x02, 0xA8, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCF, 0x01, 0x01, 0x02, 0xFF,
+0x00, 0xFF, 0x00, 0x8E, 0x00, 0x98, 0x01, 0xDA, 0x00, 0x01, 0x02, 0xA8, 0x01, 0x88, 0x00, 0x01,
+0x02, 0xD1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8C, 0x00, 0x96, 0x01, 0x01, 0x02, 0xDC, 0x00, 0x01,
+0x02, 0xA8, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8C, 0x00, 0x95,
+0x01, 0x01, 0x02, 0xDD, 0x00, 0xA9, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD2, 0x01, 0xFF, 0x00, 0xFF,
+0x00, 0x8B, 0x00, 0x95, 0x01, 0xDE, 0x00, 0xA9, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD2, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x8A, 0x00, 0x94, 0x01, 0x01, 0x02, 0xDF, 0x00, 0xA9, 0x01, 0x88, 0x00, 0x01,
+0x02, 0xD2, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8A, 0x00, 0x01, 0x02, 0x92, 0x01, 0x01, 0x02, 0xE0,
+0x00, 0x01, 0x02, 0xA8, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x88,
+0x00, 0x94, 0x01, 0xE1, 0x00, 0x01, 0x02, 0xA8, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD3, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x88, 0x00, 0x01, 0x02, 0x91, 0x01, 0x01, 0x02, 0xE2, 0x00, 0xA9, 0x01, 0x88,
+0x00, 0x01, 0x02, 0xD2, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x88, 0x00, 0x91, 0x01, 0x01,
+0x02, 0x8C, 0x00, 0x01, 0x01, 0x82, 0x02, 0xA2, 0x01, 0xB1, 0x00, 0xAA, 0x01, 0x88, 0x00, 0x01,
+0x02, 0xD3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x88, 0x00, 0x90, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00,
+0x02, 0x01, 0x02, 0xA4, 0x01, 0xB1, 0x00, 0xAA, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD4, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x86, 0x00, 0x90, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xA6, 0x01, 0xB1,
+0x00, 0xAA, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD3, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x86,
+0x00, 0x90, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xA8, 0x01, 0xB0, 0x00, 0x01, 0x02, 0xA9, 0x01, 0x88,
+0x00, 0x01, 0x02, 0xD5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x01, 0x02, 0x8D, 0x01, 0x01,
+0x02, 0x8C, 0x00, 0xAA, 0x01, 0xB0, 0x00, 0xAA, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD4, 0x01, 0x01,
+0x02, 0xFF, 0x00, 0xFF, 0x00, 0x84, 0x00, 0x8E, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xAB,
+0x01, 0xAE, 0x00, 0xAB, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x84,
+0x00, 0x8E, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xAC, 0x01, 0xAD, 0x00, 0xAC, 0x01, 0x88, 0x00, 0x01,
+0x02, 0xD5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x84, 0x00, 0x8C, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xAF,
+0x01, 0xAC, 0x00, 0x01, 0x02, 0xAB, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD6, 0x01, 0xFF, 0x00, 0xFF,
+0x00, 0x82, 0x00, 0x02, 0x01, 0x02, 0x8A, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xAE, 0x01,
+0x02, 0x02, 0x03, 0xAA, 0x00, 0xAD, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD4, 0x01, 0x01, 0x02, 0xFF,
+0x00, 0xFF, 0x00, 0x83, 0x00, 0x01, 0x02, 0x8B, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xB1, 0x01, 0xAA,
+0x00, 0x01, 0x02, 0xAC, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD4, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x84,
+0x00, 0x01, 0x02, 0x89, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xB4, 0x01, 0xA8, 0x00, 0xAE, 0x01, 0x88,
+0x00, 0x01, 0x02, 0xD2, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x89, 0x01, 0x01,
+0x02, 0x8C, 0x00, 0x01, 0x02, 0xB4, 0x01, 0xA7, 0x00, 0xAF, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD1,
+0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x8A, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xB5,
+0x01, 0x02, 0x02, 0x03, 0xA4, 0x00, 0xB0, 0x01, 0x88, 0x00, 0x01, 0x02, 0xD1, 0x01, 0xFF, 0x00,
+0xFF, 0x00, 0x86, 0x00, 0x88, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xB8, 0x01, 0x01, 0x02, 0xA4, 0x00,
+0x01, 0x02, 0xAF, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCF, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00,
+0x87, 0x00, 0x88, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xBA, 0x01, 0xA1, 0x00, 0xB2, 0x01, 0x88, 0x00,
+0x01, 0x02, 0xCF, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x88, 0x00, 0x86, 0x01, 0x01, 0x02, 0x8C, 0x00,
+0xBE, 0x01, 0x9E, 0x00, 0xB3, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCD, 0x01, 0x01, 0x02, 0xFF, 0x00,
+0xFF, 0x00, 0x89, 0x00, 0x85, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xBF, 0x01, 0x9C, 0x00,
+0x01, 0x02, 0xB3, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCC, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00,
+0x8A, 0x00, 0x85, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xC2, 0x01, 0x97, 0x00, 0xB7, 0x01, 0x88, 0x00,
+0x01, 0x02, 0xCC, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8A, 0x00, 0x84, 0x01, 0x01, 0x02, 0x8C, 0x00,
+0xC6, 0x01, 0x94, 0x00, 0xB8, 0x01, 0x88, 0x00, 0x01, 0x02, 0xCA, 0x01, 0x01, 0x02, 0x8C, 0x00,
+0x01, 0x01, 0xFF, 0x00, 0xFD, 0x00, 0x83, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC6, 0x01,
+0x01, 0x02, 0x82, 0x01, 0x8E, 0x00, 0x01, 0x01, 0x82, 0x02, 0xB8, 0x01, 0x88, 0x00, 0x01, 0x02,
+0xC9, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFD, 0x00, 0x83, 0x01, 0x8C,
+0x00, 0x01, 0x02, 0xCA, 0x01, 0x82, 0x02, 0x8A, 0x01, 0x82, 0x02, 0xBB, 0x01, 0x88, 0x00, 0x01,
+0x02, 0xC9, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x83, 0x01, 0xFF, 0x00, 0xFC, 0x00, 0x02, 0x01, 0x02,
+0x8C, 0x00, 0xD0, 0x01, 0x86, 0x02, 0xBF, 0x01, 0x88, 0x00, 0x01, 0x02, 0xC7, 0x01, 0x01, 0x02,
+0x8C, 0x00, 0x85, 0x01, 0xFF, 0x00, 0xFB, 0x00, 0x02, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xFF,
+0x01, 0x96, 0x01, 0x88, 0x00, 0x01, 0x02, 0xC6, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x85,
+0x01, 0xFF, 0x00, 0xFB, 0x00, 0x01, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xFF, 0x01, 0x97, 0x01, 0x88,
+0x00, 0x01, 0x02, 0xC6, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x86, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x88,
+0x00, 0xFF, 0x01, 0x99, 0x01, 0x88, 0x00, 0x01, 0x02, 0xC4, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x88,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0x87, 0x00, 0x01, 0x02, 0xFF, 0x01, 0x99, 0x01, 0x88, 0x00, 0x01,
+0x02, 0xC4, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x88, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x86, 0x00, 0xFF,
+0x01, 0x9B, 0x01, 0x88, 0x00, 0x01, 0x02, 0xC2, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x8A, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x85, 0x00, 0x01, 0x02, 0xFF, 0x01, 0x9B, 0x01, 0x88, 0x00, 0x01, 0x02, 0xC1,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x8A, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x84, 0x00, 0x01,
+0x02, 0xFF, 0x01, 0x9B, 0x01, 0x89, 0x00, 0x01, 0x02, 0xC1, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x8B,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0x83, 0x00, 0xFF, 0x01, 0x9D, 0x01, 0x89, 0x00, 0xC0, 0x01, 0x01,
+0x02, 0x8C, 0x00, 0x8D, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x82, 0x00, 0x01, 0x02, 0xFF, 0x01, 0x9B,
+0x01, 0x01, 0x02, 0x8A, 0x00, 0xBF, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x8E, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x01, 0x02, 0xB2, 0x01, 0x86, 0x02, 0xE2, 0x01, 0x01, 0x02, 0x8A, 0x00, 0xC0,
+0x01, 0x8C, 0x00, 0x01, 0x02, 0x8F, 0x01, 0xFF, 0x00, 0xFE, 0x00, 0xB1, 0x01, 0x82, 0x02, 0x88,
+0x01, 0x82, 0x02, 0xE0, 0x01, 0x8A, 0x00, 0xBE, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x91, 0x01, 0xFF,
+0x00, 0xFD, 0x00, 0x01, 0x02, 0xB0, 0x01, 0x8F, 0x00, 0xDC, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02,
+0xBD, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x91, 0x01, 0xFF, 0x00, 0xFC, 0x00, 0x01, 0x02, 0xAD, 0x01,
+0x96, 0x00, 0x02, 0x01, 0x02, 0xD5, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8C,
+0x00, 0x01, 0x02, 0x92, 0x01, 0xFF, 0x00, 0xFB, 0x00, 0xAC, 0x01, 0x02, 0x02, 0x03, 0x98, 0x00,
+0x02, 0x01, 0x02, 0xD3, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00,
+0x94, 0x01, 0xFF, 0x00, 0xFA, 0x00, 0x01, 0x02, 0xAC, 0x01, 0x9C, 0x00, 0xD3, 0x01, 0x8C, 0x00,
+0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x94, 0x01, 0xFF, 0x00, 0xF9, 0x00, 0xAB, 0x01,
+0x02, 0x02, 0x03, 0x9F, 0x00, 0x01, 0x02, 0xCF, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xBB, 0x01, 0x02,
+0x02, 0x03, 0x8B, 0x00, 0x02, 0x01, 0x02, 0x95, 0x01, 0xFF, 0x00, 0xF9, 0x00, 0xAC, 0x01, 0xA0,
+0x00, 0x02, 0x01, 0x02, 0xCC, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C,
+0x00, 0x01, 0x02, 0x96, 0x01, 0xFF, 0x00, 0xF9, 0x00, 0xAA, 0x01, 0xA4, 0x00, 0x01, 0x02, 0xCA,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x98, 0x01, 0xFF, 0x00, 0xF8,
+0x00, 0xAA, 0x01, 0xA4, 0x00, 0xCC, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x01, 0x02,
+0x8C, 0x00, 0x9A, 0x01, 0xFF, 0x00, 0xF8, 0x00, 0xA9, 0x01, 0xA6, 0x00, 0x02, 0x01, 0x02, 0xC8,
+0x01, 0x8B, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02, 0x9A, 0x01, 0xFF, 0x00, 0xF8, 0x00, 0xA8,
+0x01, 0xA9, 0x00, 0xC5, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8C, 0x00, 0x01,
+0x02, 0x9B, 0x01, 0xFF, 0x00, 0xF8, 0x00, 0xA7, 0x01, 0xAA, 0x00, 0xC4, 0x01, 0x02, 0x02, 0x03,
+0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x9D, 0x01, 0xFF, 0x00, 0xF8, 0x00, 0xA7, 0x01,
+0xAB, 0x00, 0xC3, 0x01, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x9D, 0x01,
+0xFF, 0x00, 0xF8, 0x00, 0xA6, 0x01, 0xAC, 0x00, 0xC1, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02,
+0xBB, 0x01, 0x02, 0x02, 0x03, 0x8C, 0x00, 0x01, 0x02, 0x9E, 0x01, 0xFF, 0x00, 0xF8, 0x00, 0xA5,
+0x01, 0xAD, 0x00, 0x02, 0x01, 0x02, 0xBE, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01,
+0x02, 0x8C, 0x00, 0xA0, 0x01, 0xFF, 0x00, 0xF8, 0x00, 0xA4, 0x01, 0x01, 0x02, 0xAE, 0x00, 0xBE,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x9F, 0x01, 0xFF,
+0x00, 0xF9, 0x00, 0xA3, 0x01, 0x02, 0x02, 0x03, 0xAF, 0x00, 0x01, 0x02, 0xBB, 0x01, 0x01, 0x02,
+0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xA0, 0x01, 0xFF, 0x00, 0xF9, 0x00,
+0xA4, 0x01, 0xB0, 0x00, 0x01, 0x02, 0xBC, 0x01, 0x8B, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0xA2, 0x01,
+0xFF, 0x00, 0xF9, 0x00, 0xA4, 0x01, 0xB0, 0x00, 0xBA, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBD, 0x01,
+0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xA2, 0x01, 0xFF, 0x00, 0xF9, 0x00, 0xA3, 0x01, 0xB1, 0x00,
+0xBB, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xA4, 0x01,
+0xFF, 0x00, 0xF9, 0x00, 0xA2, 0x01, 0x01, 0x02, 0xB2, 0x00, 0xB9, 0x01, 0x8B, 0x00, 0xBD, 0x01,
+0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xA4, 0x01, 0xFF, 0x00, 0xFA, 0x00, 0xA2, 0x01, 0xB2, 0x00,
+0xB6, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xA5, 0x01, 0xFF, 0x00,
+0xFA, 0x00, 0xA2, 0x01, 0xB2, 0x00, 0xB5, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0x02, 0x01, 0x02,
+0xBB, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xA7, 0x01, 0xFF, 0x00, 0xFA, 0x00, 0x01, 0x02, 0xA1, 0x01,
+0xB2, 0x00, 0xB4, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02,
+0xA7, 0x01, 0xFF, 0x00, 0xFA, 0x00, 0x01, 0x02, 0xA1, 0x01, 0xB2, 0x00, 0xB4, 0x01, 0x8C, 0x00,
+0x01, 0x02, 0xBD, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xA7, 0x01, 0xFF, 0x00, 0xFB, 0x00, 0x01, 0x02,
+0xA1, 0x01, 0xB2, 0x00, 0xB4, 0x01, 0x8B, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0xA9, 0x01, 0xFF, 0x00,
+0xFB, 0x00, 0x01, 0x02, 0xA1, 0x01, 0xB2, 0x00, 0xB1, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBD, 0x01,
+0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xA9, 0x01, 0xFF, 0x00, 0xFB, 0x00, 0xA2, 0x01, 0xB2, 0x00,
+0xB0, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xAA, 0x01,
+0xFF, 0x00, 0xFB, 0x00, 0xA2, 0x01, 0xB2, 0x00, 0xB1, 0x01, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02,
+0x8C, 0x00, 0xAC, 0x01, 0xFF, 0x00, 0xFB, 0x00, 0x02, 0x01, 0x02, 0xA0, 0x01, 0xB2, 0x00, 0xAF,
+0x01, 0x8C, 0x00, 0xBC, 0x01, 0x02, 0x02, 0x03, 0x8C, 0x00, 0x01, 0x02, 0xAB, 0x01, 0x01, 0x02,
+0xFF, 0x00, 0xFB, 0x00, 0x02, 0x01, 0x02, 0x9F, 0x01, 0x01, 0x02, 0xB2, 0x00, 0xAF, 0x01, 0x8B,
+0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xAE, 0x01, 0xFF, 0x00, 0xFB,
+0x00, 0xA2, 0x01, 0xB2, 0x00, 0xAC, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02,
+0x8C, 0x00, 0xAF, 0x01, 0xFF, 0x00, 0xFC, 0x00, 0xA2, 0x01, 0xB0, 0x00, 0xAD, 0x01, 0x8C, 0x00,
+0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xAE, 0x01, 0xFF, 0x00, 0xFD, 0x00, 0xA2, 0x01, 0xB0, 0x00,
+0xAD, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBC, 0x01, 0x8C, 0x00, 0xB0, 0x01, 0xFF, 0x00, 0xFD,
+0x00, 0xA1, 0x01, 0x02, 0x02, 0x03, 0xAF, 0x00, 0x01, 0x02, 0xAB, 0x01, 0x8B, 0x00, 0xBD, 0x01,
+0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xAF, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFE, 0x00, 0xA1, 0x01,
+0x01, 0x02, 0xAE, 0x00, 0xAB, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8C, 0x00, 0x01, 0x02,
+0xB0, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFE, 0x00, 0xA1, 0x01, 0x01, 0x02, 0xAE, 0x00, 0xAB, 0x01,
+0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xB2, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFE, 0x00,
+0xA3, 0x01, 0xAC, 0x00, 0xA9, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02,
+0xB1, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFE, 0x00, 0x01, 0x02, 0xA3, 0x01, 0xAB, 0x00, 0xA8,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xB2, 0x01, 0x02,
+0x02, 0x03, 0xFF, 0x00, 0xFE, 0x00, 0xA4, 0x01, 0xAA, 0x00, 0xA8, 0x01, 0x02, 0x02, 0x03, 0x8B,
+0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xB5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA4, 0x01, 0xAA,
+0x00, 0xA8, 0x01, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xB5, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x01, 0x00, 0xA2, 0x01, 0xA9, 0x00, 0x02, 0x01, 0x02, 0xA7, 0x01, 0x8C, 0x00,
+0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xB5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x82, 0x00, 0x01, 0x02,
+0x9F, 0x01, 0x01, 0x02, 0xAA, 0x00, 0x01, 0x02, 0xA6, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0xB7, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x82, 0x00, 0x01, 0x02, 0x9F,
+0x01, 0xAA, 0x00, 0xA8, 0x01, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xB6,
+0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x82, 0x00, 0x02, 0x01, 0x02, 0x9C, 0x01, 0x01, 0x02,
+0xAA, 0x00, 0xA9, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00,
+0xB9, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x82, 0x00, 0x02, 0x01, 0x02, 0x9B, 0x01, 0x01, 0x02, 0xAA,
+0x00, 0x01, 0x02, 0xA6, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBC, 0x01, 0x82, 0x02, 0x8C, 0x00,
+0x01, 0x02, 0xB9, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x83, 0x00, 0x9C, 0x01, 0x8C, 0x00, 0x01, 0x01,
+0x9C, 0x00, 0xA8, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBE, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xB9, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0x84, 0x00, 0x9A, 0x01, 0x01, 0x02, 0x8D, 0x00, 0x02, 0x02, 0x03, 0x9A,
+0x00, 0xA8, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x01, 0x02, 0x8C,
+0x00, 0xBB, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x99, 0x01, 0x8C, 0x00, 0x02, 0x01, 0x02,
+0x84, 0x01, 0x96, 0x00, 0x02, 0x01, 0x02, 0xA8, 0x01, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C,
+0x00, 0x01, 0x02, 0xBA, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x98, 0x01, 0x8C,
+0x00, 0x8B, 0x01, 0x8F, 0x00, 0x02, 0x01, 0x02, 0xAA, 0x01, 0x8C, 0x00, 0xBE, 0x01, 0x8C, 0x00,
+0x01, 0x02, 0xBA, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0x96, 0x01, 0x01,
+0x02, 0x8D, 0x00, 0x8A, 0x01, 0x01, 0x02, 0x82, 0x01, 0x8A, 0x00, 0x82, 0x01, 0x01, 0x02, 0xAA,
+0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBC, 0x01, 0x01, 0x02,
+0xFF, 0x00, 0xFF, 0x00, 0x86, 0x00, 0x95, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x02, 0x01, 0x02, 0x8F,
+0x01, 0x87, 0x02, 0xAE, 0x01, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xBD,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0x87, 0x00, 0x94, 0x01, 0x8C, 0x00, 0xC6, 0x01, 0x8C, 0x00, 0xBE,
+0x01, 0x8C, 0x00, 0x01, 0x02, 0xBD, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x88, 0x00, 0x01, 0x02, 0x91,
+0x01, 0x01, 0x02, 0x8D, 0x00, 0xC4, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02,
+0x8C, 0x00, 0xBE, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x88, 0x00, 0x02, 0x01, 0x02, 0x8F,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0xC5, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C,
+0x00, 0x01, 0x02, 0xBF, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x89, 0x00, 0x01, 0x02, 0x8E, 0x01, 0x02,
+0x02, 0x03, 0x8C, 0x00, 0x01, 0x02, 0xC5, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x02,
+0x02, 0x03, 0x8B, 0x00, 0xC1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x89, 0x00, 0x8F, 0x01, 0x8C, 0x00,
+0xC7, 0x01, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xC1, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0x8B, 0x00, 0x01, 0x02, 0x8C, 0x01, 0x8C, 0x00, 0xC5, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBE, 0x01,
+0x8C, 0x00, 0x01, 0x02, 0xC1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8B, 0x00, 0x01, 0x02, 0x8A, 0x01,
+0x01, 0x02, 0x8D, 0x00, 0xC6, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x01, 0x02, 0x8C,
+0x00, 0xC3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8B, 0x00, 0x8A, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x02,
+0x01, 0x02, 0xC5, 0x01, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC2, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0x8D, 0x00, 0x89, 0x01, 0x8C, 0x00, 0xC6, 0x01, 0x8C, 0x00, 0xBE, 0x01,
+0x8C, 0x00, 0x01, 0x02, 0xC2, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x8E, 0x00, 0x87, 0x01, 0x01, 0x02,
+0x8D, 0x00, 0xC4, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xC3,
+0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x8E, 0x00, 0x86, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xC5,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC4, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x8F, 0x00, 0x85, 0x01, 0x8C, 0x00, 0xC6, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xBD,
+0x01, 0x8C, 0x00, 0x01, 0x02, 0xC4, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x91, 0x00, 0x83, 0x01, 0x8D,
+0x00, 0xC4, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xC6, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0x91, 0x00, 0x82, 0x02, 0x8C, 0x00, 0xC5, 0x01, 0x01, 0x02, 0x8C, 0x00,
+0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x92, 0x00,
+0x82, 0x01, 0x8C, 0x00, 0xC6, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xBB, 0x01, 0x02, 0x02, 0x03,
+0x8B, 0x00, 0xC7, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9F, 0x00, 0x01, 0x02, 0xC5, 0x01, 0x8B, 0x00,
+0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xC7, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9E, 0x00, 0xC6, 0x01,
+0x8C, 0x00, 0xBD, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC6, 0x01, 0x01, 0x02, 0xFF, 0x00,
+0xFF, 0x00, 0x9E, 0x00, 0xC6, 0x01, 0x8B, 0x00, 0xBD, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xC9,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9C, 0x00, 0xC5, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xBD, 0x01,
+0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC8, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9C, 0x00, 0xC6, 0x01,
+0x8C, 0x00, 0xA7, 0x01, 0x83, 0x02, 0x01, 0x01, 0x83, 0x02, 0x90, 0x01, 0x8C, 0x00, 0x01, 0x02,
+0xC7, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x9D, 0x00, 0xC6, 0x01, 0x8B, 0x00, 0x02, 0x01,
+0x02, 0xA6, 0x01, 0x87, 0x00, 0x8E, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xCA, 0x01, 0xFF, 0x00, 0xFF,
+0x00, 0x9B, 0x00, 0xC5, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xA1, 0x01, 0x01, 0x02, 0x82, 0x01,
+0x91, 0x00, 0x02, 0x01, 0x02, 0x86, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xC9, 0x01, 0xFF,
+0x00, 0xFF, 0x00, 0x9B, 0x00, 0xC5, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x9F, 0x01, 0x02,
+0x02, 0x03, 0x97, 0x00, 0x01, 0x02, 0x84, 0x01, 0x8C, 0x00, 0x01, 0x02, 0xCA, 0x01, 0xFF, 0x00,
+0xFF, 0x00, 0x9B, 0x00, 0xC6, 0x01, 0x8B, 0x00, 0xA0, 0x01, 0x02, 0x02, 0x03, 0x99, 0x00, 0x03,
+0x02, 0x03, 0x04, 0x8C, 0x00, 0xCC, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9C, 0x00, 0xC3, 0x01, 0x8C,
+0x00, 0xA1, 0x01, 0xA9, 0x00, 0x01, 0x02, 0xCB, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0x9D, 0x00, 0xC1,
+0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0x9E, 0x01, 0x01, 0x02, 0xAA, 0x00, 0x01, 0x02, 0xCA,
+0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0x9F, 0x00, 0x01, 0x02, 0xBE, 0x01, 0x02, 0x02, 0x03,
+0x8B, 0x00, 0x9F, 0x01, 0x02, 0x02, 0x03, 0xA9, 0x00, 0xCD, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA0,
+0x00, 0xBE, 0x01, 0x8C, 0x00, 0xA0, 0x01, 0xAA, 0x00, 0x01, 0x02, 0xCC, 0x01, 0xFF, 0x00, 0xFF,
+0x00, 0xA1, 0x00, 0x01, 0x02, 0xBD, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0x9D, 0x01, 0x02, 0x02,
+0x03, 0xA9, 0x00, 0xCE, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA2, 0x00, 0xBC, 0x01, 0x8B, 0x00, 0x9F,
+0x01, 0x01, 0x02, 0xAA, 0x00, 0xCE, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA3, 0x00, 0xB9, 0x01, 0x01,
+0x02, 0x8C, 0x00, 0xA1, 0x01, 0xA9, 0x00, 0x01, 0x02, 0xCC, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF,
+0x00, 0xA5, 0x00, 0xB9, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0x9E, 0x01, 0x01, 0x02, 0xAA, 0x00,
+0xCC, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xA6, 0x00, 0x01, 0x02, 0xB6, 0x01, 0x8B,
+0x00, 0xA0, 0x01, 0x02, 0x02, 0x03, 0xAB, 0x00, 0xCB, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA8, 0x00,
+0x02, 0x01, 0x02, 0xB2, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xA2, 0x01, 0xAD, 0x00, 0x01, 0x02, 0xC9,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xA9, 0x00, 0xB2, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0x02, 0x01,
+0x02, 0xA0, 0x01, 0xAE, 0x00, 0xC9, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xAB, 0x00, 0xB1, 0x01, 0x8C,
+0x00, 0xA3, 0x01, 0xAE, 0x00, 0xC9, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xAC, 0x00, 0xAF, 0x01, 0x8C,
+0x00, 0x01, 0x02, 0xA2, 0x01, 0xB0, 0x00, 0xC6, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xAE, 0x00, 0xAD,
+0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xA4, 0x01, 0xB0, 0x00, 0xC5, 0x01, 0x01, 0x02, 0xFF, 0x00,
+0xFF, 0x00, 0xAF, 0x00, 0xAB, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xA4, 0x01, 0x01, 0x02, 0xB0, 0x00,
+0xC4, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xB1, 0x00, 0x01, 0x02, 0xAA, 0x01, 0x8B, 0x00,
+0x02, 0x01, 0x02, 0xA4, 0x01, 0xB0, 0x00, 0xC5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xB2, 0x00, 0xA9,
+0x01, 0x8B, 0x00, 0xA5, 0x01, 0x02, 0x02, 0x03, 0xB1, 0x00, 0xC3, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0xB3, 0x00, 0x02, 0x01, 0x02, 0xA4, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xA6, 0x01, 0x01, 0x02, 0xB2,
+0x00, 0xC2, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xB5, 0x00, 0xA6, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02,
+0xA6, 0x01, 0xB2, 0x00, 0xC2, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xB6, 0x00, 0xA4, 0x01, 0x8B, 0x00,
+0xA9, 0x01, 0xB3, 0x00, 0xBE, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xB8, 0x00, 0x01,
+0x02, 0xA0, 0x01, 0x8C, 0x00, 0xAA, 0x01, 0xB3, 0x00, 0xBE, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xBA,
+0x00, 0x02, 0x01, 0x02, 0x9F, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xA9, 0x01, 0xB3, 0x00, 0xBE,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xBC, 0x00, 0x9C, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00, 0xAC, 0x01,
+0xB3, 0x00, 0xBC, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xBE, 0x00, 0x9B, 0x01, 0x8C, 0x00,
+0x01, 0x02, 0xAC, 0x01, 0xB3, 0x00, 0xBC, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xBF, 0x00, 0x9B, 0x01,
+0x8B, 0x00, 0xAE, 0x01, 0xB2, 0x00, 0xBB, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xC2, 0x00,
+0x01, 0x02, 0x95, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xAE, 0x01, 0x02, 0x02, 0x03, 0xB1, 0x00, 0xBB,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xC4, 0x00, 0x94, 0x01, 0x01, 0x02, 0x8C, 0x00, 0x01, 0x02, 0xAE,
+0x01, 0x02, 0x02, 0x03, 0xB1, 0x00, 0xBA, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xC6, 0x00, 0x94, 0x01,
+0x8B, 0x00, 0xB2, 0x01, 0xB0, 0x00, 0xB9, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xC7, 0x00,
+0x91, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xB2, 0x01, 0x01, 0x02, 0xB0, 0x00, 0xB9, 0x01, 0xFF, 0x00,
+0xFF, 0x00, 0xC9, 0x00, 0x02, 0x01, 0x02, 0x8F, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xB2, 0x01,
+0xB0, 0x00, 0xB7, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xCC, 0x00, 0x8C, 0x01, 0x02, 0x02,
+0x03, 0x8B, 0x00, 0xB6, 0x01, 0xAF, 0x00, 0xB6, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xCE,
+0x00, 0x8B, 0x01, 0x8C, 0x00, 0xB7, 0x01, 0xAE, 0x00, 0xB7, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xCF,
+0x00, 0x02, 0x01, 0x02, 0x89, 0x01, 0x8B, 0x00, 0x02, 0x01, 0x02, 0xB6, 0x01, 0xAE, 0x00, 0xB6,
+0x01, 0xFF, 0x00, 0xFF, 0x00, 0xD2, 0x00, 0x01, 0x02, 0x85, 0x01, 0x02, 0x02, 0x03, 0x8B, 0x00,
+0xBA, 0x01, 0xAD, 0x00, 0xB3, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xD4, 0x00, 0x01,
+0x02, 0x83, 0x01, 0x01, 0x02, 0x8C, 0x00, 0xBA, 0x01, 0x02, 0x02, 0x03, 0xAA, 0x00, 0x02, 0x01,
+0x02, 0xB2, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xD7, 0x00, 0x84, 0x01, 0x8B, 0x00, 0x02,
+0x01, 0x02, 0xBA, 0x01, 0x01, 0x02, 0xAA, 0x00, 0xB5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xD8, 0x00,
+0x01, 0x01, 0x8C, 0x00, 0xBF, 0x01, 0xA8, 0x00, 0xB5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE5, 0x00,
+0x01, 0x02, 0xC0, 0x01, 0xA6, 0x00, 0xB2, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xE6,
+0x00, 0xC1, 0x01, 0x02, 0x02, 0x03, 0xA5, 0x00, 0x01, 0x02, 0xB2, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0xE6, 0x00, 0xC5, 0x01, 0xA3, 0x00, 0x01, 0x02, 0xB1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE7, 0x00,
+0x02, 0x01, 0x02, 0xC3, 0x01, 0x02, 0x02, 0x03, 0xA1, 0x00, 0xB3, 0x01, 0xFF, 0x00, 0xFF, 0x00,
+0xE6, 0x00, 0xC9, 0x01, 0x9E, 0x00, 0xB3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xE8, 0x00, 0xC9, 0x01,
+0x02, 0x02, 0x03, 0x9A, 0x00, 0xB3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xEB, 0x00, 0xC9, 0x01, 0x02,
+0x02, 0x03, 0x99, 0x00, 0x02, 0x01, 0x02, 0xAF, 0x01, 0x01, 0x02, 0xFF, 0x00, 0xFF, 0x00, 0xEE,
+0x00, 0xCB, 0x01, 0x94, 0x00, 0xB2, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xF0, 0x00,
+0xCB, 0x01, 0x82, 0x02, 0x01, 0x01, 0x8D, 0x00, 0x02, 0x01, 0x02, 0xB1, 0x01, 0x02, 0x02, 0x03,
+0xFF, 0x00, 0xFF, 0x00, 0xF4, 0x00, 0x01, 0x02, 0xCA, 0x01, 0x01, 0x02, 0x84, 0x01, 0x84, 0x00,
+0x84, 0x01, 0x01, 0x02, 0xB2, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xF7, 0x00, 0xFF,
+0x01, 0x8A, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFB, 0x00, 0x02, 0x01, 0x02, 0xFF, 0x01, 0x82, 0x01,
+0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFE, 0x00, 0x02, 0x01, 0x02, 0xFF, 0x01, 0x02, 0x02,
+0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x82, 0x00, 0xFD, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0x85, 0x00, 0xFD, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x89, 0x00,
+0xF5, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x8D, 0x00, 0x82, 0x01, 0x01,
+0x02, 0xF1, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x91, 0x00, 0x02, 0x01, 0x02, 0xEE, 0x01,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x96, 0x00, 0x02, 0x01, 0x02, 0xE8, 0x01, 0xFF, 0x00, 0xFF,
+0x00, 0xFF, 0x00, 0x9C, 0x00, 0x02, 0x01, 0x02, 0xE3, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0x9F, 0x00, 0x02, 0x01, 0x02, 0xDE, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xA4, 0x00, 0x01, 0x01, 0x82, 0x02, 0xD7, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
+0x00, 0xAB, 0x00, 0xD5, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xB0, 0x00, 0x82, 0x01, 0x01,
+0x02, 0xCB, 0x01, 0x01, 0x02, 0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xB5, 0x00, 0x83,
+0x01, 0x01, 0x02, 0xC2, 0x01, 0x82, 0x02, 0x82, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xBE,
+0x00, 0x82, 0x01, 0x01, 0x02, 0xBB, 0x01, 0x02, 0x02, 0x03, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xC6, 0x00, 0xBB, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xCD, 0x00, 0x84, 0x01, 0x83, 0x02,
+0xA2, 0x01, 0x83, 0x02, 0x84, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xD7, 0x00, 0x84, 0x01,
+0x84, 0x02, 0x98, 0x01, 0x84, 0x02, 0x85, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xE6, 0x00,
+0x91, 0x01, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xA8, 0x00, 0x8E, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xF1, 0x00, 0x95, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xEE, 0x00, 0x95, 0x05, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xED, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xED, 0x00,
+0x96, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xED, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xED, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xEB, 0x00, 0x85, 0x05, 0xD8, 0x00,
+0x86, 0x05, 0x9E, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xE0, 0x00, 0x8E, 0x05, 0xF3, 0x00, 0x99, 0x05,
+0xC4, 0x00, 0x99, 0x05, 0x94, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xD2, 0x00, 0xA2, 0x05, 0xB0, 0x00,
+0x96, 0x05, 0xA4, 0x00, 0xA0, 0x05, 0xBD, 0x00, 0x9F, 0x05, 0x91, 0x00, 0x96, 0x05, 0xFF, 0x00,
+0xC8, 0x00, 0xB2, 0x05, 0xA8, 0x00, 0x98, 0x05, 0xA1, 0x00, 0xA7, 0x05, 0xB5, 0x00, 0xA7, 0x05,
+0x8D, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xB5, 0x05, 0xA5, 0x00, 0x98, 0x05, 0xA0, 0x00,
+0xAA, 0x05, 0xB1, 0x00, 0xAB, 0x05, 0x8B, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xB8, 0x05,
+0xA1, 0x00, 0x99, 0x05, 0x9D, 0x00, 0xB0, 0x05, 0xAC, 0x00, 0xB0, 0x05, 0x88, 0x00, 0x96, 0x05,
+0xFF, 0x00, 0xC8, 0x00, 0xBA, 0x05, 0x9F, 0x00, 0x99, 0x05, 0x9B, 0x00, 0xB5, 0x05, 0xA5, 0x00,
+0xB6, 0x05, 0x86, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xBC, 0x05, 0x9D, 0x00, 0x99, 0x05,
+0x9A, 0x00, 0xB6, 0x05, 0xA5, 0x00, 0xB7, 0x05, 0x85, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00,
+0xBE, 0x05, 0x9B, 0x00, 0x99, 0x05, 0x99, 0x00, 0xB9, 0x05, 0xA0, 0x00, 0xBC, 0x05, 0x83, 0x00,
+0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xBF, 0x05, 0x9A, 0x00, 0x99, 0x05, 0x98, 0x00, 0xBB, 0x05,
+0x9E, 0x00, 0xBE, 0x05, 0x82, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC0, 0x05, 0x99, 0x00,
+0x99, 0x05, 0x96, 0x00, 0xBD, 0x05, 0x9D, 0x00, 0xBF, 0x05, 0x82, 0x00, 0x96, 0x05, 0xFF, 0x00,
+0xC8, 0x00, 0xC2, 0x05, 0x97, 0x00, 0x99, 0x05, 0x96, 0x00, 0xBC, 0x05, 0x9C, 0x00, 0xC1, 0x05,
+0x82, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC3, 0x05, 0x96, 0x00, 0x99, 0x05, 0x95, 0x00,
+0xBD, 0x05, 0x9B, 0x00, 0xC2, 0x05, 0x82, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC4, 0x05,
+0x95, 0x00, 0x99, 0x05, 0x94, 0x00, 0xBE, 0x05, 0x9A, 0x00, 0xC2, 0x05, 0x83, 0x00, 0x96, 0x05,
+0xFF, 0x00, 0xC8, 0x00, 0xC4, 0x05, 0x95, 0x00, 0x99, 0x05, 0x93, 0x00, 0xBF, 0x05, 0x99, 0x00,
+0xC3, 0x05, 0x83, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC5, 0x05, 0x94, 0x00, 0x9A, 0x05,
+0x91, 0x00, 0xBF, 0x05, 0x99, 0x00, 0xC4, 0x05, 0x83, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00,
+0xC5, 0x05, 0x94, 0x00, 0x9A, 0x05, 0x91, 0x00, 0xBF, 0x05, 0x98, 0x00, 0xC5, 0x05, 0x83, 0x00,
+0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC7, 0x05, 0x92, 0x00, 0x9A, 0x05, 0x91, 0x00, 0xBE, 0x05,
+0x98, 0x00, 0xC5, 0x05, 0x84, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC7, 0x05, 0x92, 0x00,
+0x9A, 0x05, 0x90, 0x00, 0xBF, 0x05, 0x98, 0x00, 0xC4, 0x05, 0x85, 0x00, 0x96, 0x05, 0xFF, 0x00,
+0xC8, 0x00, 0xC7, 0x05, 0x92, 0x00, 0x9A, 0x05, 0x8F, 0x00, 0xC0, 0x05, 0x97, 0x00, 0xC5, 0x05,
+0x85, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC8, 0x05, 0x91, 0x00, 0x9A, 0x05, 0x8F, 0x00,
+0xBF, 0x05, 0x97, 0x00, 0xC6, 0x05, 0x85, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0xC8, 0x05,
+0x91, 0x00, 0x9A, 0x05, 0x8F, 0x00, 0xBE, 0x05, 0x98, 0x00, 0xC5, 0x05, 0x86, 0x00, 0x96, 0x05,
+0xFF, 0x00, 0xC8, 0x00, 0xC8, 0x05, 0x91, 0x00, 0x9A, 0x05, 0x8F, 0x00, 0x9D, 0x05, 0x8F, 0x00,
+0x92, 0x05, 0x97, 0x00, 0xC6, 0x05, 0x86, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00, 0x99, 0x05,
+0x90, 0x00, 0xA0, 0x05, 0x90, 0x00, 0x9A, 0x05, 0x8E, 0x00, 0x9B, 0x05, 0x96, 0x00, 0x8D, 0x05,
+0x97, 0x00, 0xA8, 0x05, 0x89, 0x00, 0x96, 0x05, 0x86, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC8, 0x00,
+0x99, 0x05, 0x92, 0x00, 0x9E, 0x05, 0x90, 0x00, 0x9A, 0x05, 0x8E, 0x00, 0x9A, 0x05, 0x99, 0x00,
+0x8B, 0x05, 0x97, 0x00, 0xA6, 0x05, 0x8E, 0x00, 0x92, 0x05, 0x87, 0x00, 0x96, 0x05, 0xFF, 0x00,
+0xC8, 0x00, 0x99, 0x05, 0x94, 0x00, 0x9C, 0x05, 0x90, 0x00, 0x9A, 0x05, 0x8E, 0x00, 0x99, 0x05,
+0x9E, 0x00, 0x87, 0x05, 0x96, 0x00, 0xA3, 0x05, 0x96, 0x00, 0x8D, 0x05, 0x88, 0x00, 0x96, 0x05,
+0xFF, 0x00, 0xC7, 0x00, 0x9A, 0x05, 0x96, 0x00, 0x9B, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8D, 0x00,
+0x99, 0x05, 0xA2, 0x00, 0x82, 0x05, 0x98, 0x00, 0xA1, 0x05, 0x9C, 0x00, 0x89, 0x05, 0x88, 0x00,
+0x96, 0x05, 0xFF, 0x00, 0xC7, 0x00, 0x9A, 0x05, 0x96, 0x00, 0x9B, 0x05, 0x8F, 0x00, 0x9A, 0x05,
+0x8D, 0x00, 0x99, 0x05, 0xA3, 0x00, 0x01, 0x05, 0x97, 0x00, 0xA1, 0x05, 0x9E, 0x00, 0x87, 0x05,
+0x89, 0x00, 0x96, 0x05, 0xFF, 0x00, 0xC7, 0x00, 0x9A, 0x05, 0x97, 0x00, 0x9A, 0x05, 0x8F, 0x00,
+0x9A, 0x05, 0x8D, 0x00, 0x99, 0x05, 0xBA, 0x00, 0xA0, 0x05, 0xA3, 0x00, 0x83, 0x05, 0x8A, 0x00,
+0x96, 0x05, 0xE4, 0x00, 0x84, 0x05, 0x9F, 0x00, 0x87, 0x05, 0x9A, 0x00, 0x85, 0x05, 0x99, 0x00,
+0x9A, 0x05, 0x98, 0x00, 0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8D, 0x00, 0x99, 0x05, 0xBA, 0x00,
+0x9F, 0x05, 0xA4, 0x00, 0x83, 0x05, 0x8A, 0x00, 0x96, 0x05, 0xA5, 0x00, 0x8E, 0x05, 0xAA, 0x00,
+0x8B, 0x05, 0x96, 0x00, 0x91, 0x05, 0x99, 0x00, 0x8B, 0x05, 0x93, 0x00, 0x9A, 0x05, 0x98, 0x00,
+0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8D, 0x00, 0x99, 0x05, 0xBA, 0x00, 0x9E, 0x05, 0xB2, 0x00,
+0x95, 0x05, 0xA1, 0x00, 0x98, 0x05, 0x9F, 0x00, 0x91, 0x05, 0x94, 0x00, 0x93, 0x05, 0x99, 0x00,
+0x90, 0x05, 0x8E, 0x00, 0x9A, 0x05, 0x98, 0x00, 0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8D, 0x00,
+0x99, 0x05, 0xB9, 0x00, 0x9E, 0x05, 0xB3, 0x00, 0x95, 0x05, 0xA0, 0x00, 0x9B, 0x05, 0x9A, 0x00,
+0x95, 0x05, 0x93, 0x00, 0x94, 0x05, 0x98, 0x00, 0x92, 0x05, 0x8C, 0x00, 0x9A, 0x05, 0x98, 0x00,
+0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8D, 0x00, 0x99, 0x05, 0xB9, 0x00, 0x9D, 0x05, 0xB4, 0x00,
+0x95, 0x05, 0x9D, 0x00, 0xA1, 0x05, 0x97, 0x00, 0x95, 0x05, 0x93, 0x00, 0x94, 0x05, 0x97, 0x00,
+0x96, 0x05, 0x89, 0x00, 0x9A, 0x05, 0x98, 0x00, 0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8D, 0x00,
+0x9B, 0x05, 0xB7, 0x00, 0x9C, 0x05, 0xB5, 0x00, 0x95, 0x05, 0x9B, 0x00, 0xA5, 0x05, 0x95, 0x00,
+0x96, 0x05, 0x93, 0x00, 0x94, 0x05, 0x96, 0x00, 0x96, 0x05, 0x89, 0x00, 0x9A, 0x05, 0x99, 0x00,
+0x98, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8E, 0x00, 0x9B, 0x05, 0xB6, 0x00, 0x9C, 0x05, 0xB5, 0x00,
+0x95, 0x05, 0x9A, 0x00, 0xA7, 0x05, 0x94, 0x00, 0x96, 0x05, 0x93, 0x00, 0x94, 0x05, 0x96, 0x00,
+0x96, 0x05, 0x89, 0x00, 0x9A, 0x05, 0x99, 0x00, 0x98, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8E, 0x00,
+0x9C, 0x05, 0xB5, 0x00, 0x9B, 0x05, 0xB6, 0x00, 0x95, 0x05, 0x98, 0x00, 0xAA, 0x05, 0x93, 0x00,
+0x96, 0x05, 0x93, 0x00, 0x94, 0x05, 0x95, 0x00, 0x96, 0x05, 0x8A, 0x00, 0x9A, 0x05, 0x99, 0x00,
+0x98, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8E, 0x00, 0x9F, 0x05, 0xB1, 0x00, 0x9B, 0x05, 0xB7, 0x00,
+0x95, 0x05, 0x96, 0x00, 0xAC, 0x05, 0x93, 0x00, 0x96, 0x05, 0x94, 0x00, 0x93, 0x05, 0x95, 0x00,
+0x96, 0x05, 0x8A, 0x00, 0x9A, 0x05, 0x98, 0x00, 0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8E, 0x00,
+0xA3, 0x05, 0xAD, 0x00, 0x9B, 0x05, 0xB7, 0x00, 0x95, 0x05, 0x96, 0x00, 0xAC, 0x05, 0x93, 0x00,
+0x96, 0x05, 0x94, 0x00, 0x94, 0x05, 0x94, 0x00, 0x95, 0x05, 0x8B, 0x00, 0x9A, 0x05, 0x98, 0x00,
+0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8F, 0x00, 0xA5, 0x05, 0xA9, 0x00, 0x9C, 0x05, 0xB7, 0x00,
+0x95, 0x05, 0x95, 0x00, 0xAC, 0x05, 0x95, 0x00, 0x96, 0x05, 0x93, 0x00, 0x94, 0x05, 0x93, 0x00,
+0x96, 0x05, 0x8B, 0x00, 0x9A, 0x05, 0x98, 0x00, 0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8F, 0x00,
+0xAA, 0x05, 0xA4, 0x00, 0x9B, 0x05, 0xB8, 0x00, 0x95, 0x05, 0x93, 0x00, 0xAC, 0x05, 0x97, 0x00,
+0x96, 0x05, 0x93, 0x00, 0x94, 0x05, 0x93, 0x00, 0x96, 0x05, 0x8B, 0x00, 0x9A, 0x05, 0x98, 0x00,
+0x99, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8F, 0x00, 0xAE, 0x05, 0xA0, 0x00, 0x9B, 0x05, 0xB8, 0x00,
+0x95, 0x05, 0x93, 0x00, 0xAC, 0x05, 0x97, 0x00, 0x96, 0x05, 0x94, 0x00, 0x93, 0x05, 0x93, 0x00,
+0x96, 0x05, 0x8B, 0x00, 0x9A, 0x05, 0x97, 0x00, 0x9A, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x8F, 0x00,
+0xB0, 0x05, 0x9E, 0x00, 0x9B, 0x05, 0xB8, 0x00, 0x95, 0x05, 0x92, 0x00, 0xAC, 0x05, 0x98, 0x00,
+0x96, 0x05, 0x93, 0x00, 0x95, 0x05, 0x91, 0x00, 0x96, 0x05, 0x8C, 0x00, 0x9A, 0x05, 0x96, 0x00,
+0x9B, 0x05, 0x8F, 0x00, 0x9A, 0x05, 0x90, 0x00, 0xB2, 0x05, 0x9B, 0x00, 0x9A, 0x05, 0xB9, 0x00,
+0x95, 0x05, 0x91, 0x00, 0xAC, 0x05, 0x8B, 0x00, 0x01, 0x05, 0x8D, 0x00, 0x97, 0x05, 0x92, 0x00,
+0x95, 0x05, 0x91, 0x00, 0x96, 0x05, 0x8C, 0x00, 0x9A, 0x05, 0x96, 0x00, 0x9A, 0x05, 0x90, 0x00,
+0x9A, 0x05, 0x90, 0x00, 0xB4, 0x05, 0x99, 0x00, 0x9A, 0x05, 0xB9, 0x00, 0x95, 0x05, 0x90, 0x00,
+0xAC, 0x05, 0x8B, 0x00, 0x83, 0x05, 0x8D, 0x00, 0x96, 0x05, 0x92, 0x00, 0x96, 0x05, 0x90, 0x00,
+0x95, 0x05, 0x8D, 0x00, 0x9A, 0x05, 0x95, 0x00, 0x9B, 0x05, 0x90, 0x00, 0x9A, 0x05, 0x91, 0x00,
+0xB5, 0x05, 0x97, 0x00, 0x9A, 0x05, 0xB9, 0x00, 0x95, 0x05, 0x90, 0x00, 0xAA, 0x05, 0x8B, 0x00,
+0x86, 0x05, 0x8C, 0x00, 0x97, 0x05, 0x90, 0x00, 0x97, 0x05, 0x90, 0x00, 0x95, 0x05, 0x8D, 0x00,
+0x9A, 0x05, 0x92, 0x00, 0x9D, 0x05, 0x91, 0x00, 0x9A, 0x05, 0x91, 0x00, 0xB7, 0x05, 0x95, 0x00,
+0x99, 0x05, 0xBA, 0x00, 0x95, 0x05, 0x8F, 0x00, 0xAB, 0x05, 0x8B, 0x00, 0x86, 0x05, 0x8D, 0x00,
+0x96, 0x05, 0x90, 0x00, 0x97, 0x05, 0x90, 0x00, 0x95, 0x05, 0x8D, 0x00, 0x9A, 0x05, 0x90, 0x00,
+0x9F, 0x05, 0x91, 0x00, 0x9A, 0x05, 0x92, 0x00, 0xB7, 0x05, 0x94, 0x00, 0x99, 0x05, 0xBA, 0x00,
+0x95, 0x05, 0x8F, 0x00, 0xAA, 0x05, 0x8B, 0x00, 0x88, 0x05, 0x8C, 0x00, 0x96, 0x05, 0x90, 0x00,
+0x97, 0x05, 0x8F, 0x00, 0x95, 0x05, 0x8E, 0x00, 0xC9, 0x05, 0x91, 0x00, 0x9A, 0x05, 0x92, 0x00,
+0xB9, 0x05, 0x92, 0x00, 0x99, 0x05, 0xBA, 0x00, 0x95, 0x05, 0x8E, 0x00, 0xA9, 0x05, 0x8B, 0x00,
+0x8A, 0x05, 0x8C, 0x00, 0x96, 0x05, 0x90, 0x00, 0x97, 0x05, 0x8E, 0x00, 0x96, 0x05, 0x8E, 0x00,
+0xC8, 0x05, 0x92, 0x00, 0x9A, 0x05, 0x94, 0x00, 0xB8, 0x05, 0x91, 0x00, 0x99, 0x05, 0xBA, 0x00,
+0x95, 0x05, 0x8E, 0x00, 0x9B, 0x05, 0x88, 0x00, 0x86, 0x05, 0x8B, 0x00, 0x8B, 0x05, 0x8B, 0x00,
+0x96, 0x05, 0x8F, 0x00, 0x99, 0x05, 0x8D, 0x00, 0x96, 0x05, 0x8E, 0x00, 0xC8, 0x05, 0x92, 0x00,
+0x9A, 0x05, 0x94, 0x00, 0xB9, 0x05, 0x90, 0x00, 0x99, 0x05, 0xBA, 0x00, 0x95, 0x05, 0x8D, 0x00,
+0x99, 0x05, 0x8E, 0x00, 0x82, 0x05, 0x8B, 0x00, 0x8C, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x8E, 0x00,
+0x9A, 0x05, 0x8D, 0x00, 0x96, 0x05, 0x8E, 0x00, 0xC8, 0x05, 0x92, 0x00, 0x9A, 0x05, 0x95, 0x00,
+0xB9, 0x05, 0x8F, 0x00, 0x99, 0x05, 0xBA, 0x00, 0x95, 0x05, 0x8D, 0x00, 0x97, 0x05, 0x9B, 0x00,
+0x8F, 0x05, 0x8B, 0x00, 0x96, 0x05, 0x8D, 0x00, 0x9A, 0x05, 0x8D, 0x00, 0x95, 0x05, 0x8F, 0x00,
+0xC7, 0x05, 0x93, 0x00, 0x9A, 0x05, 0x97, 0x00, 0xB8, 0x05, 0x8E, 0x00, 0x99, 0x05, 0xBA, 0x00,
+0x95, 0x05, 0x8C, 0x00, 0x97, 0x05, 0x9C, 0x00, 0x8F, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x8D, 0x00,
+0x9A, 0x05, 0x8D, 0x00, 0x95, 0x05, 0x8F, 0x00, 0xC6, 0x05, 0x94, 0x00, 0x9A, 0x05, 0x97, 0x00,
+0xB9, 0x05, 0x8D, 0x00, 0x99, 0x05, 0xBA, 0x00, 0x95, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x9D, 0x00,
+0x90, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x8C, 0x00, 0x9C, 0x05, 0x8B, 0x00, 0x95, 0x05, 0x90, 0x00,
+0xC5, 0x05, 0x95, 0x00, 0x9A, 0x05, 0x99, 0x00, 0xB8, 0x05, 0x8C, 0x00, 0x99, 0x05, 0xBA, 0x00,
+0x95, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x9C, 0x00, 0x92, 0x05, 0x8B, 0x00, 0x95, 0x05, 0x8C, 0x00,
+0x9C, 0x05, 0x8B, 0x00, 0x95, 0x05, 0x90, 0x00, 0xC5, 0x05, 0x95, 0x00, 0x9A, 0x05, 0x9A, 0x00,
+0xB7, 0x05, 0x8C, 0x00, 0x99, 0x05, 0xBA, 0x00, 0x95, 0x05, 0x8C, 0x00, 0x94, 0x05, 0x9C, 0x00,
+0x93, 0x05, 0x8B, 0x00, 0x95, 0x05, 0x8B, 0x00, 0x9D, 0x05, 0x8A, 0x00, 0x96, 0x05, 0x90, 0x00,
+0xC4, 0x05, 0x96, 0x00, 0x9A, 0x05, 0x9D, 0x00, 0xB5, 0x05, 0x8B, 0x00, 0x99, 0x05, 0xBA, 0x00,
+0x95, 0x05, 0x8B, 0x00, 0x94, 0x05, 0x9C, 0x00, 0x94, 0x05, 0x8B, 0x00, 0x96, 0x05, 0x8A, 0x00,
+0x9E, 0x05, 0x89, 0x00, 0x95, 0x05, 0x91, 0x00, 0xC3, 0x05, 0x97, 0x00, 0x9A, 0x05, 0x9F, 0x00,
+0xB3, 0x05, 0x8B, 0x00, 0x9A, 0x05, 0xB9, 0x00, 0x95, 0x05, 0x8B, 0x00, 0x94, 0x05, 0x9D, 0x00,
+0x93, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x8A, 0x00, 0x9E, 0x05, 0x89, 0x00, 0x95, 0x05, 0x91, 0x00,
+0xC1, 0x05, 0x99, 0x00, 0x9A, 0x05, 0xA0, 0x00, 0xB3, 0x05, 0x8A, 0x00, 0x9A, 0x05, 0xB9, 0x00,
+0x95, 0x05, 0x8B, 0x00, 0x93, 0x05, 0x9E, 0x00, 0x93, 0x05, 0x8C, 0x00, 0x96, 0x05, 0x88, 0x00,
+0x9F, 0x05, 0x89, 0x00, 0x95, 0x05, 0x91, 0x00, 0xC0, 0x05, 0x9A, 0x00, 0x9A, 0x05, 0xA5, 0x00,
+0xAE, 0x05, 0x8A, 0x00, 0x9A, 0x05, 0xB9, 0x00, 0x95, 0x05, 0x8B, 0x00, 0x93, 0x05, 0x9F, 0x00,
+0x93, 0x05, 0x8B, 0x00, 0x96, 0x05, 0x88, 0x00, 0x9F, 0x05, 0x88, 0x00, 0x96, 0x05, 0x91, 0x00,
+0xBE, 0x05, 0x9C, 0x00, 0x9A, 0x05, 0xAA, 0x00, 0xAA, 0x05, 0x89, 0x00, 0x9B, 0x05, 0xB8, 0x00,
+0x95, 0x05, 0x8B, 0x00, 0x92, 0x05, 0xA0, 0x00, 0x93, 0x05, 0x8B, 0x00, 0x96, 0x05, 0x88, 0x00,
+0xA0, 0x05, 0x87, 0x00, 0x95, 0x05, 0x92, 0x00, 0xBD, 0x05, 0x9D, 0x00, 0x9A, 0x05, 0xAC, 0x00,
+0xA8, 0x05, 0x89, 0x00, 0x9B, 0x05, 0xB8, 0x00, 0x95, 0x05, 0x8A, 0x00, 0x93, 0x05, 0xA1, 0x00,
+0x92, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x87, 0x00, 0xA1, 0x05, 0x87, 0x00, 0x95, 0x05, 0x92, 0x00,
+0xBB, 0x05, 0x9F, 0x00, 0x9A, 0x05, 0xB1, 0x00, 0xA3, 0x05, 0x89, 0x00, 0x9B, 0x05, 0xB8, 0x00,
+0x95, 0x05, 0x8A, 0x00, 0x93, 0x05, 0xA1, 0x00, 0x92, 0x05, 0x8C, 0x00, 0x95, 0x05, 0x87, 0x00,
+0xA2, 0x05, 0x86, 0x00, 0x94, 0x05, 0x93, 0x00, 0xBB, 0x05, 0x9F, 0x00, 0x9A, 0x05, 0xB4, 0x00,
+0xA0, 0x05, 0x8A, 0x00, 0x9A, 0x05, 0xB8, 0x00, 0x95, 0x05, 0x8A, 0x00, 0x93, 0x05, 0xA1, 0x00,
+0x92, 0x05, 0x8D, 0x00, 0x94, 0x05, 0x86, 0x00, 0xA3, 0x05, 0x85, 0x00, 0x95, 0x05, 0x93, 0x00,
+0xBB, 0x05, 0x9F, 0x00, 0x9A, 0x05, 0xB6, 0x00, 0x9E, 0x05, 0x8A, 0x00, 0x9B, 0x05, 0xB7, 0x00,
+0x94, 0x05, 0x8B, 0x00, 0x93, 0x05, 0xA1, 0x00, 0x92, 0x05, 0x8D, 0x00, 0x95, 0x05, 0x85, 0x00,
+0xA3, 0x05, 0x85, 0x00, 0x95, 0x05, 0x93, 0x00, 0xBC, 0x05, 0x9E, 0x00, 0x9A, 0x05, 0xB8, 0x00,
+0x9D, 0x05, 0x89, 0x00, 0x9B, 0x05, 0xB7, 0x00, 0x94, 0x05, 0x8B, 0x00, 0x93, 0x05, 0xA1, 0x00,
+0x92, 0x05, 0x8D, 0x00, 0x95, 0x05, 0x85, 0x00, 0xA3, 0x05, 0x84, 0x00, 0x96, 0x05, 0x93, 0x00,
+0xBD, 0x05, 0x9D, 0x00, 0x9A, 0x05, 0xB9, 0x00, 0x9C, 0x05, 0x89, 0x00, 0x9B, 0x05, 0xB7, 0x00,
+0x94, 0x05, 0x8B, 0x00, 0x93, 0x05, 0xA1, 0x00, 0x92, 0x05, 0x8D, 0x00, 0x95, 0x05, 0x84, 0x00,
+0xA4, 0x05, 0x84, 0x00, 0x95, 0x05, 0x94, 0x00, 0x99, 0x05, 0x89, 0x00, 0x9B, 0x05, 0x9D, 0x00,
+0x9A, 0x05, 0xB9, 0x00, 0x9C, 0x05, 0x8A, 0x00, 0x9B, 0x05, 0xB6, 0x00, 0x94, 0x05, 0x8C, 0x00,
+0x92, 0x05, 0xA1, 0x00, 0x92, 0x05, 0x8D, 0x00, 0x96, 0x05, 0x83, 0x00, 0x92, 0x05, 0x01, 0x00,
+0x92, 0x05, 0x83, 0x00, 0x95, 0x05, 0x94, 0x00, 0x99, 0x05, 0x89, 0x00, 0x9C, 0x05, 0x9C, 0x00,
+0x9A, 0x05, 0xBB, 0x00, 0x9A, 0x05, 0x8A, 0x00, 0x9C, 0x05, 0xB5, 0x00, 0x94, 0x05, 0x8C, 0x00,
+0x92, 0x05, 0xA1, 0x00, 0x92, 0x05, 0x8E, 0x00, 0x95, 0x05, 0x83, 0x00, 0x92, 0x05, 0x01, 0x00,
+0x92, 0x05, 0x83, 0x00, 0x95, 0x05, 0x94, 0x00, 0x99, 0x05, 0x8A, 0x00, 0x9C, 0x05, 0x9B, 0x00,
+0x9A, 0x05, 0xBB, 0x00, 0x9A, 0x05, 0x8A, 0x00, 0x9C, 0x05, 0xB5, 0x00, 0x94, 0x05, 0x8C, 0x00,
+0x92, 0x05, 0xA0, 0x00, 0x93, 0x05, 0x8E, 0x00, 0x95, 0x05, 0x82, 0x00, 0x92, 0x05, 0x82, 0x00,
+0x92, 0x05, 0x82, 0x00, 0x95, 0x05, 0x95, 0x00, 0x99, 0x05, 0x8B, 0x00, 0x9C, 0x05, 0x9A, 0x00,
+0x9A, 0x05, 0x94, 0x00, 0x01, 0x05, 0xA6, 0x00, 0x9A, 0x05, 0x8A, 0x00, 0x9D, 0x05, 0xB4, 0x00,
+0x94, 0x05, 0x8C, 0x00, 0x93, 0x05, 0x9F, 0x00, 0x93, 0x05, 0x8E, 0x00, 0x95, 0x05, 0x82, 0x00,
+0x92, 0x05, 0x83, 0x00, 0x91, 0x05, 0x82, 0x00, 0x95, 0x05, 0x95, 0x00, 0x99, 0x05, 0x8C, 0x00,
+0x9C, 0x05, 0x99, 0x00, 0x9A, 0x05, 0x93, 0x00, 0x84, 0x05, 0xA4, 0x00, 0x9A, 0x05, 0x8B, 0x00,
+0x9D, 0x05, 0xA5, 0x00, 0x83, 0x05, 0x8B, 0x00, 0x94, 0x05, 0x8C, 0x00, 0x93, 0x05, 0x9F, 0x00,
+0x92, 0x05, 0x8F, 0x00, 0x95, 0x05, 0x82, 0x00, 0x92, 0x05, 0x83, 0x00, 0x91, 0x05, 0x82, 0x00,
+0x94, 0x05, 0x96, 0x00, 0x99, 0x05, 0x8C, 0x00, 0x9C, 0x05, 0x99, 0x00, 0x9A, 0x05, 0x93, 0x00,
+0x85, 0x05, 0xA3, 0x00, 0x9A, 0x05, 0x8B, 0x00, 0x9E, 0x05, 0xA3, 0x00, 0x84, 0x05, 0x8B, 0x00,
+0x94, 0x05, 0x8D, 0x00, 0x92, 0x05, 0x9E, 0x00, 0x93, 0x05, 0x90, 0x00, 0xA8, 0x05, 0x83, 0x00,
+0x92, 0x05, 0x01, 0x00, 0x94, 0x05, 0x96, 0x00, 0x99, 0x05, 0x8D, 0x00, 0x9C, 0x05, 0x98, 0x00,
+0x9A, 0x05, 0x92, 0x00, 0x88, 0x05, 0xA1, 0x00, 0x9A, 0x05, 0x8B, 0x00, 0x9F, 0x05, 0xA0, 0x00,
+0x87, 0x05, 0x8A, 0x00, 0x94, 0x05, 0x8D, 0x00, 0x93, 0x05, 0x9D, 0x00, 0x93, 0x05, 0x90, 0x00,
+0xA7, 0x05, 0x84, 0x00, 0xA7, 0x05, 0x96, 0x00, 0x99, 0x05, 0x8E, 0x00, 0x9C, 0x05, 0x97, 0x00,
+0x9A, 0x05, 0x92, 0x00, 0x8A, 0x05, 0x9E, 0x00, 0x9A, 0x05, 0x8D, 0x00, 0xA0, 0x05, 0x9C, 0x00,
+0x8A, 0x05, 0x89, 0x00, 0x94, 0x05, 0x8D, 0x00, 0x93, 0x05, 0x9C, 0x00, 0x94, 0x05, 0x91, 0x00,
+0xA5, 0x05, 0x86, 0x00, 0xA6, 0x05, 0x96, 0x00, 0x99, 0x05, 0x8E, 0x00, 0x9C, 0x05, 0x97, 0x00,
+0x9A, 0x05, 0x91, 0x00, 0x8C, 0x05, 0x9C, 0x00, 0x9B, 0x05, 0x8D, 0x00, 0xA1, 0x05, 0x99, 0x00,
+0x8D, 0x05, 0x88, 0x00, 0x94, 0x05, 0x8D, 0x00, 0x94, 0x05, 0x9A, 0x00, 0x95, 0x05, 0x91, 0x00,
+0xA5, 0x05, 0x86, 0x00, 0xA5, 0x05, 0x97, 0x00, 0x99, 0x05, 0x8F, 0x00, 0x9D, 0x05, 0x95, 0x00,
+0x9A, 0x05, 0x91, 0x00, 0x8F, 0x05, 0x99, 0x00, 0x9B, 0x05, 0x8E, 0x00, 0xA2, 0x05, 0x95, 0x00,
+0x8F, 0x05, 0x88, 0x00, 0x94, 0x05, 0x8D, 0x00, 0x95, 0x05, 0x98, 0x00, 0x95, 0x05, 0x92, 0x00,
+0xA5, 0x05, 0x87, 0x00, 0xA3, 0x05, 0x98, 0x00, 0x99, 0x05, 0x90, 0x00, 0x9C, 0x05, 0x95, 0x00,
+0x9A, 0x05, 0x91, 0x00, 0x92, 0x05, 0x94, 0x00, 0x9D, 0x05, 0x8E, 0x00, 0xA5, 0x05, 0x8E, 0x00,
+0x94, 0x05, 0x87, 0x00, 0x94, 0x05, 0x8E, 0x00, 0x95, 0x05, 0x97, 0x00, 0x95, 0x05, 0x92, 0x00,
+0xA5, 0x05, 0x87, 0x00, 0xA3, 0x05, 0x98, 0x00, 0x99, 0x05, 0x91, 0x00, 0x9C, 0x05, 0x94, 0x00,
+0x9A, 0x05, 0x90, 0x00, 0x95, 0x05, 0x90, 0x00, 0x9F, 0x05, 0x8F, 0x00, 0xA8, 0x05, 0x86, 0x00,
+0x99, 0x05, 0x86, 0x00, 0x94, 0x05, 0x8E, 0x00, 0x96, 0x05, 0x94, 0x00, 0x96, 0x05, 0x94, 0x00,
+0xA3, 0x05, 0x88, 0x00, 0xA3, 0x05, 0x98, 0x00, 0x99, 0x05, 0x91, 0x00, 0x9C, 0x05, 0x94, 0x00,
+0x99, 0x05, 0x90, 0x00, 0xC4, 0x05, 0x90, 0x00, 0xC7, 0x05, 0x86, 0x00, 0x94, 0x05, 0x8E, 0x00,
+0x98, 0x05, 0x91, 0x00, 0x97, 0x05, 0x94, 0x00, 0xA3, 0x05, 0x88, 0x00, 0xA3, 0x05, 0x98, 0x00,
+0x99, 0x05, 0x92, 0x00, 0x9C, 0x05, 0x93, 0x00, 0x99, 0x05, 0x90, 0x00, 0xC4, 0x05, 0x90, 0x00,
+0xC8, 0x05, 0x85, 0x00, 0x94, 0x05, 0x8F, 0x00, 0x98, 0x05, 0x8E, 0x00, 0x99, 0x05, 0x94, 0x00,
+0xA3, 0x05, 0x88, 0x00, 0xA2, 0x05, 0x99, 0x00, 0x99, 0x05, 0x93, 0x00, 0x9C, 0x05, 0x92, 0x00,
+0x99, 0x05, 0x90, 0x00, 0xC3, 0x05, 0x92, 0x00, 0xC7, 0x05, 0x85, 0x00, 0x94, 0x05, 0x90, 0x00,
+0x9C, 0x05, 0x84, 0x00, 0x9D, 0x05, 0x95, 0x00, 0xA2, 0x05, 0x8A, 0x00, 0xA1, 0x05, 0x99, 0x00,
+0x99, 0x05, 0x94, 0x00, 0x9C, 0x05, 0x91, 0x00, 0x99, 0x05, 0x90, 0x00, 0xC3, 0x05, 0x93, 0x00,
+0xC7, 0x05, 0x84, 0x00, 0x94, 0x05, 0x90, 0x00, 0xBD, 0x05, 0x95, 0x00, 0xA2, 0x05, 0x8A, 0x00,
+0xA1, 0x05, 0x99, 0x00, 0x98, 0x05, 0x95, 0x00, 0x9C, 0x05, 0x91, 0x00, 0x99, 0x05, 0x8F, 0x00,
+0xC3, 0x05, 0x94, 0x00, 0xC8, 0x05, 0x83, 0x00, 0x94, 0x05, 0x90, 0x00, 0xBC, 0x05, 0x97, 0x00,
+0xA0, 0x05, 0x8B, 0x00, 0xA0, 0x05, 0x9A, 0x00, 0x99, 0x05, 0x95, 0x00, 0x9B, 0x05, 0x91, 0x00,
+0x99, 0x05, 0x8F, 0x00, 0xC3, 0x05, 0x95, 0x00, 0xC7, 0x05, 0x83, 0x00, 0x94, 0x05, 0x91, 0x00,
+0xBA, 0x05, 0x98, 0x00, 0xA0, 0x05, 0x8B, 0x00, 0xA0, 0x05, 0x9A, 0x00, 0x98, 0x05, 0x97, 0x00,
+0x9C, 0x05, 0x8F, 0x00, 0x99, 0x05, 0x8E, 0x00, 0xC3, 0x05, 0x97, 0x00, 0xC7, 0x05, 0x82, 0x00,
+0x94, 0x05, 0x91, 0x00, 0xBA, 0x05, 0x99, 0x00, 0x9F, 0x05, 0x8C, 0x00, 0x9E, 0x05, 0x9B, 0x00,
+0x98, 0x05, 0x97, 0x00, 0x9C, 0x05, 0x8F, 0x00, 0x99, 0x05, 0x8E, 0x00, 0xC2, 0x05, 0x99, 0x00,
+0xC6, 0x05, 0x82, 0x00, 0x94, 0x05, 0x93, 0x00, 0xB7, 0x05, 0x9A, 0x00, 0x9E, 0x05, 0x8D, 0x00,
+0x9E, 0x05, 0x9B, 0x00, 0x98, 0x05, 0x98, 0x00, 0x9C, 0x05, 0x8E, 0x00, 0x99, 0x05, 0x8E, 0x00,
+0xC1, 0x05, 0x9B, 0x00, 0xC5, 0x05, 0x82, 0x00, 0x94, 0x05, 0x93, 0x00, 0xB6, 0x05, 0x9B, 0x00,
+0x9E, 0x05, 0x8E, 0x00, 0x9D, 0x05, 0x9B, 0x00, 0x98, 0x05, 0x99, 0x00, 0x9B, 0x05, 0x8E, 0x00,
+0x99, 0x05, 0x8E, 0x00, 0xC0, 0x05, 0x9D, 0x00, 0xC4, 0x05, 0x82, 0x00, 0x94, 0x05, 0x94, 0x00,
+0xB4, 0x05, 0x9C, 0x00, 0x9E, 0x05, 0x8E, 0x00, 0x9C, 0x05, 0x9C, 0x00, 0x98, 0x05, 0x99, 0x00,
+0x9C, 0x05, 0x8D, 0x00, 0x99, 0x05, 0x8E, 0x00, 0xC0, 0x05, 0x9D, 0x00, 0xC4, 0x05, 0x82, 0x00,
+0x94, 0x05, 0x95, 0x00, 0xB2, 0x05, 0x9E, 0x00, 0x9C, 0x05, 0x8F, 0x00, 0x9C, 0x05, 0x9C, 0x00,
+0x98, 0x05, 0x9A, 0x00, 0x9C, 0x05, 0x8C, 0x00, 0x99, 0x05, 0x8F, 0x00, 0xBD, 0x05, 0xA0, 0x00,
+0xC2, 0x05, 0x83, 0x00, 0x94, 0x05, 0x96, 0x00, 0xB0, 0x05, 0x9F, 0x00, 0x9C, 0x05, 0x8F, 0x00,
+0x9C, 0x05, 0x9C, 0x00, 0x98, 0x05, 0x9A, 0x00, 0x9C, 0x05, 0x8C, 0x00, 0x99, 0x05, 0x90, 0x00,
+0xBB, 0x05, 0xA3, 0x00, 0xBF, 0x05, 0x84, 0x00, 0x94, 0x05, 0x97, 0x00, 0xAE, 0x05, 0xA1, 0x00,
+0x9A, 0x05, 0x91, 0x00, 0x9B, 0x05, 0x9C, 0x00, 0x98, 0x05, 0x9B, 0x00, 0x9B, 0x05, 0x8C, 0x00,
+0x99, 0x05, 0x92, 0x00, 0xB8, 0x05, 0xA5, 0x00, 0xBC, 0x05, 0x86, 0x00, 0x94, 0x05, 0x99, 0x00,
+0xAA, 0x05, 0xA3, 0x00, 0x9A, 0x05, 0x91, 0x00, 0x9A, 0x05, 0x9D, 0x00, 0x98, 0x05, 0x9C, 0x00,
+0x9A, 0x05, 0x8C, 0x00, 0x99, 0x05, 0x95, 0x00, 0xB3, 0x05, 0xA9, 0x00, 0xB9, 0x05, 0x87, 0x00,
+0x94, 0x05, 0x99, 0x00, 0xAA, 0x05, 0xA3, 0x00, 0x99, 0x05, 0x92, 0x00, 0x99, 0x05, 0x9E, 0x00,
+0x98, 0x05, 0x9D, 0x00, 0x97, 0x05, 0x8E, 0x00, 0x99, 0x05, 0x96, 0x00, 0xB1, 0x05, 0xAA, 0x00,
+0xB8, 0x05, 0x88, 0x00, 0x94, 0x05, 0x9B, 0x00, 0xA6, 0x05, 0xA5, 0x00, 0x99, 0x05, 0x92, 0x00,
+0x99, 0x05, 0x9E, 0x00, 0x98, 0x05, 0x9D, 0x00, 0x95, 0x05, 0x90, 0x00, 0x99, 0x05, 0x99, 0x00,
+0xAC, 0x05, 0xAE, 0x00, 0xB3, 0x05, 0x8B, 0x00, 0x94, 0x05, 0x9E, 0x00, 0xA1, 0x05, 0xA8, 0x00,
+0x98, 0x05, 0x93, 0x00, 0x98, 0x05, 0x9E, 0x00, 0x98, 0x05, 0x9E, 0x00, 0x92, 0x05, 0x92, 0x00,
+0x99, 0x05, 0x9C, 0x00, 0xA6, 0x05, 0xB3, 0x00, 0xAF, 0x05, 0x8D, 0x00, 0x94, 0x05, 0x9F, 0x00,
+0x9E, 0x05, 0xAA, 0x00, 0x97, 0x05, 0x94, 0x00, 0x98, 0x05, 0x9E, 0x00, 0x98, 0x05, 0x9F, 0x00,
+0x8F, 0x05, 0x94, 0x00, 0x99, 0x05, 0x9F, 0x00, 0xA1, 0x05, 0xB7, 0x00, 0xAC, 0x05, 0x8E, 0x00,
+0x94, 0x05, 0xA2, 0x00, 0x98, 0x05, 0xAD, 0x00, 0x97, 0x05, 0x95, 0x00, 0x96, 0x05, 0x9F, 0x00,
+0x98, 0x05, 0x9F, 0x00, 0x8C, 0x05, 0x97, 0x00, 0x99, 0x05, 0xA4, 0x00, 0x97, 0x05, 0xBF, 0x00,
+0xA6, 0x05, 0x94, 0x00, 0x91, 0x05, 0xA7, 0x00, 0x8E, 0x05, 0xB6, 0x00, 0x92, 0x05, 0x9A, 0x00,
+0x92, 0x05, 0xD7, 0x00, 0x88, 0x05, 0x9C, 0x00, 0x96, 0x05, 0xFE, 0x00, 0x9E, 0x05, 0xD4, 0x00,
+0x87, 0x05, 0xC3, 0x00, 0x87, 0x05, 0xA5, 0x00, 0x86, 0x05, 0xDA, 0x00, 0x86, 0x05, 0xA6, 0x00,
+0x88, 0x05, 0xFF, 0x00, 0x88, 0x00, 0x99, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xF1, 0x00,
+0x8B, 0x05, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
+0xFF, 0x00, 0xE3, 0x00, 0x86, 0x05, 0x9B, 0x00, 0x89, 0x05, 0x9A, 0x00, 0x8B, 0x05, 0x97, 0x00,
+0x84, 0x05, 0x85, 0x00, 0x85, 0x05, 0xAF, 0x00, 0x8C, 0x05, 0x99, 0x00, 0x87, 0x05, 0xB3, 0x00,
+0x8C, 0x05, 0x96, 0x00, 0x84, 0x05, 0x86, 0x00, 0x83, 0x05, 0x98, 0x00, 0x8A, 0x05, 0xB5, 0x00,
+0x86, 0x05, 0x9D, 0x00, 0x86, 0x05, 0x9B, 0x00, 0x89, 0x05, 0x9A, 0x00, 0x8B, 0x05, 0x85, 0x00,
+0x89, 0x05, 0x99, 0x00, 0x8B, 0x05, 0x98, 0x00, 0x8B, 0x05, 0x97, 0x00, 0x85, 0x05, 0x84, 0x00,
+0x85, 0x05, 0xAF, 0x00, 0x8C, 0x05, 0x98, 0x00, 0x89, 0x05, 0xB2, 0x00, 0x8C, 0x05, 0x96, 0x00,
+0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x97, 0x00, 0x8C, 0x05, 0xB3, 0x00, 0x88, 0x05, 0x9A, 0x00,
+0x89, 0x05, 0x9A, 0x00, 0x8A, 0x05, 0x99, 0x00, 0x8B, 0x05, 0x83, 0x00, 0x8C, 0x05, 0x98, 0x00,
+0x8C, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x97, 0x00, 0x85, 0x05, 0x84, 0x00, 0x85, 0x05, 0xAF, 0x00,
+0x8C, 0x05, 0x97, 0x00, 0x8C, 0x05, 0xB0, 0x00, 0x8C, 0x05, 0x96, 0x00, 0x85, 0x05, 0x85, 0x00,
+0x83, 0x05, 0x98, 0x00, 0x8B, 0x05, 0xB1, 0x00, 0x8B, 0x05, 0x97, 0x00, 0x8D, 0x05, 0x98, 0x00,
+0x8C, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x82, 0x00, 0x87, 0x05, 0x01, 0x00, 0x86, 0x05, 0x97, 0x00,
+0x8D, 0x05, 0x96, 0x00, 0x8B, 0x05, 0x97, 0x00, 0x86, 0x05, 0x83, 0x00, 0x85, 0x05, 0xAF, 0x00,
+0x8C, 0x05, 0x96, 0x00, 0x86, 0x05, 0x01, 0x00, 0x87, 0x05, 0xAF, 0x00, 0x8C, 0x05, 0x96, 0x00,
+0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x98, 0x00, 0x8B, 0x05, 0xB0, 0x00, 0x8B, 0x05, 0x97, 0x00,
+0x87, 0x05, 0x01, 0x00, 0x86, 0x05, 0x98, 0x00, 0x8C, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x82, 0x00,
+0x85, 0x05, 0x84, 0x00, 0x85, 0x05, 0x97, 0x00, 0x85, 0x05, 0x83, 0x00, 0x85, 0x05, 0x96, 0x00,
+0x84, 0x05, 0x9E, 0x00, 0x87, 0x05, 0x82, 0x00, 0x85, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00,
+0x85, 0x05, 0x84, 0x00, 0x85, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x85, 0x05, 0x85, 0x00,
+0x83, 0x05, 0x98, 0x00, 0x84, 0x05, 0xB7, 0x00, 0x85, 0x05, 0x84, 0x00, 0x82, 0x05, 0x97, 0x00,
+0x85, 0x05, 0x85, 0x00, 0x85, 0x05, 0x97, 0x00, 0x84, 0x05, 0x84, 0x00, 0x84, 0x05, 0x97, 0x00,
+0x84, 0x05, 0x89, 0x00, 0x84, 0x05, 0x87, 0x00, 0x84, 0x05, 0x96, 0x00, 0x85, 0x05, 0x84, 0x00,
+0x84, 0x05, 0x96, 0x00, 0x84, 0x05, 0x9E, 0x00, 0x88, 0x05, 0x01, 0x00, 0x85, 0x05, 0xB3, 0x00,
+0x84, 0x05, 0x99, 0x00, 0x84, 0x05, 0x87, 0x00, 0x84, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00,
+0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x98, 0x00, 0x84, 0x05, 0xB7, 0x00, 0x84, 0x05, 0x9E, 0x00,
+0x84, 0x05, 0x87, 0x00, 0x84, 0x05, 0x97, 0x00, 0x84, 0x05, 0x85, 0x00, 0x83, 0x05, 0x97, 0x00,
+0x84, 0x05, 0x88, 0x00, 0x84, 0x05, 0x88, 0x00, 0x84, 0x05, 0x96, 0x00, 0x85, 0x05, 0x84, 0x00,
+0x84, 0x05, 0x96, 0x00, 0x8B, 0x05, 0x97, 0x00, 0x8E, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x99, 0x00,
+0x84, 0x05, 0x88, 0x00, 0x84, 0x05, 0xB2, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x8D, 0x05, 0x98, 0x00,
+0x8A, 0x05, 0xB1, 0x00, 0x83, 0x05, 0x9F, 0x00, 0x84, 0x05, 0x87, 0x00, 0x85, 0x05, 0x96, 0x00,
+0x84, 0x05, 0x84, 0x00, 0x84, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x01, 0x00, 0x84, 0x05, 0x88, 0x00,
+0x84, 0x05, 0x96, 0x00, 0x85, 0x05, 0x83, 0x00, 0x85, 0x05, 0x96, 0x00, 0x8B, 0x05, 0x97, 0x00,
+0x8E, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x99, 0x00, 0x84, 0x05, 0x88, 0x00, 0x84, 0x05, 0xB2, 0x00,
+0x84, 0x05, 0x9A, 0x00, 0x8D, 0x05, 0x98, 0x00, 0x8A, 0x05, 0xB1, 0x00, 0x83, 0x05, 0x9F, 0x00,
+0x84, 0x05, 0x87, 0x00, 0x85, 0x05, 0x96, 0x00, 0x8C, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x01, 0x00,
+0x84, 0x05, 0x88, 0x00, 0x84, 0x05, 0x96, 0x00, 0x8C, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x97, 0x00,
+0x85, 0x05, 0x01, 0x00, 0x88, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x99, 0x00, 0x84, 0x05, 0x88, 0x00,
+0x84, 0x05, 0xB2, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x8D, 0x05, 0x98, 0x00, 0x8A, 0x05, 0xB1, 0x00,
+0x83, 0x05, 0x9F, 0x00, 0x84, 0x05, 0x87, 0x00, 0x85, 0x05, 0x96, 0x00, 0x8B, 0x05, 0x98, 0x00,
+0x8B, 0x05, 0x01, 0x00, 0x84, 0x05, 0x88, 0x00, 0x84, 0x05, 0x96, 0x00, 0x8C, 0x05, 0x97, 0x00,
+0x84, 0x05, 0x9E, 0x00, 0x85, 0x05, 0x01, 0x00, 0x88, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x99, 0x00,
+0x84, 0x05, 0x87, 0x00, 0x84, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x8D, 0x05, 0x98, 0x00,
+0x84, 0x05, 0xB7, 0x00, 0x84, 0x05, 0x9E, 0x00, 0x84, 0x05, 0x87, 0x00, 0x85, 0x05, 0x96, 0x00,
+0x8A, 0x05, 0x99, 0x00, 0x85, 0x05, 0x88, 0x00, 0x84, 0x05, 0x86, 0x00, 0x84, 0x05, 0x97, 0x00,
+0x8A, 0x05, 0x99, 0x00, 0x84, 0x05, 0x9E, 0x00, 0x85, 0x05, 0x82, 0x00, 0x87, 0x05, 0xB3, 0x00,
+0x84, 0x05, 0x9A, 0x00, 0x84, 0x05, 0x86, 0x00, 0x84, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00,
+0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x98, 0x00, 0x84, 0x05, 0xB7, 0x00, 0x84, 0x05, 0x86, 0x00,
+0x01, 0x05, 0x97, 0x00, 0x85, 0x05, 0x85, 0x00, 0x85, 0x05, 0x97, 0x00, 0x84, 0x05, 0x82, 0x00,
+0x84, 0x05, 0x99, 0x00, 0x84, 0x05, 0x89, 0x00, 0x8E, 0x05, 0x97, 0x00, 0x85, 0x05, 0x9E, 0x00,
+0x8C, 0x05, 0x96, 0x00, 0x85, 0x05, 0x83, 0x00, 0x86, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00,
+0x8E, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x98, 0x00,
+0x8B, 0x05, 0xB0, 0x00, 0x8C, 0x05, 0x97, 0x00, 0x8D, 0x05, 0x98, 0x00, 0x84, 0x05, 0x82, 0x00,
+0x85, 0x05, 0x98, 0x00, 0x8B, 0x05, 0x83, 0x00, 0x8D, 0x05, 0x97, 0x00, 0x85, 0x05, 0x9E, 0x00,
+0x8C, 0x05, 0x96, 0x00, 0x85, 0x05, 0x83, 0x00, 0x86, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9A, 0x00,
+0x8D, 0x05, 0xB4, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x98, 0x00,
+0x8B, 0x05, 0xB1, 0x00, 0x8B, 0x05, 0x97, 0x00, 0x8D, 0x05, 0x98, 0x00, 0x84, 0x05, 0x83, 0x00,
+0x85, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x84, 0x00, 0x8A, 0x05, 0x99, 0x00, 0x85, 0x05, 0x9E, 0x00,
+0x8C, 0x05, 0x96, 0x00, 0x85, 0x05, 0x84, 0x00, 0x85, 0x05, 0xB3, 0x00, 0x84, 0x05, 0x9C, 0x00,
+0x8A, 0x05, 0xB5, 0x00, 0x84, 0x05, 0x9A, 0x00, 0x85, 0x05, 0x85, 0x00, 0x83, 0x05, 0x98, 0x00,
+0x8B, 0x05, 0xB2, 0x00, 0x8A, 0x05, 0x98, 0x00, 0x8A, 0x05, 0x9A, 0x00, 0x84, 0x05, 0x84, 0x00,
+0x84, 0x05, 0x97, 0x00, 0x8B, 0x05, 0x86, 0x00, 0x86, 0x05, 0x9C, 0x00, 0x83, 0x05, 0xA0, 0x00,
+0x8A, 0x05, 0x98, 0x00, 0x83, 0x05, 0x87, 0x00, 0x82, 0x05, 0xB4, 0x00, 0x84, 0x05, 0x9E, 0x00,
+0x86, 0x05, 0xB8, 0x00, 0x83, 0x05, 0x9A, 0x00, 0x84, 0x05, 0x86, 0x00, 0x83, 0x05, 0x98, 0x00,
+0x8A, 0x05, 0xB5, 0x00, 0x86, 0x05, 0x9D, 0x00, 0x85, 0x05, 0x9D, 0x00, 0x83, 0x05, 0x85, 0x00,
+0x83, 0x05, 0x98, 0x00, 0x8A, 0x05, 0x01, 0x00,
diff --git a/drivers/video/fbdev/lowrisc_mini_font.h b/drivers/video/fbdev/lowrisc_mini_font.h
new file mode 100644
index 000000000..fff234be7
--- /dev/null
+++ b/drivers/video/fbdev/lowrisc_mini_font.h
@@ -0,0 +1,190 @@
+/*--     --*/
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+/*-- !  --*/
+0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x20,
+/*-- "  --*/
+0x28,0x50,0x50,0x00,0x00,0x00,0x00,0x00,
+/*-- #  --*/
+0x28,0x28,0xFC,0x28,0x50,0xFC,0x50,0x50,
+/*-- $  --*/
+0x78,0xA8,0xA0,0x60,0x30,0x28,0xA8,0xF0,
+/*-- %  --*/
+0x48,0xA8,0xB0,0x50,0x28,0x34,0x54,0x48,
+/*-- &  --*/
+0x20,0x50,0x50,0x78,0xA8,0xA8,0x90,0x6C,
+/*-- '  --*/
+0x40,0x40,0x80,0x00,0x00,0x00,0x00,0x00,
+/*-- (  --*/
+0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x08,
+/*-- )  --*/
+0x20,0x10,0x10,0x10,0x10,0x10,0x10,0x20,
+/*-- *  --*/
+0x00,0x20,0xA8,0x70,0x70,0xA8,0x20,0x00,
+/*-- +  --*/
+0x20,0x20,0x20,0xF8,0x20,0x20,0x20,0x00,
+/*-- ,  --*/
+0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x80,
+/*-- -  --*/
+0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,
+/*-- .  --*/
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
+/*-- /  --*/
+0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x80,
+/*-- 0  --*/
+0x70,0x88,0x88,0x88,0x88,0x88,0x88,0x70,
+/*-- 1  --*/
+0x20,0x60,0x20,0x20,0x20,0x20,0x20,0x70,
+/*-- 2  --*/
+0x70,0x88,0x88,0x10,0x20,0x40,0x80,0xF8,
+/*-- 3  --*/
+0x70,0x88,0x08,0x30,0x08,0x08,0x88,0x70,
+/*-- 4  --*/
+0x10,0x30,0x50,0x50,0x90,0x78,0x10,0x18,
+/*-- 5  --*/
+0xF8,0x80,0x80,0xF0,0x08,0x08,0x88,0x70,
+/*-- 6  --*/
+0x70,0x90,0x80,0xF0,0x88,0x88,0x88,0x70,
+/*-- 7  --*/
+0xF8,0x90,0x10,0x20,0x20,0x20,0x20,0x20,
+/*-- 8  --*/
+0x70,0x88,0x88,0x70,0x88,0x88,0x88,0x70,
+/*-- 9  --*/
+0x70,0x88,0x88,0x88,0x78,0x08,0x48,0x70,
+/*-- :  --*/
+0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x20,
+/*-- ;  --*/
+0x00,0x00,0x20,0x00,0x00,0x00,0x20,0x20,
+/*-- <  --*/
+0x04,0x08,0x10,0x20,0x40,0x20,0x10,0x08,
+/*-- =  --*/
+0x00,0x00,0xF8,0x00,0x00,0xF8,0x00,0x00,
+/*-- >  --*/
+0x40,0x20,0x10,0x08,0x04,0x08,0x10,0x20,
+/*-- ?  --*/
+0x70,0x88,0x88,0x10,0x20,0x20,0x00,0x20,
+/*-- @  --*/
+0x70,0x88,0x98,0xA8,0xA8,0xB8,0x80,0x78,
+/*-- A  --*/
+0x20,0x20,0x30,0x50,0x50,0x78,0x48,0xCC,
+/*-- B  --*/
+0xF0,0x48,0x48,0x70,0x48,0x48,0x48,0xF0,
+/*-- C  --*/
+0x78,0x88,0x80,0x80,0x80,0x80,0x88,0x70,
+/*-- D  --*/
+0xF0,0x48,0x48,0x48,0x48,0x48,0x48,0xF0,
+/*-- E  --*/
+0xF8,0x48,0x50,0x70,0x50,0x40,0x48,0xF8,
+/*-- F  --*/
+0xF8,0x48,0x50,0x70,0x50,0x40,0x40,0xE0,
+/*-- G  --*/
+0x38,0x48,0x80,0x80,0x9C,0x88,0x48,0x30,
+/*-- H  --*/
+0xCC,0x48,0x48,0x78,0x48,0x48,0x48,0xCC,
+/*-- I  --*/
+0xF8,0x20,0x20,0x20,0x20,0x20,0x20,0xF8,
+/*-- J  --*/
+0x7C,0x10,0x10,0x10,0x10,0x10,0x90,0xE0,
+/*-- K  --*/
+0xEC,0x48,0x50,0x60,0x50,0x50,0x48,0xEC,
+/*-- L  --*/
+0xE0,0x40,0x40,0x40,0x40,0x40,0x44,0xFC,
+/*-- M  --*/
+0xD8,0xD8,0xD8,0xD8,0xA8,0xA8,0xA8,0xA8,
+/*-- N  --*/
+0xDC,0x48,0x68,0x68,0x58,0x58,0x48,0xE8,
+/*-- O  --*/
+0x70,0x88,0x88,0x88,0x88,0x88,0x88,0x70,
+/*-- P  --*/
+0xF0,0x48,0x48,0x70,0x40,0x40,0x40,0xE0,
+/*-- Q  --*/
+0x70,0x88,0x88,0x88,0xE8,0x98,0x70,0x18,
+/*-- R  --*/
+0xF0,0x48,0x48,0x70,0x50,0x48,0x48,0xEC,
+/*-- S  --*/
+0x78,0x88,0x80,0x60,0x10,0x08,0x88,0xF0,
+/*-- T  --*/
+0xF8,0xA8,0x20,0x20,0x20,0x20,0x20,0x70,
+/*-- U  --*/
+0xCC,0x48,0x48,0x48,0x48,0x48,0x48,0x30,
+/*-- V  --*/
+0xCC,0x48,0x48,0x50,0x50,0x30,0x20,0x20,
+/*-- W  --*/
+0xA8,0xA8,0xA8,0x70,0x50,0x50,0x50,0x50,
+/*-- X  --*/
+0xD8,0x50,0x50,0x20,0x20,0x50,0x50,0xD8,
+/*-- Y  --*/
+0xD8,0x50,0x50,0x20,0x20,0x20,0x20,0x70,
+/*-- Z  --*/
+0xF8,0x90,0x10,0x20,0x20,0x40,0x48,0xF8,
+/*-- [  --*/
+0x38,0x20,0x20,0x20,0x20,0x20,0x20,0x38,
+/*-- \  --*/
+0x40,0x40,0x20,0x20,0x10,0x10,0x10,0x08,
+/*-- ]  --*/
+0x70,0x10,0x10,0x10,0x10,0x10,0x10,0x70,
+/*-- ^  --*/
+0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00,
+/*-- _  --*/
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,
+/*-- `  --*/
+0x20,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
+/*-- a  --*/
+0x00,0x00,0x00,0x30,0x48,0x38,0x48,0x3C,
+/*-- b  --*/
+0xC0,0x40,0x40,0x70,0x48,0x48,0x48,0x70,
+/*-- c  --*/
+0x00,0x00,0x00,0x38,0x48,0x40,0x40,0x38,
+/*-- d  --*/
+0x18,0x08,0x08,0x38,0x48,0x48,0x48,0x3C,
+/*-- e  --*/
+0x00,0x00,0x00,0x30,0x48,0x78,0x40,0x38,
+/*-- f  --*/
+0x1C,0x20,0x20,0x78,0x20,0x20,0x20,0x78,
+/*-- g  --*/
+0x00,0x3C,0x48,0x30,0x40,0x78,0x44,0x38,
+/*-- h  --*/
+0xC0,0x40,0x40,0x70,0x48,0x48,0x48,0xEC,
+/*-- i  --*/
+0x20,0x00,0x00,0x60,0x20,0x20,0x20,0x70,
+/*-- j  --*/
+0x00,0x30,0x00,0x10,0x10,0x10,0x10,0xE0,
+/*-- k  --*/
+0xC0,0x40,0x40,0x5C,0x50,0x70,0x48,0xEC,
+/*-- l  --*/
+0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0xF8,
+/*-- m  --*/
+0x00,0x00,0x00,0xF0,0xA8,0xA8,0xA8,0xA8,
+/*-- n  --*/
+0x00,0x00,0x00,0xF0,0x48,0x48,0x48,0xEC,
+/*-- o  --*/
+0x00,0x00,0x00,0x30,0x48,0x48,0x48,0x30,
+/*-- p  --*/
+0x00,0x00,0xF0,0x48,0x48,0x70,0x40,0xE0,
+/*-- q  --*/
+0x00,0x00,0x38,0x48,0x48,0x38,0x08,0x1C,
+/*-- r  --*/
+0x00,0x00,0x00,0xD8,0x60,0x40,0x40,0xE0,
+/*-- s  --*/
+0x00,0x00,0x00,0x78,0x40,0x30,0x08,0x78,
+/*-- t  --*/
+0x00,0x20,0x20,0x70,0x20,0x20,0x20,0x18,
+/*-- u  --*/
+0x00,0x00,0x00,0xD8,0x48,0x48,0x48,0x3C,
+/*-- v  --*/
+0x00,0x00,0x00,0xEC,0x48,0x50,0x30,0x20,
+/*-- w  --*/
+0x00,0x00,0x00,0xA8,0xA8,0x70,0x50,0x50,
+/*-- x  --*/
+0x00,0x00,0x00,0xD8,0x50,0x20,0x50,0xD8,
+/*-- y  --*/
+0x00,0x00,0xEC,0x48,0x50,0x30,0x20,0xC0,
+/*-- z  --*/
+0x00,0x00,0x00,0x78,0x10,0x20,0x20,0x78,
+/*-- {  --*/
+0x18,0x10,0x10,0x20,0x10,0x10,0x10,0x18,
+/*-- |  --*/
+0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
+/*-- }  --*/
+0x60,0x20,0x20,0x10,0x20,0x20,0x20,0x60,
+/*-- ~  --*/
+0x40,0xA4,0x18,0x00,0x00,0x00,0x00,0x00,
diff --git a/drivers/video/fbdev/lowrisc_palette.h b/drivers/video/fbdev/lowrisc_palette.h
new file mode 100644
index 000000000..59b0a9a71
--- /dev/null
+++ b/drivers/video/fbdev/lowrisc_palette.h
@@ -0,0 +1,256 @@
+  0x0,
+  0xffffff,
+  0x550000,
+  0xaa0000,
+  0xff0000,
+  0x5500,
+  0x555500,
+  0xaa5500,
+  0xff5500,
+  0xaa00,
+  0x55aa00,
+  0xaaaa00,
+  0xffaa00,
+  0xff00,
+  0x55ff00,
+  0xaaff00,
+  0xffff00,
+  0x55,
+  0x550055,
+  0xaa0055,
+  0xff0055,
+  0x5555,
+  0x555555,
+  0xaa5555,
+  0xff5555,
+  0xaa55,
+  0x55aa55,
+  0xaaaa55,
+  0xffaa55,
+  0xff55,
+  0x55ff55,
+  0xaaff55,
+  0xffff55,
+  0xaa,
+  0x5500aa,
+  0xaa00aa,
+  0xff00aa,
+  0x55aa,
+  0x5555aa,
+  0xaa55aa,
+  0xff55aa,
+  0xaaaa,
+  0x55aaaa,
+  0xaaaaaa,
+  0xffaaaa,
+  0xffaa,
+  0x55ffaa,
+  0xaaffaa,
+  0xffffaa,
+  0xff,
+  0x5500ff,
+  0xaa00ff,
+  0xff00ff,
+  0x55ff,
+  0x5555ff,
+  0xaa55ff,
+  0xff55ff,
+  0xaaff,
+  0x55aaff,
+  0xaaaaff,
+  0xffaaff,
+  0xffff,
+  0x55ffff,
+  0xaaffff,
+  0x151515,
+  0x2a2a2a,
+  0x404040,
+  0x6a6a6a,
+  0x808080,
+  0x959595,
+  0xbfbfbf,
+  0xd5d5d5,
+  0xeaeaea,
+  0xbebebe,
+  0x908070,
+  0x99aa22,
+  0xd9d9d9,
+  0xb3b3b3,
+  0x53ff,
+  0x5eff,
+  0x48ff,
+  0x42ff,
+  0x40ff,
+  0x4bff,
+  0x52ff,
+  0x54ff,
+  0x35ff,
+  0x51ff,
+  0x5cff,
+  0x30ff,
+  0x45ff,
+  0x20ff,
+  0x3ff,
+  0x16ff,
+  0x5dff,
+  0x38ff,
+  0x2ff,
+  0x9ff,
+  0x2bff,
+  0x33ff,
+  0x1aff,
+  0x13ff,
+  0x12ff,
+  0x57ff,
+  0xba7745,
+  0x784e87,
+  0x777588,
+  0x777e88,
+  0x777988,
+  0x785087,
+  0xa96c56,
+  0xa1705e,
+  0x774e88,
+  0x777688,
+  0x835b7c,
+  0x865679,
+  0xfe8d00,
+  0xf31200,
+  0xf20b00,
+  0xfe8f00,
+  0xfa6c00,
+  0xf10000,
+  0xf10100,
+  0xf42000,
+  0xf64000,
+  0xf05909,
+  0xe85811,
+  0xe85911,
+  0xf95800,
+  0xf41d00,
+  0xf42300,
+  0xfa5b00,
+  0xfa6000,
+  0xeb580e,
+  0xf35106,
+  0xf53300,
+  0xf20e00,
+  0xfa6e00,
+  0xff9200,
+  0xf41f00,
+  0xf20f00,
+  0xec510c,
+  0xc96a32,
+  0x83657a,
+  0x3462ca,
+  0x35ffc,
+  0x58ff,
+  0x8ff,
+  0xb06f4,
+  0xfb7c00,
+  0xf31300,
+  0xfb7e00,
+  0x18ff,
+  0xc59f3,
+  0x5261ab,
+  0xad4e4f,
+  0xe45c17,
+  0xf53600,
+  0xf42200,
+  0xfd9500,
+  0xfd8400,
+  0xf10400,
+  0xf85100,
+  0xc75a34,
+  0x1915e6,
+  0x59ff,
+  0x46ff,
+  0x1ff,
+  0xb96e44,
+  0xf63400,
+  0xf53200,
+  0x22ff,
+  0xfa6f00,
+  0xf52d00,
+  0xfd8600,
+  0xf74600,
+  0xf31500,
+  0xfc7600,
+  0x4ff,
+  0x23ff,
+  0x29ff,
+  0x613e9e,
+  0xf63900,
+  0x2aff,
+  0x43ff,
+  0xfb7100,
+  0xf95e00,
+  0xf74d00,
+  0xfe8c00,
+  0xf20800,
+  0xf31d00,
+  0xfb7d00,
+  0x41ff,
+  0x5bff,
+  0x5c42a3,
+  0x664c99,
+  0x11ff,
+  0xfb7200,
+  0xf20a00,
+  0xfc6e00,
+  0xf31700,
+  0xfb7f00,
+  0x6ff,
+  0x56ff,
+  0x5a6aa5,
+  0x5a3ba5,
+  0x4fff,
+  0xfb7600,
+  0xfa7600,
+  0xff9300,
+  0xfc7d00,
+  0x1cff,
+  0x5a76a5,
+  0x5a5da5,
+  0xfb6f00,
+  0xf52c00,
+  0xfd8a00,
+  0xf96b00,
+  0x3aff,
+  0x50ff,
+  0xfb7b00,
+  0xfd8b00,
+  0x5a75a5,
+  0x65559a,
+  0x5b3aa4,
+  0x4dff,
+  0x7f5080,
+  0xfff,
+  0x85547a,
+  0x5a55a5,
+  0xaff,
+  0x5a3da5,
+  0x5b51a4,
+  0x5a68a5,
+  0x5a73a5,
+  0x7ff,
+  0x2eff,
+  0x15ff,
+  0x5c70a3,
+  0x5ff,
+  0x65499a,
+  0xeff,
+  0x3bff,
+  0x2dff,
+  0x5e3ca1,
+  0x4cff,
+  0x9d6462,
+  0xbff,
+  0x47ff,
+  0x1dff,
+0x20272D,
+0xE0354F,
+0xE9374F,
+0xE0354F,
+0xE9374F,
+0xE1E6E8,
